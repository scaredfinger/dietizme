schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

input activate_organization_features_input {
  category_ids: [String!]!
  organization_id: uuid!
}

"""
Oauth requests, inserted before redirecting to the provider's site. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authProviderRequests {
  id: uuid!
  options(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "auth.provider_requests"
"""
type authProviderRequests_aggregate {
  aggregate: authProviderRequests_aggregate_fields
  nodes: [authProviderRequests!]!
}

"""
aggregate fields of "auth.provider_requests"
"""
type authProviderRequests_aggregate_fields {
  count(columns: [authProviderRequests_select_column!], distinct: Boolean): Int!
  max: authProviderRequests_max_fields
  min: authProviderRequests_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input authProviderRequests_append_input {
  options: jsonb
}

"""
Boolean expression to filter rows from the table "auth.provider_requests". All fields are combined with a logical 'AND'.
"""
input authProviderRequests_bool_exp {
  _and: [authProviderRequests_bool_exp!]
  _not: authProviderRequests_bool_exp
  _or: [authProviderRequests_bool_exp!]
  id: uuid_comparison_exp
  options: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "auth.provider_requests"
"""
enum authProviderRequests_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  provider_requests_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input authProviderRequests_delete_at_path_input {
  options: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input authProviderRequests_delete_elem_input {
  options: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input authProviderRequests_delete_key_input {
  options: String
}

"""
input type for inserting data into table "auth.provider_requests"
"""
input authProviderRequests_insert_input {
  id: uuid
  options: jsonb
}

"""aggregate max on columns"""
type authProviderRequests_max_fields {
  id: uuid
}

"""aggregate min on columns"""
type authProviderRequests_min_fields {
  id: uuid
}

"""
response of any mutation on the table "auth.provider_requests"
"""
type authProviderRequests_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authProviderRequests!]!
}

"""
on_conflict condition type for table "auth.provider_requests"
"""
input authProviderRequests_on_conflict {
  constraint: authProviderRequests_constraint!
  update_columns: [authProviderRequests_update_column!]! = []
  where: authProviderRequests_bool_exp
}

"""Ordering options when selecting data from "auth.provider_requests"."""
input authProviderRequests_order_by {
  id: order_by
  options: order_by
}

"""primary key columns input for table: auth.provider_requests"""
input authProviderRequests_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input authProviderRequests_prepend_input {
  options: jsonb
}

"""
select columns of table "auth.provider_requests"
"""
enum authProviderRequests_select_column {
  """column name"""
  id

  """column name"""
  options
}

"""
input type for updating data in table "auth.provider_requests"
"""
input authProviderRequests_set_input {
  id: uuid
  options: jsonb
}

"""
Streaming cursor of the table "authProviderRequests"
"""
input authProviderRequests_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authProviderRequests_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authProviderRequests_stream_cursor_value_input {
  id: uuid
  options: jsonb
}

"""
update columns of table "auth.provider_requests"
"""
enum authProviderRequests_update_column {
  """column name"""
  id

  """column name"""
  options
}

input authProviderRequests_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: authProviderRequests_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: authProviderRequests_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: authProviderRequests_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: authProviderRequests_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: authProviderRequests_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: authProviderRequests_set_input

  """filter the rows which have to be updated"""
  where: authProviderRequests_bool_exp!
}

"""
List of available Oauth providers. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authProviders {
  id: String!

  """An array relationship"""
  userProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """An aggregate relationship"""
  userProviders_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!
}

"""
aggregated selection of "auth.providers"
"""
type authProviders_aggregate {
  aggregate: authProviders_aggregate_fields
  nodes: [authProviders!]!
}

"""
aggregate fields of "auth.providers"
"""
type authProviders_aggregate_fields {
  count(columns: [authProviders_select_column!], distinct: Boolean): Int!
  max: authProviders_max_fields
  min: authProviders_min_fields
}

"""
Boolean expression to filter rows from the table "auth.providers". All fields are combined with a logical 'AND'.
"""
input authProviders_bool_exp {
  _and: [authProviders_bool_exp!]
  _not: authProviders_bool_exp
  _or: [authProviders_bool_exp!]
  id: String_comparison_exp
  userProviders: authUserProviders_bool_exp
  userProviders_aggregate: authUserProviders_aggregate_bool_exp
}

"""
unique or primary key constraints on table "auth.providers"
"""
enum authProviders_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  providers_pkey
}

"""
input type for inserting data into table "auth.providers"
"""
input authProviders_insert_input {
  id: String
  userProviders: authUserProviders_arr_rel_insert_input
}

"""aggregate max on columns"""
type authProviders_max_fields {
  id: String
}

"""aggregate min on columns"""
type authProviders_min_fields {
  id: String
}

"""
response of any mutation on the table "auth.providers"
"""
type authProviders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authProviders!]!
}

"""
input type for inserting object relation for remote table "auth.providers"
"""
input authProviders_obj_rel_insert_input {
  data: authProviders_insert_input!

  """upsert condition"""
  on_conflict: authProviders_on_conflict
}

"""
on_conflict condition type for table "auth.providers"
"""
input authProviders_on_conflict {
  constraint: authProviders_constraint!
  update_columns: [authProviders_update_column!]! = []
  where: authProviders_bool_exp
}

"""Ordering options when selecting data from "auth.providers"."""
input authProviders_order_by {
  id: order_by
  userProviders_aggregate: authUserProviders_aggregate_order_by
}

"""primary key columns input for table: auth.providers"""
input authProviders_pk_columns_input {
  id: String!
}

"""
select columns of table "auth.providers"
"""
enum authProviders_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "auth.providers"
"""
input authProviders_set_input {
  id: String
}

"""
Streaming cursor of the table "authProviders"
"""
input authProviders_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authProviders_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authProviders_stream_cursor_value_input {
  id: String
}

"""
update columns of table "auth.providers"
"""
enum authProviders_update_column {
  """column name"""
  id
}

input authProviders_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authProviders_set_input

  """filter the rows which have to be updated"""
  where: authProviders_bool_exp!
}

"""
columns and relationships of "auth.refresh_token_types"
"""
type authRefreshTokenTypes {
  comment: String

  """An array relationship"""
  refreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """An aggregate relationship"""
  refreshTokens_aggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!
  value: String!
}

"""
aggregated selection of "auth.refresh_token_types"
"""
type authRefreshTokenTypes_aggregate {
  aggregate: authRefreshTokenTypes_aggregate_fields
  nodes: [authRefreshTokenTypes!]!
}

"""
aggregate fields of "auth.refresh_token_types"
"""
type authRefreshTokenTypes_aggregate_fields {
  count(columns: [authRefreshTokenTypes_select_column!], distinct: Boolean): Int!
  max: authRefreshTokenTypes_max_fields
  min: authRefreshTokenTypes_min_fields
}

"""
Boolean expression to filter rows from the table "auth.refresh_token_types". All fields are combined with a logical 'AND'.
"""
input authRefreshTokenTypes_bool_exp {
  _and: [authRefreshTokenTypes_bool_exp!]
  _not: authRefreshTokenTypes_bool_exp
  _or: [authRefreshTokenTypes_bool_exp!]
  comment: String_comparison_exp
  refreshTokens: authRefreshTokens_bool_exp
  refreshTokens_aggregate: authRefreshTokens_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "auth.refresh_token_types"
"""
enum authRefreshTokenTypes_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  refresh_token_types_pkey
}

enum authRefreshTokenTypes_enum {
  """Personal access token"""
  pat

  """Regular refresh token"""
  regular
}

"""
Boolean expression to compare columns of type "authRefreshTokenTypes_enum". All fields are combined with logical 'AND'.
"""
input authRefreshTokenTypes_enum_comparison_exp {
  _eq: authRefreshTokenTypes_enum
  _in: [authRefreshTokenTypes_enum!]
  _is_null: Boolean
  _neq: authRefreshTokenTypes_enum
  _nin: [authRefreshTokenTypes_enum!]
}

"""
input type for inserting data into table "auth.refresh_token_types"
"""
input authRefreshTokenTypes_insert_input {
  comment: String
  refreshTokens: authRefreshTokens_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type authRefreshTokenTypes_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type authRefreshTokenTypes_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "auth.refresh_token_types"
"""
type authRefreshTokenTypes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRefreshTokenTypes!]!
}

"""
on_conflict condition type for table "auth.refresh_token_types"
"""
input authRefreshTokenTypes_on_conflict {
  constraint: authRefreshTokenTypes_constraint!
  update_columns: [authRefreshTokenTypes_update_column!]! = []
  where: authRefreshTokenTypes_bool_exp
}

"""Ordering options when selecting data from "auth.refresh_token_types"."""
input authRefreshTokenTypes_order_by {
  comment: order_by
  refreshTokens_aggregate: authRefreshTokens_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: auth.refresh_token_types"""
input authRefreshTokenTypes_pk_columns_input {
  value: String!
}

"""
select columns of table "auth.refresh_token_types"
"""
enum authRefreshTokenTypes_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "auth.refresh_token_types"
"""
input authRefreshTokenTypes_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "authRefreshTokenTypes"
"""
input authRefreshTokenTypes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authRefreshTokenTypes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authRefreshTokenTypes_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "auth.refresh_token_types"
"""
enum authRefreshTokenTypes_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input authRefreshTokenTypes_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authRefreshTokenTypes_set_input

  """filter the rows which have to be updated"""
  where: authRefreshTokenTypes_bool_exp!
}

"""
User refresh tokens. Hasura auth uses them to rotate new access tokens as long as the refresh token is not expired. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authRefreshTokens {
  createdAt: timestamptz!
  expiresAt: timestamptz!
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  refreshTokenHash: String
  type: authRefreshTokenTypes_enum!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.refresh_tokens"
"""
type authRefreshTokens_aggregate {
  aggregate: authRefreshTokens_aggregate_fields
  nodes: [authRefreshTokens!]!
}

input authRefreshTokens_aggregate_bool_exp {
  count: authRefreshTokens_aggregate_bool_exp_count
}

input authRefreshTokens_aggregate_bool_exp_count {
  arguments: [authRefreshTokens_select_column!]
  distinct: Boolean
  filter: authRefreshTokens_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.refresh_tokens"
"""
type authRefreshTokens_aggregate_fields {
  count(columns: [authRefreshTokens_select_column!], distinct: Boolean): Int!
  max: authRefreshTokens_max_fields
  min: authRefreshTokens_min_fields
}

"""
order by aggregate values of table "auth.refresh_tokens"
"""
input authRefreshTokens_aggregate_order_by {
  count: order_by
  max: authRefreshTokens_max_order_by
  min: authRefreshTokens_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input authRefreshTokens_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "auth.refresh_tokens"
"""
input authRefreshTokens_arr_rel_insert_input {
  data: [authRefreshTokens_insert_input!]!

  """upsert condition"""
  on_conflict: authRefreshTokens_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'.
"""
input authRefreshTokens_bool_exp {
  _and: [authRefreshTokens_bool_exp!]
  _not: authRefreshTokens_bool_exp
  _or: [authRefreshTokens_bool_exp!]
  createdAt: timestamptz_comparison_exp
  expiresAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  refreshTokenHash: String_comparison_exp
  type: authRefreshTokenTypes_enum_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.refresh_tokens"
"""
enum authRefreshTokens_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  refresh_tokens_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input authRefreshTokens_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input authRefreshTokens_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input authRefreshTokens_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "auth.refresh_tokens"
"""
input authRefreshTokens_insert_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  metadata: jsonb
  refreshTokenHash: String
  type: authRefreshTokenTypes_enum
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authRefreshTokens_max_fields {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  refreshTokenHash: String
  userId: uuid
}

"""
order by max() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_max_order_by {
  createdAt: order_by
  expiresAt: order_by
  id: order_by
  refreshTokenHash: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authRefreshTokens_min_fields {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  refreshTokenHash: String
  userId: uuid
}

"""
order by min() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_min_order_by {
  createdAt: order_by
  expiresAt: order_by
  id: order_by
  refreshTokenHash: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.refresh_tokens"
"""
type authRefreshTokens_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRefreshTokens!]!
}

"""
on_conflict condition type for table "auth.refresh_tokens"
"""
input authRefreshTokens_on_conflict {
  constraint: authRefreshTokens_constraint!
  update_columns: [authRefreshTokens_update_column!]! = []
  where: authRefreshTokens_bool_exp
}

"""Ordering options when selecting data from "auth.refresh_tokens"."""
input authRefreshTokens_order_by {
  createdAt: order_by
  expiresAt: order_by
  id: order_by
  metadata: order_by
  refreshTokenHash: order_by
  type: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.refresh_tokens"""
input authRefreshTokens_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input authRefreshTokens_prepend_input {
  metadata: jsonb
}

"""
select columns of table "auth.refresh_tokens"
"""
enum authRefreshTokens_select_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  refreshTokenHash

  """column name"""
  type

  """column name"""
  userId
}

"""
input type for updating data in table "auth.refresh_tokens"
"""
input authRefreshTokens_set_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  metadata: jsonb
  refreshTokenHash: String
  type: authRefreshTokenTypes_enum
  userId: uuid
}

"""
Streaming cursor of the table "authRefreshTokens"
"""
input authRefreshTokens_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authRefreshTokens_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authRefreshTokens_stream_cursor_value_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  metadata: jsonb
  refreshTokenHash: String
  type: authRefreshTokenTypes_enum
  userId: uuid
}

"""
update columns of table "auth.refresh_tokens"
"""
enum authRefreshTokens_update_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  refreshTokenHash

  """column name"""
  type

  """column name"""
  userId
}

input authRefreshTokens_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: authRefreshTokens_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: authRefreshTokens_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: authRefreshTokens_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: authRefreshTokens_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: authRefreshTokens_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: authRefreshTokens_set_input

  """filter the rows which have to be updated"""
  where: authRefreshTokens_bool_exp!
}

"""
Persistent Hasura roles for users. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authRoles {
  role: String!

  """An array relationship"""
  userRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """An aggregate relationship"""
  userRoles_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """An array relationship"""
  usersByDefaultRole(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  usersByDefaultRole_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
}

"""
aggregated selection of "auth.roles"
"""
type authRoles_aggregate {
  aggregate: authRoles_aggregate_fields
  nodes: [authRoles!]!
}

"""
aggregate fields of "auth.roles"
"""
type authRoles_aggregate_fields {
  count(columns: [authRoles_select_column!], distinct: Boolean): Int!
  max: authRoles_max_fields
  min: authRoles_min_fields
}

"""
Boolean expression to filter rows from the table "auth.roles". All fields are combined with a logical 'AND'.
"""
input authRoles_bool_exp {
  _and: [authRoles_bool_exp!]
  _not: authRoles_bool_exp
  _or: [authRoles_bool_exp!]
  role: String_comparison_exp
  userRoles: authUserRoles_bool_exp
  userRoles_aggregate: authUserRoles_aggregate_bool_exp
  usersByDefaultRole: users_bool_exp
  usersByDefaultRole_aggregate: users_aggregate_bool_exp
}

"""
unique or primary key constraints on table "auth.roles"
"""
enum authRoles_constraint {
  """
  unique or primary key constraint on columns "role"
  """
  roles_pkey
}

"""
input type for inserting data into table "auth.roles"
"""
input authRoles_insert_input {
  role: String
  userRoles: authUserRoles_arr_rel_insert_input
  usersByDefaultRole: users_arr_rel_insert_input
}

"""aggregate max on columns"""
type authRoles_max_fields {
  role: String
}

"""aggregate min on columns"""
type authRoles_min_fields {
  role: String
}

"""
response of any mutation on the table "auth.roles"
"""
type authRoles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRoles!]!
}

"""
input type for inserting object relation for remote table "auth.roles"
"""
input authRoles_obj_rel_insert_input {
  data: authRoles_insert_input!

  """upsert condition"""
  on_conflict: authRoles_on_conflict
}

"""
on_conflict condition type for table "auth.roles"
"""
input authRoles_on_conflict {
  constraint: authRoles_constraint!
  update_columns: [authRoles_update_column!]! = []
  where: authRoles_bool_exp
}

"""Ordering options when selecting data from "auth.roles"."""
input authRoles_order_by {
  role: order_by
  userRoles_aggregate: authUserRoles_aggregate_order_by
  usersByDefaultRole_aggregate: users_aggregate_order_by
}

"""primary key columns input for table: auth.roles"""
input authRoles_pk_columns_input {
  role: String!
}

"""
select columns of table "auth.roles"
"""
enum authRoles_select_column {
  """column name"""
  role
}

"""
input type for updating data in table "auth.roles"
"""
input authRoles_set_input {
  role: String
}

"""
Streaming cursor of the table "authRoles"
"""
input authRoles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authRoles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authRoles_stream_cursor_value_input {
  role: String
}

"""
update columns of table "auth.roles"
"""
enum authRoles_update_column {
  """column name"""
  role
}

input authRoles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authRoles_set_input

  """filter the rows which have to be updated"""
  where: authRoles_bool_exp!
}

"""
Active providers for a given user. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserProviders {
  accessToken: String!
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  provider: authProviders!
  providerId: String!
  providerUserId: String!
  refreshToken: String
  updatedAt: timestamptz!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_providers"
"""
type authUserProviders_aggregate {
  aggregate: authUserProviders_aggregate_fields
  nodes: [authUserProviders!]!
}

input authUserProviders_aggregate_bool_exp {
  count: authUserProviders_aggregate_bool_exp_count
}

input authUserProviders_aggregate_bool_exp_count {
  arguments: [authUserProviders_select_column!]
  distinct: Boolean
  filter: authUserProviders_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.user_providers"
"""
type authUserProviders_aggregate_fields {
  count(columns: [authUserProviders_select_column!], distinct: Boolean): Int!
  max: authUserProviders_max_fields
  min: authUserProviders_min_fields
}

"""
order by aggregate values of table "auth.user_providers"
"""
input authUserProviders_aggregate_order_by {
  count: order_by
  max: authUserProviders_max_order_by
  min: authUserProviders_min_order_by
}

"""
input type for inserting array relation for remote table "auth.user_providers"
"""
input authUserProviders_arr_rel_insert_input {
  data: [authUserProviders_insert_input!]!

  """upsert condition"""
  on_conflict: authUserProviders_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.user_providers". All fields are combined with a logical 'AND'.
"""
input authUserProviders_bool_exp {
  _and: [authUserProviders_bool_exp!]
  _not: authUserProviders_bool_exp
  _or: [authUserProviders_bool_exp!]
  accessToken: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  provider: authProviders_bool_exp
  providerId: String_comparison_exp
  providerUserId: String_comparison_exp
  refreshToken: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_providers"
"""
enum authUserProviders_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_providers_pkey

  """
  unique or primary key constraint on columns "provider_user_id", "provider_id"
  """
  user_providers_provider_id_provider_user_id_key

  """
  unique or primary key constraint on columns "user_id", "provider_id"
  """
  user_providers_user_id_provider_id_key
}

"""
input type for inserting data into table "auth.user_providers"
"""
input authUserProviders_insert_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  provider: authProviders_obj_rel_insert_input
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserProviders_max_fields {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "auth.user_providers"
"""
input authUserProviders_max_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserProviders_min_fields {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "auth.user_providers"
"""
input authUserProviders_min_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_providers"
"""
type authUserProviders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserProviders!]!
}

"""
on_conflict condition type for table "auth.user_providers"
"""
input authUserProviders_on_conflict {
  constraint: authUserProviders_constraint!
  update_columns: [authUserProviders_update_column!]! = []
  where: authUserProviders_bool_exp
}

"""Ordering options when selecting data from "auth.user_providers"."""
input authUserProviders_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  provider: authProviders_order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.user_providers"""
input authUserProviders_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_providers"
"""
enum authUserProviders_select_column {
  """column name"""
  accessToken

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  providerId

  """column name"""
  providerUserId

  """column name"""
  refreshToken

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_providers"
"""
input authUserProviders_set_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "authUserProviders"
"""
input authUserProviders_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserProviders_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserProviders_stream_cursor_value_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "auth.user_providers"
"""
enum authUserProviders_update_column {
  """column name"""
  accessToken

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  providerId

  """column name"""
  providerUserId

  """column name"""
  refreshToken

  """column name"""
  updatedAt

  """column name"""
  userId
}

input authUserProviders_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authUserProviders_set_input

  """filter the rows which have to be updated"""
  where: authUserProviders_bool_exp!
}

"""
Roles of users. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserRoles {
  createdAt: timestamptz!
  id: uuid!
  role: String!

  """An object relationship"""
  roleByRole: authRoles!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_roles"
"""
type authUserRoles_aggregate {
  aggregate: authUserRoles_aggregate_fields
  nodes: [authUserRoles!]!
}

input authUserRoles_aggregate_bool_exp {
  count: authUserRoles_aggregate_bool_exp_count
}

input authUserRoles_aggregate_bool_exp_count {
  arguments: [authUserRoles_select_column!]
  distinct: Boolean
  filter: authUserRoles_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.user_roles"
"""
type authUserRoles_aggregate_fields {
  count(columns: [authUserRoles_select_column!], distinct: Boolean): Int!
  max: authUserRoles_max_fields
  min: authUserRoles_min_fields
}

"""
order by aggregate values of table "auth.user_roles"
"""
input authUserRoles_aggregate_order_by {
  count: order_by
  max: authUserRoles_max_order_by
  min: authUserRoles_min_order_by
}

"""
input type for inserting array relation for remote table "auth.user_roles"
"""
input authUserRoles_arr_rel_insert_input {
  data: [authUserRoles_insert_input!]!

  """upsert condition"""
  on_conflict: authUserRoles_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.user_roles". All fields are combined with a logical 'AND'.
"""
input authUserRoles_bool_exp {
  _and: [authUserRoles_bool_exp!]
  _not: authUserRoles_bool_exp
  _or: [authUserRoles_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  role: String_comparison_exp
  roleByRole: authRoles_bool_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_roles"
"""
enum authUserRoles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_roles_pkey

  """
  unique or primary key constraint on columns "user_id", "role"
  """
  user_roles_user_id_role_key
}

"""
input type for inserting data into table "auth.user_roles"
"""
input authUserRoles_insert_input {
  createdAt: timestamptz
  id: uuid
  role: String
  roleByRole: authRoles_obj_rel_insert_input
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserRoles_max_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
order by max() on columns of table "auth.user_roles"
"""
input authUserRoles_max_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserRoles_min_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
order by min() on columns of table "auth.user_roles"
"""
input authUserRoles_min_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_roles"
"""
type authUserRoles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserRoles!]!
}

"""
on_conflict condition type for table "auth.user_roles"
"""
input authUserRoles_on_conflict {
  constraint: authUserRoles_constraint!
  update_columns: [authUserRoles_update_column!]! = []
  where: authUserRoles_bool_exp
}

"""Ordering options when selecting data from "auth.user_roles"."""
input authUserRoles_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  roleByRole: authRoles_order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.user_roles"""
input authUserRoles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_roles"
"""
enum authUserRoles_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  role

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_roles"
"""
input authUserRoles_set_input {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
Streaming cursor of the table "authUserRoles"
"""
input authUserRoles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserRoles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserRoles_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
update columns of table "auth.user_roles"
"""
enum authUserRoles_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  role

  """column name"""
  userId
}

input authUserRoles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authUserRoles_set_input

  """filter the rows which have to be updated"""
  where: authUserRoles_bool_exp!
}

"""
User webauthn security keys. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserSecurityKeys {
  counter: bigint!
  credentialId: String!
  credentialPublicKey: bytea
  id: uuid!
  nickname: String
  transports: String!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_security_keys"
"""
type authUserSecurityKeys_aggregate {
  aggregate: authUserSecurityKeys_aggregate_fields
  nodes: [authUserSecurityKeys!]!
}

input authUserSecurityKeys_aggregate_bool_exp {
  count: authUserSecurityKeys_aggregate_bool_exp_count
}

input authUserSecurityKeys_aggregate_bool_exp_count {
  arguments: [authUserSecurityKeys_select_column!]
  distinct: Boolean
  filter: authUserSecurityKeys_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.user_security_keys"
"""
type authUserSecurityKeys_aggregate_fields {
  avg: authUserSecurityKeys_avg_fields
  count(columns: [authUserSecurityKeys_select_column!], distinct: Boolean): Int!
  max: authUserSecurityKeys_max_fields
  min: authUserSecurityKeys_min_fields
  stddev: authUserSecurityKeys_stddev_fields
  stddev_pop: authUserSecurityKeys_stddev_pop_fields
  stddev_samp: authUserSecurityKeys_stddev_samp_fields
  sum: authUserSecurityKeys_sum_fields
  var_pop: authUserSecurityKeys_var_pop_fields
  var_samp: authUserSecurityKeys_var_samp_fields
  variance: authUserSecurityKeys_variance_fields
}

"""
order by aggregate values of table "auth.user_security_keys"
"""
input authUserSecurityKeys_aggregate_order_by {
  avg: authUserSecurityKeys_avg_order_by
  count: order_by
  max: authUserSecurityKeys_max_order_by
  min: authUserSecurityKeys_min_order_by
  stddev: authUserSecurityKeys_stddev_order_by
  stddev_pop: authUserSecurityKeys_stddev_pop_order_by
  stddev_samp: authUserSecurityKeys_stddev_samp_order_by
  sum: authUserSecurityKeys_sum_order_by
  var_pop: authUserSecurityKeys_var_pop_order_by
  var_samp: authUserSecurityKeys_var_samp_order_by
  variance: authUserSecurityKeys_variance_order_by
}

"""
input type for inserting array relation for remote table "auth.user_security_keys"
"""
input authUserSecurityKeys_arr_rel_insert_input {
  data: [authUserSecurityKeys_insert_input!]!

  """upsert condition"""
  on_conflict: authUserSecurityKeys_on_conflict
}

"""aggregate avg on columns"""
type authUserSecurityKeys_avg_fields {
  counter: Float
}

"""
order by avg() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_avg_order_by {
  counter: order_by
}

"""
Boolean expression to filter rows from the table "auth.user_security_keys". All fields are combined with a logical 'AND'.
"""
input authUserSecurityKeys_bool_exp {
  _and: [authUserSecurityKeys_bool_exp!]
  _not: authUserSecurityKeys_bool_exp
  _or: [authUserSecurityKeys_bool_exp!]
  counter: bigint_comparison_exp
  credentialId: String_comparison_exp
  credentialPublicKey: bytea_comparison_exp
  id: uuid_comparison_exp
  nickname: String_comparison_exp
  transports: String_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_security_keys"
"""
enum authUserSecurityKeys_constraint {
  """
  unique or primary key constraint on columns "credential_id"
  """
  user_security_key_credential_id_key

  """
  unique or primary key constraint on columns "id"
  """
  user_security_keys_pkey
}

"""
input type for incrementing numeric columns in table "auth.user_security_keys"
"""
input authUserSecurityKeys_inc_input {
  counter: bigint
}

"""
input type for inserting data into table "auth.user_security_keys"
"""
input authUserSecurityKeys_insert_input {
  counter: bigint
  credentialId: String
  credentialPublicKey: bytea
  id: uuid
  nickname: String
  transports: String
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserSecurityKeys_max_fields {
  counter: bigint
  credentialId: String
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""
order by max() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_max_order_by {
  counter: order_by
  credentialId: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserSecurityKeys_min_fields {
  counter: bigint
  credentialId: String
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""
order by min() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_min_order_by {
  counter: order_by
  credentialId: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_security_keys"
"""
type authUserSecurityKeys_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserSecurityKeys!]!
}

"""
on_conflict condition type for table "auth.user_security_keys"
"""
input authUserSecurityKeys_on_conflict {
  constraint: authUserSecurityKeys_constraint!
  update_columns: [authUserSecurityKeys_update_column!]! = []
  where: authUserSecurityKeys_bool_exp
}

"""Ordering options when selecting data from "auth.user_security_keys"."""
input authUserSecurityKeys_order_by {
  counter: order_by
  credentialId: order_by
  credentialPublicKey: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.user_security_keys"""
input authUserSecurityKeys_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_security_keys"
"""
enum authUserSecurityKeys_select_column {
  """column name"""
  counter

  """column name"""
  credentialId

  """column name"""
  credentialPublicKey

  """column name"""
  id

  """column name"""
  nickname

  """column name"""
  transports

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_security_keys"
"""
input authUserSecurityKeys_set_input {
  counter: bigint
  credentialId: String
  credentialPublicKey: bytea
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""aggregate stddev on columns"""
type authUserSecurityKeys_stddev_fields {
  counter: Float
}

"""
order by stddev() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_order_by {
  counter: order_by
}

"""aggregate stddev_pop on columns"""
type authUserSecurityKeys_stddev_pop_fields {
  counter: Float
}

"""
order by stddev_pop() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_pop_order_by {
  counter: order_by
}

"""aggregate stddev_samp on columns"""
type authUserSecurityKeys_stddev_samp_fields {
  counter: Float
}

"""
order by stddev_samp() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_samp_order_by {
  counter: order_by
}

"""
Streaming cursor of the table "authUserSecurityKeys"
"""
input authUserSecurityKeys_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserSecurityKeys_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserSecurityKeys_stream_cursor_value_input {
  counter: bigint
  credentialId: String
  credentialPublicKey: bytea
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""aggregate sum on columns"""
type authUserSecurityKeys_sum_fields {
  counter: bigint
}

"""
order by sum() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_sum_order_by {
  counter: order_by
}

"""
update columns of table "auth.user_security_keys"
"""
enum authUserSecurityKeys_update_column {
  """column name"""
  counter

  """column name"""
  credentialId

  """column name"""
  credentialPublicKey

  """column name"""
  id

  """column name"""
  nickname

  """column name"""
  transports

  """column name"""
  userId
}

input authUserSecurityKeys_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: authUserSecurityKeys_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: authUserSecurityKeys_set_input

  """filter the rows which have to be updated"""
  where: authUserSecurityKeys_bool_exp!
}

"""aggregate var_pop on columns"""
type authUserSecurityKeys_var_pop_fields {
  counter: Float
}

"""
order by var_pop() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_var_pop_order_by {
  counter: order_by
}

"""aggregate var_samp on columns"""
type authUserSecurityKeys_var_samp_fields {
  counter: Float
}

"""
order by var_samp() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_var_samp_order_by {
  counter: order_by
}

"""aggregate variance on columns"""
type authUserSecurityKeys_variance_fields {
  counter: Float
}

"""
order by variance() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_variance_order_by {
  counter: order_by
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "booking"
"""
type booking {
  amount: numeric!
  booking_answers_by_id(
    """JSON select path"""
    path: String
  ): json!

  """An object relationship"""
  contact: contact!
  contact_id: uuid!
  created_on: timestamptz!
  friendly_id: String!

  """An array relationship"""
  history_entries(
    """distinct select on columns"""
    distinct_on: [booking_history_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_history_entry_order_by!]

    """filter the rows returned"""
    where: booking_history_entry_bool_exp
  ): [booking_history_entry!]!

  """An aggregate relationship"""
  history_entries_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_history_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_history_entry_order_by!]

    """filter the rows returned"""
    where: booking_history_entry_bool_exp
  ): booking_history_entry_aggregate!
  id: uuid!
  last_modified_on: timestamptz!
  locale: String!

  """An object relationship"""
  organization: organization!
  organization_id: uuid!

  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [booking_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_product_order_by!]

    """filter the rows returned"""
    where: booking_product_bool_exp
  ): [booking_product!]!

  """An aggregate relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_product_order_by!]

    """filter the rows returned"""
    where: booking_product_bool_exp
  ): booking_product_aggregate!
  questions_by_scope_by_id(
    """JSON select path"""
    path: String
  ): json!
  state: booking_state_enum!
  version: numeric!
}

input booking_accept_input {
  expected_version: numeric!
  id: uuid!
}

input booking_add_note_input {
  expected_version: numeric!
  id: uuid!
  note: String!
}

"""
aggregated selection of "booking"
"""
type booking_aggregate {
  aggregate: booking_aggregate_fields
  nodes: [booking!]!
}

input booking_aggregate_bool_exp {
  count: booking_aggregate_bool_exp_count
}

input booking_aggregate_bool_exp_count {
  arguments: [booking_select_column!]
  distinct: Boolean
  filter: booking_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "booking"
"""
type booking_aggregate_fields {
  avg: booking_avg_fields
  count(columns: [booking_select_column!], distinct: Boolean): Int!
  max: booking_max_fields
  min: booking_min_fields
  stddev: booking_stddev_fields
  stddev_pop: booking_stddev_pop_fields
  stddev_samp: booking_stddev_samp_fields
  sum: booking_sum_fields
  var_pop: booking_var_pop_fields
  var_samp: booking_var_samp_fields
  variance: booking_variance_fields
}

"""
order by aggregate values of table "booking"
"""
input booking_aggregate_order_by {
  avg: booking_avg_order_by
  count: order_by
  max: booking_max_order_by
  min: booking_min_order_by
  stddev: booking_stddev_order_by
  stddev_pop: booking_stddev_pop_order_by
  stddev_samp: booking_stddev_samp_order_by
  sum: booking_sum_order_by
  var_pop: booking_var_pop_order_by
  var_samp: booking_var_samp_order_by
  variance: booking_variance_order_by
}

"""
input type for inserting array relation for remote table "booking"
"""
input booking_arr_rel_insert_input {
  data: [booking_insert_input!]!

  """upsert condition"""
  on_conflict: booking_on_conflict
}

"""aggregate avg on columns"""
type booking_avg_fields {
  amount: Float
  version: Float
}

"""
order by avg() on columns of table "booking"
"""
input booking_avg_order_by {
  amount: order_by
  version: order_by
}

"""
Boolean expression to filter rows from the table "booking". All fields are combined with a logical 'AND'.
"""
input booking_bool_exp {
  _and: [booking_bool_exp!]
  _not: booking_bool_exp
  _or: [booking_bool_exp!]
  amount: numeric_comparison_exp
  booking_answers_by_id: json_comparison_exp
  contact: contact_bool_exp
  contact_id: uuid_comparison_exp
  created_on: timestamptz_comparison_exp
  friendly_id: String_comparison_exp
  history_entries: booking_history_entry_bool_exp
  history_entries_aggregate: booking_history_entry_aggregate_bool_exp
  id: uuid_comparison_exp
  last_modified_on: timestamptz_comparison_exp
  locale: String_comparison_exp
  organization: organization_bool_exp
  organization_id: uuid_comparison_exp
  products: booking_product_bool_exp
  products_aggregate: booking_product_aggregate_bool_exp
  questions_by_scope_by_id: json_comparison_exp
  state: booking_state_enum_comparison_exp
  version: numeric_comparison_exp
}

input booking_cancel_input {
  expected_version: numeric!
  id: uuid!
}

"""
unique or primary key constraints on table "booking"
"""
enum booking_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  booking_pkey

  """
  unique or primary key constraint on columns "friendly_id", "organization_id"
  """
  friendly_id_ukey
}

input booking_contact_input {
  email: String!
  name: String!
}

input booking_create_input {
  answers: booking_questions_answers_by_scope!
  contact: booking_contact_input!
  friendly_id: String!
  id: uuid
  items: [booking_item_input!]!
  locale: String!
  organization_id: uuid!
}

"""
columns and relationships of "booking_events.event_type"
"""
type booking_events_event_type {
  description: String!
  id: String!
}

"""
aggregated selection of "booking_events.event_type"
"""
type booking_events_event_type_aggregate {
  aggregate: booking_events_event_type_aggregate_fields
  nodes: [booking_events_event_type!]!
}

"""
aggregate fields of "booking_events.event_type"
"""
type booking_events_event_type_aggregate_fields {
  count(columns: [booking_events_event_type_select_column!], distinct: Boolean): Int!
  max: booking_events_event_type_max_fields
  min: booking_events_event_type_min_fields
}

"""
Boolean expression to filter rows from the table "booking_events.event_type". All fields are combined with a logical 'AND'.
"""
input booking_events_event_type_bool_exp {
  _and: [booking_events_event_type_bool_exp!]
  _not: booking_events_event_type_bool_exp
  _or: [booking_events_event_type_bool_exp!]
  description: String_comparison_exp
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "booking_events.event_type"
"""
enum booking_events_event_type_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  event_type_pkey
}

enum booking_events_event_type_enum {
  """Accepted"""
  ACCEPTED

  """Created"""
  CREATED

  """Customer cancelled"""
  CUSTOMER_CANCELLED

  """Note added"""
  NOTE_ADDED

  """Owner cancelled"""
  OWNER_CANCELLED

  """Rejected"""
  REJECTED
}

"""
Boolean expression to compare columns of type "booking_events_event_type_enum". All fields are combined with logical 'AND'.
"""
input booking_events_event_type_enum_comparison_exp {
  _eq: booking_events_event_type_enum
  _in: [booking_events_event_type_enum!]
  _is_null: Boolean
  _neq: booking_events_event_type_enum
  _nin: [booking_events_event_type_enum!]
}

"""
input type for inserting data into table "booking_events.event_type"
"""
input booking_events_event_type_insert_input {
  description: String
  id: String
}

"""aggregate max on columns"""
type booking_events_event_type_max_fields {
  description: String
  id: String
}

"""aggregate min on columns"""
type booking_events_event_type_min_fields {
  description: String
  id: String
}

"""
response of any mutation on the table "booking_events.event_type"
"""
type booking_events_event_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [booking_events_event_type!]!
}

"""
on_conflict condition type for table "booking_events.event_type"
"""
input booking_events_event_type_on_conflict {
  constraint: booking_events_event_type_constraint!
  update_columns: [booking_events_event_type_update_column!]! = []
  where: booking_events_event_type_bool_exp
}

"""Ordering options when selecting data from "booking_events.event_type"."""
input booking_events_event_type_order_by {
  description: order_by
  id: order_by
}

"""primary key columns input for table: booking_events.event_type"""
input booking_events_event_type_pk_columns_input {
  id: String!
}

"""
select columns of table "booking_events.event_type"
"""
enum booking_events_event_type_select_column {
  """column name"""
  description

  """column name"""
  id
}

"""
input type for updating data in table "booking_events.event_type"
"""
input booking_events_event_type_set_input {
  description: String
  id: String
}

"""
Streaming cursor of the table "booking_events_event_type"
"""
input booking_events_event_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: booking_events_event_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input booking_events_event_type_stream_cursor_value_input {
  description: String
  id: String
}

"""
update columns of table "booking_events.event_type"
"""
enum booking_events_event_type_update_column {
  """column name"""
  description

  """column name"""
  id
}

input booking_events_event_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: booking_events_event_type_set_input

  """filter the rows which have to be updated"""
  where: booking_events_event_type_bool_exp!
}

"""
columns and relationships of "booking_events.main"
"""
type booking_events_main {
  booking_id: uuid!
  id: uuid!
  payload(
    """JSON select path"""
    path: String
  ): json!
  timestamp: timestamptz!
  type: booking_events_event_type_enum!
  user_id: uuid
  version: Int!
}

"""
aggregated selection of "booking_events.main"
"""
type booking_events_main_aggregate {
  aggregate: booking_events_main_aggregate_fields
  nodes: [booking_events_main!]!
}

"""
aggregate fields of "booking_events.main"
"""
type booking_events_main_aggregate_fields {
  avg: booking_events_main_avg_fields
  count(columns: [booking_events_main_select_column!], distinct: Boolean): Int!
  max: booking_events_main_max_fields
  min: booking_events_main_min_fields
  stddev: booking_events_main_stddev_fields
  stddev_pop: booking_events_main_stddev_pop_fields
  stddev_samp: booking_events_main_stddev_samp_fields
  sum: booking_events_main_sum_fields
  var_pop: booking_events_main_var_pop_fields
  var_samp: booking_events_main_var_samp_fields
  variance: booking_events_main_variance_fields
}

"""aggregate avg on columns"""
type booking_events_main_avg_fields {
  version: Float
}

"""
Boolean expression to filter rows from the table "booking_events.main". All fields are combined with a logical 'AND'.
"""
input booking_events_main_bool_exp {
  _and: [booking_events_main_bool_exp!]
  _not: booking_events_main_bool_exp
  _or: [booking_events_main_bool_exp!]
  booking_id: uuid_comparison_exp
  id: uuid_comparison_exp
  payload: json_comparison_exp
  timestamp: timestamptz_comparison_exp
  type: booking_events_event_type_enum_comparison_exp
  user_id: uuid_comparison_exp
  version: Int_comparison_exp
}

"""
unique or primary key constraints on table "booking_events.main"
"""
enum booking_events_main_constraint {
  """
  unique or primary key constraint on columns "booking_id", "version"
  """
  main_booking_id_version_key

  """
  unique or primary key constraint on columns "id"
  """
  main_pkey
}

"""
input type for incrementing numeric columns in table "booking_events.main"
"""
input booking_events_main_inc_input {
  version: Int
}

"""
input type for inserting data into table "booking_events.main"
"""
input booking_events_main_insert_input {
  booking_id: uuid
  id: uuid
  payload: json
  timestamp: timestamptz
  type: booking_events_event_type_enum
  user_id: uuid
  version: Int
}

"""aggregate max on columns"""
type booking_events_main_max_fields {
  booking_id: uuid
  id: uuid
  timestamp: timestamptz
  user_id: uuid
  version: Int
}

"""aggregate min on columns"""
type booking_events_main_min_fields {
  booking_id: uuid
  id: uuid
  timestamp: timestamptz
  user_id: uuid
  version: Int
}

"""
response of any mutation on the table "booking_events.main"
"""
type booking_events_main_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [booking_events_main!]!
}

"""
on_conflict condition type for table "booking_events.main"
"""
input booking_events_main_on_conflict {
  constraint: booking_events_main_constraint!
  update_columns: [booking_events_main_update_column!]! = []
  where: booking_events_main_bool_exp
}

"""Ordering options when selecting data from "booking_events.main"."""
input booking_events_main_order_by {
  booking_id: order_by
  id: order_by
  payload: order_by
  timestamp: order_by
  type: order_by
  user_id: order_by
  version: order_by
}

"""primary key columns input for table: booking_events.main"""
input booking_events_main_pk_columns_input {
  id: uuid!
}

"""
select columns of table "booking_events.main"
"""
enum booking_events_main_select_column {
  """column name"""
  booking_id

  """column name"""
  id

  """column name"""
  payload

  """column name"""
  timestamp

  """column name"""
  type

  """column name"""
  user_id

  """column name"""
  version
}

"""
input type for updating data in table "booking_events.main"
"""
input booking_events_main_set_input {
  booking_id: uuid
  id: uuid
  payload: json
  timestamp: timestamptz
  type: booking_events_event_type_enum
  user_id: uuid
  version: Int
}

"""aggregate stddev on columns"""
type booking_events_main_stddev_fields {
  version: Float
}

"""aggregate stddev_pop on columns"""
type booking_events_main_stddev_pop_fields {
  version: Float
}

"""aggregate stddev_samp on columns"""
type booking_events_main_stddev_samp_fields {
  version: Float
}

"""
Streaming cursor of the table "booking_events_main"
"""
input booking_events_main_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: booking_events_main_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input booking_events_main_stream_cursor_value_input {
  booking_id: uuid
  id: uuid
  payload: json
  timestamp: timestamptz
  type: booking_events_event_type_enum
  user_id: uuid
  version: Int
}

"""aggregate sum on columns"""
type booking_events_main_sum_fields {
  version: Int
}

"""
update columns of table "booking_events.main"
"""
enum booking_events_main_update_column {
  """column name"""
  booking_id

  """column name"""
  id

  """column name"""
  payload

  """column name"""
  timestamp

  """column name"""
  type

  """column name"""
  user_id

  """column name"""
  version
}

input booking_events_main_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: booking_events_main_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: booking_events_main_set_input

  """filter the rows which have to be updated"""
  where: booking_events_main_bool_exp!
}

"""aggregate var_pop on columns"""
type booking_events_main_var_pop_fields {
  version: Float
}

"""aggregate var_samp on columns"""
type booking_events_main_var_samp_fields {
  version: Float
}

"""aggregate variance on columns"""
type booking_events_main_variance_fields {
  version: Float
}

"""
columns and relationships of "booking_events.version"
"""
type booking_events_version {
  current: numeric!
  id: uuid!
}

"""
aggregated selection of "booking_events.version"
"""
type booking_events_version_aggregate {
  aggregate: booking_events_version_aggregate_fields
  nodes: [booking_events_version!]!
}

"""
aggregate fields of "booking_events.version"
"""
type booking_events_version_aggregate_fields {
  avg: booking_events_version_avg_fields
  count(columns: [booking_events_version_select_column!], distinct: Boolean): Int!
  max: booking_events_version_max_fields
  min: booking_events_version_min_fields
  stddev: booking_events_version_stddev_fields
  stddev_pop: booking_events_version_stddev_pop_fields
  stddev_samp: booking_events_version_stddev_samp_fields
  sum: booking_events_version_sum_fields
  var_pop: booking_events_version_var_pop_fields
  var_samp: booking_events_version_var_samp_fields
  variance: booking_events_version_variance_fields
}

"""aggregate avg on columns"""
type booking_events_version_avg_fields {
  current: Float
}

"""
Boolean expression to filter rows from the table "booking_events.version". All fields are combined with a logical 'AND'.
"""
input booking_events_version_bool_exp {
  _and: [booking_events_version_bool_exp!]
  _not: booking_events_version_bool_exp
  _or: [booking_events_version_bool_exp!]
  current: numeric_comparison_exp
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "booking_events.version"
"""
enum booking_events_version_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  version_pkey
}

"""
input type for incrementing numeric columns in table "booking_events.version"
"""
input booking_events_version_inc_input {
  current: numeric
}

"""
input type for inserting data into table "booking_events.version"
"""
input booking_events_version_insert_input {
  current: numeric
  id: uuid
}

"""aggregate max on columns"""
type booking_events_version_max_fields {
  current: numeric
  id: uuid
}

"""aggregate min on columns"""
type booking_events_version_min_fields {
  current: numeric
  id: uuid
}

"""
response of any mutation on the table "booking_events.version"
"""
type booking_events_version_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [booking_events_version!]!
}

"""
on_conflict condition type for table "booking_events.version"
"""
input booking_events_version_on_conflict {
  constraint: booking_events_version_constraint!
  update_columns: [booking_events_version_update_column!]! = []
  where: booking_events_version_bool_exp
}

"""Ordering options when selecting data from "booking_events.version"."""
input booking_events_version_order_by {
  current: order_by
  id: order_by
}

"""primary key columns input for table: booking_events.version"""
input booking_events_version_pk_columns_input {
  id: uuid!
}

"""
select columns of table "booking_events.version"
"""
enum booking_events_version_select_column {
  """column name"""
  current

  """column name"""
  id
}

"""
input type for updating data in table "booking_events.version"
"""
input booking_events_version_set_input {
  current: numeric
  id: uuid
}

"""aggregate stddev on columns"""
type booking_events_version_stddev_fields {
  current: Float
}

"""aggregate stddev_pop on columns"""
type booking_events_version_stddev_pop_fields {
  current: Float
}

"""aggregate stddev_samp on columns"""
type booking_events_version_stddev_samp_fields {
  current: Float
}

"""
Streaming cursor of the table "booking_events_version"
"""
input booking_events_version_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: booking_events_version_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input booking_events_version_stream_cursor_value_input {
  current: numeric
  id: uuid
}

"""aggregate sum on columns"""
type booking_events_version_sum_fields {
  current: numeric
}

"""
update columns of table "booking_events.version"
"""
enum booking_events_version_update_column {
  """column name"""
  current

  """column name"""
  id
}

input booking_events_version_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: booking_events_version_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: booking_events_version_set_input

  """filter the rows which have to be updated"""
  where: booking_events_version_bool_exp!
}

"""aggregate var_pop on columns"""
type booking_events_version_var_pop_fields {
  current: Float
}

"""aggregate var_samp on columns"""
type booking_events_version_var_samp_fields {
  current: Float
}

"""aggregate variance on columns"""
type booking_events_version_variance_fields {
  current: Float
}

"""
columns and relationships of "booking_history_entry"
"""
type booking_history_entry {
  """An object relationship"""
  booking: booking!
  booking_id: uuid!
  id: uuid!
  timestamp: timestamptz!
  type: String!

  """An object relationship"""
  user: users
  user_id: uuid
  value(
    """JSON select path"""
    path: String
  ): json!
  version: numeric!
}

"""
aggregated selection of "booking_history_entry"
"""
type booking_history_entry_aggregate {
  aggregate: booking_history_entry_aggregate_fields
  nodes: [booking_history_entry!]!
}

input booking_history_entry_aggregate_bool_exp {
  count: booking_history_entry_aggregate_bool_exp_count
}

input booking_history_entry_aggregate_bool_exp_count {
  arguments: [booking_history_entry_select_column!]
  distinct: Boolean
  filter: booking_history_entry_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "booking_history_entry"
"""
type booking_history_entry_aggregate_fields {
  avg: booking_history_entry_avg_fields
  count(columns: [booking_history_entry_select_column!], distinct: Boolean): Int!
  max: booking_history_entry_max_fields
  min: booking_history_entry_min_fields
  stddev: booking_history_entry_stddev_fields
  stddev_pop: booking_history_entry_stddev_pop_fields
  stddev_samp: booking_history_entry_stddev_samp_fields
  sum: booking_history_entry_sum_fields
  var_pop: booking_history_entry_var_pop_fields
  var_samp: booking_history_entry_var_samp_fields
  variance: booking_history_entry_variance_fields
}

"""
order by aggregate values of table "booking_history_entry"
"""
input booking_history_entry_aggregate_order_by {
  avg: booking_history_entry_avg_order_by
  count: order_by
  max: booking_history_entry_max_order_by
  min: booking_history_entry_min_order_by
  stddev: booking_history_entry_stddev_order_by
  stddev_pop: booking_history_entry_stddev_pop_order_by
  stddev_samp: booking_history_entry_stddev_samp_order_by
  sum: booking_history_entry_sum_order_by
  var_pop: booking_history_entry_var_pop_order_by
  var_samp: booking_history_entry_var_samp_order_by
  variance: booking_history_entry_variance_order_by
}

"""
input type for inserting array relation for remote table "booking_history_entry"
"""
input booking_history_entry_arr_rel_insert_input {
  data: [booking_history_entry_insert_input!]!

  """upsert condition"""
  on_conflict: booking_history_entry_on_conflict
}

"""aggregate avg on columns"""
type booking_history_entry_avg_fields {
  version: Float
}

"""
order by avg() on columns of table "booking_history_entry"
"""
input booking_history_entry_avg_order_by {
  version: order_by
}

"""
Boolean expression to filter rows from the table "booking_history_entry". All fields are combined with a logical 'AND'.
"""
input booking_history_entry_bool_exp {
  _and: [booking_history_entry_bool_exp!]
  _not: booking_history_entry_bool_exp
  _or: [booking_history_entry_bool_exp!]
  booking: booking_bool_exp
  booking_id: uuid_comparison_exp
  id: uuid_comparison_exp
  timestamp: timestamptz_comparison_exp
  type: String_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
  value: json_comparison_exp
  version: numeric_comparison_exp
}

"""
unique or primary key constraints on table "booking_history_entry"
"""
enum booking_history_entry_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  booking_history_entry_pkey
}

"""
input type for incrementing numeric columns in table "booking_history_entry"
"""
input booking_history_entry_inc_input {
  version: numeric
}

"""
input type for inserting data into table "booking_history_entry"
"""
input booking_history_entry_insert_input {
  booking: booking_obj_rel_insert_input
  booking_id: uuid
  id: uuid
  timestamp: timestamptz
  type: String
  user: users_obj_rel_insert_input
  user_id: uuid
  value: json
  version: numeric
}

"""aggregate max on columns"""
type booking_history_entry_max_fields {
  booking_id: uuid
  id: uuid
  timestamp: timestamptz
  type: String
  user_id: uuid
  version: numeric
}

"""
order by max() on columns of table "booking_history_entry"
"""
input booking_history_entry_max_order_by {
  booking_id: order_by
  id: order_by
  timestamp: order_by
  type: order_by
  user_id: order_by
  version: order_by
}

"""aggregate min on columns"""
type booking_history_entry_min_fields {
  booking_id: uuid
  id: uuid
  timestamp: timestamptz
  type: String
  user_id: uuid
  version: numeric
}

"""
order by min() on columns of table "booking_history_entry"
"""
input booking_history_entry_min_order_by {
  booking_id: order_by
  id: order_by
  timestamp: order_by
  type: order_by
  user_id: order_by
  version: order_by
}

"""
response of any mutation on the table "booking_history_entry"
"""
type booking_history_entry_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [booking_history_entry!]!
}

"""
on_conflict condition type for table "booking_history_entry"
"""
input booking_history_entry_on_conflict {
  constraint: booking_history_entry_constraint!
  update_columns: [booking_history_entry_update_column!]! = []
  where: booking_history_entry_bool_exp
}

"""Ordering options when selecting data from "booking_history_entry"."""
input booking_history_entry_order_by {
  booking: booking_order_by
  booking_id: order_by
  id: order_by
  timestamp: order_by
  type: order_by
  user: users_order_by
  user_id: order_by
  value: order_by
  version: order_by
}

"""primary key columns input for table: booking_history_entry"""
input booking_history_entry_pk_columns_input {
  id: uuid!
}

"""
select columns of table "booking_history_entry"
"""
enum booking_history_entry_select_column {
  """column name"""
  booking_id

  """column name"""
  id

  """column name"""
  timestamp

  """column name"""
  type

  """column name"""
  user_id

  """column name"""
  value

  """column name"""
  version
}

"""
input type for updating data in table "booking_history_entry"
"""
input booking_history_entry_set_input {
  booking_id: uuid
  id: uuid
  timestamp: timestamptz
  type: String
  user_id: uuid
  value: json
  version: numeric
}

"""aggregate stddev on columns"""
type booking_history_entry_stddev_fields {
  version: Float
}

"""
order by stddev() on columns of table "booking_history_entry"
"""
input booking_history_entry_stddev_order_by {
  version: order_by
}

"""aggregate stddev_pop on columns"""
type booking_history_entry_stddev_pop_fields {
  version: Float
}

"""
order by stddev_pop() on columns of table "booking_history_entry"
"""
input booking_history_entry_stddev_pop_order_by {
  version: order_by
}

"""aggregate stddev_samp on columns"""
type booking_history_entry_stddev_samp_fields {
  version: Float
}

"""
order by stddev_samp() on columns of table "booking_history_entry"
"""
input booking_history_entry_stddev_samp_order_by {
  version: order_by
}

"""
Streaming cursor of the table "booking_history_entry"
"""
input booking_history_entry_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: booking_history_entry_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input booking_history_entry_stream_cursor_value_input {
  booking_id: uuid
  id: uuid
  timestamp: timestamptz
  type: String
  user_id: uuid
  value: json
  version: numeric
}

"""aggregate sum on columns"""
type booking_history_entry_sum_fields {
  version: numeric
}

"""
order by sum() on columns of table "booking_history_entry"
"""
input booking_history_entry_sum_order_by {
  version: order_by
}

"""
update columns of table "booking_history_entry"
"""
enum booking_history_entry_update_column {
  """column name"""
  booking_id

  """column name"""
  id

  """column name"""
  timestamp

  """column name"""
  type

  """column name"""
  user_id

  """column name"""
  value

  """column name"""
  version
}

input booking_history_entry_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: booking_history_entry_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: booking_history_entry_set_input

  """filter the rows which have to be updated"""
  where: booking_history_entry_bool_exp!
}

"""aggregate var_pop on columns"""
type booking_history_entry_var_pop_fields {
  version: Float
}

"""
order by var_pop() on columns of table "booking_history_entry"
"""
input booking_history_entry_var_pop_order_by {
  version: order_by
}

"""aggregate var_samp on columns"""
type booking_history_entry_var_samp_fields {
  version: Float
}

"""
order by var_samp() on columns of table "booking_history_entry"
"""
input booking_history_entry_var_samp_order_by {
  version: order_by
}

"""aggregate variance on columns"""
type booking_history_entry_variance_fields {
  version: Float
}

"""
order by variance() on columns of table "booking_history_entry"
"""
input booking_history_entry_variance_order_by {
  version: order_by
}

"""
input type for incrementing numeric columns in table "booking"
"""
input booking_inc_input {
  amount: numeric
  version: numeric
}

"""
input type for inserting data into table "booking"
"""
input booking_insert_input {
  amount: numeric
  booking_answers_by_id: json
  contact: contact_obj_rel_insert_input
  contact_id: uuid
  created_on: timestamptz
  friendly_id: String
  history_entries: booking_history_entry_arr_rel_insert_input
  id: uuid
  last_modified_on: timestamptz
  locale: String
  organization: organization_obj_rel_insert_input
  organization_id: uuid
  products: booking_product_arr_rel_insert_input
  questions_by_scope_by_id: json
  state: booking_state_enum
  version: numeric
}

input booking_item_input {
  expected_price: numeric!
  explained_search_params: json!
  rate_id: uuid!
  search_params: search_params_input!
  units: [booking_item_unit_input!]!
}

input booking_item_unit_input {
  supplements: [booking_item_unit_supplements_input!]!
}

input booking_item_unit_supplements_input {
  expected_unit_price: numeric!
  id: uuid!
  quantity: numeric!
}

"""aggregate max on columns"""
type booking_max_fields {
  amount: numeric
  contact_id: uuid
  created_on: timestamptz
  friendly_id: String
  id: uuid
  last_modified_on: timestamptz
  locale: String
  organization_id: uuid
  version: numeric
}

"""
order by max() on columns of table "booking"
"""
input booking_max_order_by {
  amount: order_by
  contact_id: order_by
  created_on: order_by
  friendly_id: order_by
  id: order_by
  last_modified_on: order_by
  locale: order_by
  organization_id: order_by
  version: order_by
}

"""aggregate min on columns"""
type booking_min_fields {
  amount: numeric
  contact_id: uuid
  created_on: timestamptz
  friendly_id: String
  id: uuid
  last_modified_on: timestamptz
  locale: String
  organization_id: uuid
  version: numeric
}

"""
order by min() on columns of table "booking"
"""
input booking_min_order_by {
  amount: order_by
  contact_id: order_by
  created_on: order_by
  friendly_id: order_by
  id: order_by
  last_modified_on: order_by
  locale: order_by
  organization_id: order_by
  version: order_by
}

"""
response of any mutation on the table "booking"
"""
type booking_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [booking!]!
}

"""
input type for inserting object relation for remote table "booking"
"""
input booking_obj_rel_insert_input {
  data: booking_insert_input!

  """upsert condition"""
  on_conflict: booking_on_conflict
}

"""
on_conflict condition type for table "booking"
"""
input booking_on_conflict {
  constraint: booking_constraint!
  update_columns: [booking_update_column!]! = []
  where: booking_bool_exp
}

"""Ordering options when selecting data from "booking"."""
input booking_order_by {
  amount: order_by
  booking_answers_by_id: order_by
  contact: contact_order_by
  contact_id: order_by
  created_on: order_by
  friendly_id: order_by
  history_entries_aggregate: booking_history_entry_aggregate_order_by
  id: order_by
  last_modified_on: order_by
  locale: order_by
  organization: organization_order_by
  organization_id: order_by
  products_aggregate: booking_product_aggregate_order_by
  questions_by_scope_by_id: order_by
  state: order_by
  version: order_by
}

"""primary key columns input for table: booking"""
input booking_pk_columns_input {
  id: uuid!
}

"""
columns and relationships of "booking_product"
"""
type booking_product {
  """An object relationship"""
  booking: booking!
  booking_id: uuid!
  ends_on: timestamp!
  explained_search_params(
    """JSON select path"""
    path: String
  ): json!
  id: uuid!
  pax_answers_by_pax_type_by_index_by_id(
    """JSON select path"""
    path: String
  ): json!
  price: numeric!
  product_answers_by_id(
    """JSON select path"""
    path: String
  ): json!
  quantity: numeric!

  """An object relationship"""
  rate: rate!
  rate_id: uuid!
  search_params(
    """JSON select path"""
    path: String
  ): json!
  starts_on: timestamp!
}

"""
aggregated selection of "booking_product"
"""
type booking_product_aggregate {
  aggregate: booking_product_aggregate_fields
  nodes: [booking_product!]!
}

input booking_product_aggregate_bool_exp {
  count: booking_product_aggregate_bool_exp_count
}

input booking_product_aggregate_bool_exp_count {
  arguments: [booking_product_select_column!]
  distinct: Boolean
  filter: booking_product_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "booking_product"
"""
type booking_product_aggregate_fields {
  avg: booking_product_avg_fields
  count(columns: [booking_product_select_column!], distinct: Boolean): Int!
  max: booking_product_max_fields
  min: booking_product_min_fields
  stddev: booking_product_stddev_fields
  stddev_pop: booking_product_stddev_pop_fields
  stddev_samp: booking_product_stddev_samp_fields
  sum: booking_product_sum_fields
  var_pop: booking_product_var_pop_fields
  var_samp: booking_product_var_samp_fields
  variance: booking_product_variance_fields
}

"""
order by aggregate values of table "booking_product"
"""
input booking_product_aggregate_order_by {
  avg: booking_product_avg_order_by
  count: order_by
  max: booking_product_max_order_by
  min: booking_product_min_order_by
  stddev: booking_product_stddev_order_by
  stddev_pop: booking_product_stddev_pop_order_by
  stddev_samp: booking_product_stddev_samp_order_by
  sum: booking_product_sum_order_by
  var_pop: booking_product_var_pop_order_by
  var_samp: booking_product_var_samp_order_by
  variance: booking_product_variance_order_by
}

"""
input type for inserting array relation for remote table "booking_product"
"""
input booking_product_arr_rel_insert_input {
  data: [booking_product_insert_input!]!

  """upsert condition"""
  on_conflict: booking_product_on_conflict
}

"""aggregate avg on columns"""
type booking_product_avg_fields {
  price: Float
  quantity: Float
}

"""
order by avg() on columns of table "booking_product"
"""
input booking_product_avg_order_by {
  price: order_by
  quantity: order_by
}

"""
Boolean expression to filter rows from the table "booking_product". All fields are combined with a logical 'AND'.
"""
input booking_product_bool_exp {
  _and: [booking_product_bool_exp!]
  _not: booking_product_bool_exp
  _or: [booking_product_bool_exp!]
  booking: booking_bool_exp
  booking_id: uuid_comparison_exp
  ends_on: timestamp_comparison_exp
  explained_search_params: json_comparison_exp
  id: uuid_comparison_exp
  pax_answers_by_pax_type_by_index_by_id: json_comparison_exp
  price: numeric_comparison_exp
  product_answers_by_id: json_comparison_exp
  quantity: numeric_comparison_exp
  rate: rate_bool_exp
  rate_id: uuid_comparison_exp
  search_params: json_comparison_exp
  starts_on: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "booking_product"
"""
enum booking_product_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  booking_products_pkey
}

"""
input type for incrementing numeric columns in table "booking_product"
"""
input booking_product_inc_input {
  price: numeric
  quantity: numeric
}

"""
input type for inserting data into table "booking_product"
"""
input booking_product_insert_input {
  booking: booking_obj_rel_insert_input
  booking_id: uuid
  ends_on: timestamp
  explained_search_params: json
  id: uuid
  pax_answers_by_pax_type_by_index_by_id: json
  price: numeric
  product_answers_by_id: json
  quantity: numeric
  rate: rate_obj_rel_insert_input
  rate_id: uuid
  search_params: json
  starts_on: timestamp
}

"""aggregate max on columns"""
type booking_product_max_fields {
  booking_id: uuid
  ends_on: timestamp
  id: uuid
  price: numeric
  quantity: numeric
  rate_id: uuid
  starts_on: timestamp
}

"""
order by max() on columns of table "booking_product"
"""
input booking_product_max_order_by {
  booking_id: order_by
  ends_on: order_by
  id: order_by
  price: order_by
  quantity: order_by
  rate_id: order_by
  starts_on: order_by
}

"""aggregate min on columns"""
type booking_product_min_fields {
  booking_id: uuid
  ends_on: timestamp
  id: uuid
  price: numeric
  quantity: numeric
  rate_id: uuid
  starts_on: timestamp
}

"""
order by min() on columns of table "booking_product"
"""
input booking_product_min_order_by {
  booking_id: order_by
  ends_on: order_by
  id: order_by
  price: order_by
  quantity: order_by
  rate_id: order_by
  starts_on: order_by
}

"""
response of any mutation on the table "booking_product"
"""
type booking_product_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [booking_product!]!
}

"""
on_conflict condition type for table "booking_product"
"""
input booking_product_on_conflict {
  constraint: booking_product_constraint!
  update_columns: [booking_product_update_column!]! = []
  where: booking_product_bool_exp
}

"""Ordering options when selecting data from "booking_product"."""
input booking_product_order_by {
  booking: booking_order_by
  booking_id: order_by
  ends_on: order_by
  explained_search_params: order_by
  id: order_by
  pax_answers_by_pax_type_by_index_by_id: order_by
  price: order_by
  product_answers_by_id: order_by
  quantity: order_by
  rate: rate_order_by
  rate_id: order_by
  search_params: order_by
  starts_on: order_by
}

"""primary key columns input for table: booking_product"""
input booking_product_pk_columns_input {
  id: uuid!
}

"""
select columns of table "booking_product"
"""
enum booking_product_select_column {
  """column name"""
  booking_id

  """column name"""
  ends_on

  """column name"""
  explained_search_params

  """column name"""
  id

  """column name"""
  pax_answers_by_pax_type_by_index_by_id

  """column name"""
  price

  """column name"""
  product_answers_by_id

  """column name"""
  quantity

  """column name"""
  rate_id

  """column name"""
  search_params

  """column name"""
  starts_on
}

"""
input type for updating data in table "booking_product"
"""
input booking_product_set_input {
  booking_id: uuid
  ends_on: timestamp
  explained_search_params: json
  id: uuid
  pax_answers_by_pax_type_by_index_by_id: json
  price: numeric
  product_answers_by_id: json
  quantity: numeric
  rate_id: uuid
  search_params: json
  starts_on: timestamp
}

"""aggregate stddev on columns"""
type booking_product_stddev_fields {
  price: Float
  quantity: Float
}

"""
order by stddev() on columns of table "booking_product"
"""
input booking_product_stddev_order_by {
  price: order_by
  quantity: order_by
}

"""aggregate stddev_pop on columns"""
type booking_product_stddev_pop_fields {
  price: Float
  quantity: Float
}

"""
order by stddev_pop() on columns of table "booking_product"
"""
input booking_product_stddev_pop_order_by {
  price: order_by
  quantity: order_by
}

"""aggregate stddev_samp on columns"""
type booking_product_stddev_samp_fields {
  price: Float
  quantity: Float
}

"""
order by stddev_samp() on columns of table "booking_product"
"""
input booking_product_stddev_samp_order_by {
  price: order_by
  quantity: order_by
}

"""
Streaming cursor of the table "booking_product"
"""
input booking_product_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: booking_product_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input booking_product_stream_cursor_value_input {
  booking_id: uuid
  ends_on: timestamp
  explained_search_params: json
  id: uuid
  pax_answers_by_pax_type_by_index_by_id: json
  price: numeric
  product_answers_by_id: json
  quantity: numeric
  rate_id: uuid
  search_params: json
  starts_on: timestamp
}

"""aggregate sum on columns"""
type booking_product_sum_fields {
  price: numeric
  quantity: numeric
}

"""
order by sum() on columns of table "booking_product"
"""
input booking_product_sum_order_by {
  price: order_by
  quantity: order_by
}

"""
update columns of table "booking_product"
"""
enum booking_product_update_column {
  """column name"""
  booking_id

  """column name"""
  ends_on

  """column name"""
  explained_search_params

  """column name"""
  id

  """column name"""
  pax_answers_by_pax_type_by_index_by_id

  """column name"""
  price

  """column name"""
  product_answers_by_id

  """column name"""
  quantity

  """column name"""
  rate_id

  """column name"""
  search_params

  """column name"""
  starts_on
}

input booking_product_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: booking_product_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: booking_product_set_input

  """filter the rows which have to be updated"""
  where: booking_product_bool_exp!
}

"""aggregate var_pop on columns"""
type booking_product_var_pop_fields {
  price: Float
  quantity: Float
}

"""
order by var_pop() on columns of table "booking_product"
"""
input booking_product_var_pop_order_by {
  price: order_by
  quantity: order_by
}

"""aggregate var_samp on columns"""
type booking_product_var_samp_fields {
  price: Float
  quantity: Float
}

"""
order by var_samp() on columns of table "booking_product"
"""
input booking_product_var_samp_order_by {
  price: order_by
  quantity: order_by
}

"""aggregate variance on columns"""
type booking_product_variance_fields {
  price: Float
  quantity: Float
}

"""
order by variance() on columns of table "booking_product"
"""
input booking_product_variance_order_by {
  price: order_by
  quantity: order_by
}

input booking_question_answer {
  question_id: uuid!
  value: json
}

"""
columns and relationships of "booking_question_scope"
"""
type booking_question_scope {
  id: String!
}

"""
aggregated selection of "booking_question_scope"
"""
type booking_question_scope_aggregate {
  aggregate: booking_question_scope_aggregate_fields
  nodes: [booking_question_scope!]!
}

"""
aggregate fields of "booking_question_scope"
"""
type booking_question_scope_aggregate_fields {
  count(columns: [booking_question_scope_select_column!], distinct: Boolean): Int!
  max: booking_question_scope_max_fields
  min: booking_question_scope_min_fields
}

"""
Boolean expression to filter rows from the table "booking_question_scope". All fields are combined with a logical 'AND'.
"""
input booking_question_scope_bool_exp {
  _and: [booking_question_scope_bool_exp!]
  _not: booking_question_scope_bool_exp
  _or: [booking_question_scope_bool_exp!]
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "booking_question_scope"
"""
enum booking_question_scope_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  booking_question_scope_pkey
}

enum booking_question_scope_enum {
  PER_BOOKING
  PER_PAX
  PER_PRODUCT
}

"""
Boolean expression to compare columns of type "booking_question_scope_enum". All fields are combined with logical 'AND'.
"""
input booking_question_scope_enum_comparison_exp {
  _eq: booking_question_scope_enum
  _in: [booking_question_scope_enum!]
  _is_null: Boolean
  _neq: booking_question_scope_enum
  _nin: [booking_question_scope_enum!]
}

"""
input type for inserting data into table "booking_question_scope"
"""
input booking_question_scope_insert_input {
  id: String
}

"""aggregate max on columns"""
type booking_question_scope_max_fields {
  id: String
}

"""aggregate min on columns"""
type booking_question_scope_min_fields {
  id: String
}

"""
response of any mutation on the table "booking_question_scope"
"""
type booking_question_scope_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [booking_question_scope!]!
}

"""
on_conflict condition type for table "booking_question_scope"
"""
input booking_question_scope_on_conflict {
  constraint: booking_question_scope_constraint!
  update_columns: [booking_question_scope_update_column!]! = []
  where: booking_question_scope_bool_exp
}

"""Ordering options when selecting data from "booking_question_scope"."""
input booking_question_scope_order_by {
  id: order_by
}

"""primary key columns input for table: booking_question_scope"""
input booking_question_scope_pk_columns_input {
  id: String!
}

"""
select columns of table "booking_question_scope"
"""
enum booking_question_scope_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "booking_question_scope"
"""
input booking_question_scope_set_input {
  id: String
}

"""
Streaming cursor of the table "booking_question_scope"
"""
input booking_question_scope_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: booking_question_scope_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input booking_question_scope_stream_cursor_value_input {
  id: String
}

"""
update columns of table "booking_question_scope"
"""
enum booking_question_scope_update_column {
  """column name"""
  id
}

input booking_question_scope_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: booking_question_scope_set_input

  """filter the rows which have to be updated"""
  where: booking_question_scope_bool_exp!
}

"""
columns and relationships of "booking_question_type"
"""
type booking_question_type {
  id: String!
}

"""
aggregated selection of "booking_question_type"
"""
type booking_question_type_aggregate {
  aggregate: booking_question_type_aggregate_fields
  nodes: [booking_question_type!]!
}

"""
aggregate fields of "booking_question_type"
"""
type booking_question_type_aggregate_fields {
  count(columns: [booking_question_type_select_column!], distinct: Boolean): Int!
  max: booking_question_type_max_fields
  min: booking_question_type_min_fields
}

"""
Boolean expression to filter rows from the table "booking_question_type". All fields are combined with a logical 'AND'.
"""
input booking_question_type_bool_exp {
  _and: [booking_question_type_bool_exp!]
  _not: booking_question_type_bool_exp
  _or: [booking_question_type_bool_exp!]
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "booking_question_type"
"""
enum booking_question_type_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  booking_question_type_pkey
}

enum booking_question_type_enum {
  FREE_TEXT
  NUMERIC
  SELECT
}

"""
Boolean expression to compare columns of type "booking_question_type_enum". All fields are combined with logical 'AND'.
"""
input booking_question_type_enum_comparison_exp {
  _eq: booking_question_type_enum
  _in: [booking_question_type_enum!]
  _is_null: Boolean
  _neq: booking_question_type_enum
  _nin: [booking_question_type_enum!]
}

"""
input type for inserting data into table "booking_question_type"
"""
input booking_question_type_insert_input {
  id: String
}

"""aggregate max on columns"""
type booking_question_type_max_fields {
  id: String
}

"""aggregate min on columns"""
type booking_question_type_min_fields {
  id: String
}

"""
response of any mutation on the table "booking_question_type"
"""
type booking_question_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [booking_question_type!]!
}

"""
on_conflict condition type for table "booking_question_type"
"""
input booking_question_type_on_conflict {
  constraint: booking_question_type_constraint!
  update_columns: [booking_question_type_update_column!]! = []
  where: booking_question_type_bool_exp
}

"""Ordering options when selecting data from "booking_question_type"."""
input booking_question_type_order_by {
  id: order_by
}

"""primary key columns input for table: booking_question_type"""
input booking_question_type_pk_columns_input {
  id: String!
}

"""
select columns of table "booking_question_type"
"""
enum booking_question_type_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "booking_question_type"
"""
input booking_question_type_set_input {
  id: String
}

"""
Streaming cursor of the table "booking_question_type"
"""
input booking_question_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: booking_question_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input booking_question_type_stream_cursor_value_input {
  id: String
}

"""
update columns of table "booking_question_type"
"""
enum booking_question_type_update_column {
  """column name"""
  id
}

input booking_question_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: booking_question_type_set_input

  """filter the rows which have to be updated"""
  where: booking_question_type_bool_exp!
}

input booking_questions_answers_by_scope {
  booking: [booking_question_answer!]!
  products: [product_and_pax_questions_answers!]!
}

input booking_reject_input {
  expected_version: numeric!
  id: uuid!
}

"""
select columns of table "booking"
"""
enum booking_select_column {
  """column name"""
  amount

  """column name"""
  booking_answers_by_id

  """column name"""
  contact_id

  """column name"""
  created_on

  """column name"""
  friendly_id

  """column name"""
  id

  """column name"""
  last_modified_on

  """column name"""
  locale

  """column name"""
  organization_id

  """column name"""
  questions_by_scope_by_id

  """column name"""
  state

  """column name"""
  version
}

"""
input type for updating data in table "booking"
"""
input booking_set_input {
  amount: numeric
  booking_answers_by_id: json
  contact_id: uuid
  created_on: timestamptz
  friendly_id: String
  id: uuid
  last_modified_on: timestamptz
  locale: String
  organization_id: uuid
  questions_by_scope_by_id: json
  state: booking_state_enum
  version: numeric
}

"""
columns and relationships of "booking_state"
"""
type booking_state {
  """An array relationship"""
  bookings(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): [booking!]!

  """An aggregate relationship"""
  bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): booking_aggregate!
  description: String!
  id: String!
}

"""
aggregated selection of "booking_state"
"""
type booking_state_aggregate {
  aggregate: booking_state_aggregate_fields
  nodes: [booking_state!]!
}

"""
aggregate fields of "booking_state"
"""
type booking_state_aggregate_fields {
  count(columns: [booking_state_select_column!], distinct: Boolean): Int!
  max: booking_state_max_fields
  min: booking_state_min_fields
}

"""
Boolean expression to filter rows from the table "booking_state". All fields are combined with a logical 'AND'.
"""
input booking_state_bool_exp {
  _and: [booking_state_bool_exp!]
  _not: booking_state_bool_exp
  _or: [booking_state_bool_exp!]
  bookings: booking_bool_exp
  bookings_aggregate: booking_aggregate_bool_exp
  description: String_comparison_exp
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "booking_state"
"""
enum booking_state_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  booking_state_pkey
}

enum booking_state_enum {
  """Accepted"""
  ACCEPTED

  """Cancelled"""
  CANCELLED

  """Created"""
  CREATED

  """Rejected"""
  REJECTED
}

"""
Boolean expression to compare columns of type "booking_state_enum". All fields are combined with logical 'AND'.
"""
input booking_state_enum_comparison_exp {
  _eq: booking_state_enum
  _in: [booking_state_enum!]
  _is_null: Boolean
  _neq: booking_state_enum
  _nin: [booking_state_enum!]
}

"""
input type for inserting data into table "booking_state"
"""
input booking_state_insert_input {
  bookings: booking_arr_rel_insert_input
  description: String
  id: String
}

"""aggregate max on columns"""
type booking_state_max_fields {
  description: String
  id: String
}

"""aggregate min on columns"""
type booking_state_min_fields {
  description: String
  id: String
}

"""
response of any mutation on the table "booking_state"
"""
type booking_state_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [booking_state!]!
}

"""
on_conflict condition type for table "booking_state"
"""
input booking_state_on_conflict {
  constraint: booking_state_constraint!
  update_columns: [booking_state_update_column!]! = []
  where: booking_state_bool_exp
}

"""Ordering options when selecting data from "booking_state"."""
input booking_state_order_by {
  bookings_aggregate: booking_aggregate_order_by
  description: order_by
  id: order_by
}

"""primary key columns input for table: booking_state"""
input booking_state_pk_columns_input {
  id: String!
}

"""
select columns of table "booking_state"
"""
enum booking_state_select_column {
  """column name"""
  description

  """column name"""
  id
}

"""
input type for updating data in table "booking_state"
"""
input booking_state_set_input {
  description: String
  id: String
}

"""
Streaming cursor of the table "booking_state"
"""
input booking_state_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: booking_state_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input booking_state_stream_cursor_value_input {
  description: String
  id: String
}

"""
update columns of table "booking_state"
"""
enum booking_state_update_column {
  """column name"""
  description

  """column name"""
  id
}

input booking_state_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: booking_state_set_input

  """filter the rows which have to be updated"""
  where: booking_state_bool_exp!
}

"""aggregate stddev on columns"""
type booking_stddev_fields {
  amount: Float
  version: Float
}

"""
order by stddev() on columns of table "booking"
"""
input booking_stddev_order_by {
  amount: order_by
  version: order_by
}

"""aggregate stddev_pop on columns"""
type booking_stddev_pop_fields {
  amount: Float
  version: Float
}

"""
order by stddev_pop() on columns of table "booking"
"""
input booking_stddev_pop_order_by {
  amount: order_by
  version: order_by
}

"""aggregate stddev_samp on columns"""
type booking_stddev_samp_fields {
  amount: Float
  version: Float
}

"""
order by stddev_samp() on columns of table "booking"
"""
input booking_stddev_samp_order_by {
  amount: order_by
  version: order_by
}

"""
Streaming cursor of the table "booking"
"""
input booking_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: booking_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input booking_stream_cursor_value_input {
  amount: numeric
  booking_answers_by_id: json
  contact_id: uuid
  created_on: timestamptz
  friendly_id: String
  id: uuid
  last_modified_on: timestamptz
  locale: String
  organization_id: uuid
  questions_by_scope_by_id: json
  state: booking_state_enum
  version: numeric
}

"""aggregate sum on columns"""
type booking_sum_fields {
  amount: numeric
  version: numeric
}

"""
order by sum() on columns of table "booking"
"""
input booking_sum_order_by {
  amount: order_by
  version: order_by
}

"""
update columns of table "booking"
"""
enum booking_update_column {
  """column name"""
  amount

  """column name"""
  booking_answers_by_id

  """column name"""
  contact_id

  """column name"""
  created_on

  """column name"""
  friendly_id

  """column name"""
  id

  """column name"""
  last_modified_on

  """column name"""
  locale

  """column name"""
  organization_id

  """column name"""
  questions_by_scope_by_id

  """column name"""
  state

  """column name"""
  version
}

input booking_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: booking_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: booking_set_input

  """filter the rows which have to be updated"""
  where: booking_bool_exp!
}

"""aggregate var_pop on columns"""
type booking_var_pop_fields {
  amount: Float
  version: Float
}

"""
order by var_pop() on columns of table "booking"
"""
input booking_var_pop_order_by {
  amount: order_by
  version: order_by
}

"""aggregate var_samp on columns"""
type booking_var_samp_fields {
  amount: Float
  version: Float
}

"""
order by var_samp() on columns of table "booking"
"""
input booking_var_samp_order_by {
  amount: order_by
  version: order_by
}

"""aggregate variance on columns"""
type booking_variance_fields {
  amount: Float
  version: Float
}

"""
order by variance() on columns of table "booking"
"""
input booking_variance_order_by {
  amount: order_by
  version: order_by
}

"""
columns and relationships of "storage.buckets"
"""
type buckets {
  cacheControl: String
  createdAt: timestamptz!
  downloadExpiration: Int!

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """An aggregate relationship"""
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!
  id: String!
  maxUploadFileSize: Int!
  minUploadFileSize: Int!
  presignedUrlsEnabled: Boolean!
  updatedAt: timestamptz!
}

"""
aggregated selection of "storage.buckets"
"""
type buckets_aggregate {
  aggregate: buckets_aggregate_fields
  nodes: [buckets!]!
}

"""
aggregate fields of "storage.buckets"
"""
type buckets_aggregate_fields {
  avg: buckets_avg_fields
  count(columns: [buckets_select_column!], distinct: Boolean): Int!
  max: buckets_max_fields
  min: buckets_min_fields
  stddev: buckets_stddev_fields
  stddev_pop: buckets_stddev_pop_fields
  stddev_samp: buckets_stddev_samp_fields
  sum: buckets_sum_fields
  var_pop: buckets_var_pop_fields
  var_samp: buckets_var_samp_fields
  variance: buckets_variance_fields
}

"""aggregate avg on columns"""
type buckets_avg_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""
Boolean expression to filter rows from the table "storage.buckets". All fields are combined with a logical 'AND'.
"""
input buckets_bool_exp {
  _and: [buckets_bool_exp!]
  _not: buckets_bool_exp
  _or: [buckets_bool_exp!]
  cacheControl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  downloadExpiration: Int_comparison_exp
  files: files_bool_exp
  files_aggregate: files_aggregate_bool_exp
  id: String_comparison_exp
  maxUploadFileSize: Int_comparison_exp
  minUploadFileSize: Int_comparison_exp
  presignedUrlsEnabled: Boolean_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "storage.buckets"
"""
enum buckets_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  buckets_pkey
}

"""
input type for incrementing numeric columns in table "storage.buckets"
"""
input buckets_inc_input {
  downloadExpiration: Int
  maxUploadFileSize: Int
  minUploadFileSize: Int
}

"""
input type for inserting data into table "storage.buckets"
"""
input buckets_insert_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  files: files_arr_rel_insert_input
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type buckets_max_fields {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type buckets_min_fields {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  updatedAt: timestamptz
}

"""
response of any mutation on the table "storage.buckets"
"""
type buckets_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [buckets!]!
}

"""
input type for inserting object relation for remote table "storage.buckets"
"""
input buckets_obj_rel_insert_input {
  data: buckets_insert_input!

  """upsert condition"""
  on_conflict: buckets_on_conflict
}

"""
on_conflict condition type for table "storage.buckets"
"""
input buckets_on_conflict {
  constraint: buckets_constraint!
  update_columns: [buckets_update_column!]! = []
  where: buckets_bool_exp
}

"""Ordering options when selecting data from "storage.buckets"."""
input buckets_order_by {
  cacheControl: order_by
  createdAt: order_by
  downloadExpiration: order_by
  files_aggregate: files_aggregate_order_by
  id: order_by
  maxUploadFileSize: order_by
  minUploadFileSize: order_by
  presignedUrlsEnabled: order_by
  updatedAt: order_by
}

"""primary key columns input for table: storage.buckets"""
input buckets_pk_columns_input {
  id: String!
}

"""
select columns of table "storage.buckets"
"""
enum buckets_select_column {
  """column name"""
  cacheControl

  """column name"""
  createdAt

  """column name"""
  downloadExpiration

  """column name"""
  id

  """column name"""
  maxUploadFileSize

  """column name"""
  minUploadFileSize

  """column name"""
  presignedUrlsEnabled

  """column name"""
  updatedAt
}

"""
input type for updating data in table "storage.buckets"
"""
input buckets_set_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type buckets_stddev_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate stddev_pop on columns"""
type buckets_stddev_pop_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate stddev_samp on columns"""
type buckets_stddev_samp_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""
Streaming cursor of the table "buckets"
"""
input buckets_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: buckets_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input buckets_stream_cursor_value_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type buckets_sum_fields {
  downloadExpiration: Int
  maxUploadFileSize: Int
  minUploadFileSize: Int
}

"""
update columns of table "storage.buckets"
"""
enum buckets_update_column {
  """column name"""
  cacheControl

  """column name"""
  createdAt

  """column name"""
  downloadExpiration

  """column name"""
  id

  """column name"""
  maxUploadFileSize

  """column name"""
  minUploadFileSize

  """column name"""
  presignedUrlsEnabled

  """column name"""
  updatedAt
}

input buckets_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: buckets_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: buckets_set_input

  """filter the rows which have to be updated"""
  where: buckets_bool_exp!
}

"""aggregate var_pop on columns"""
type buckets_var_pop_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate var_samp on columns"""
type buckets_var_samp_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate variance on columns"""
type buckets_variance_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

input business_model_input {
  time_management: String!
  unit_management: String!
}

scalar bytea

"""
Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'.
"""
input bytea_comparison_exp {
  _eq: bytea
  _gt: bytea
  _gte: bytea
  _in: [bytea!]
  _is_null: Boolean
  _lt: bytea
  _lte: bytea
  _neq: bytea
  _nin: [bytea!]
}

"""
columns and relationships of "category"
"""
type category {
  id: String!
  parent_id: String
  path: ltree
}

"""
aggregated selection of "category"
"""
type category_aggregate {
  aggregate: category_aggregate_fields
  nodes: [category!]!
}

"""
aggregate fields of "category"
"""
type category_aggregate_fields {
  count(columns: [category_select_column!], distinct: Boolean): Int!
  max: category_max_fields
  min: category_min_fields
}

"""
Boolean expression to filter rows from the table "category". All fields are combined with a logical 'AND'.
"""
input category_bool_exp {
  _and: [category_bool_exp!]
  _not: category_bool_exp
  _or: [category_bool_exp!]
  id: String_comparison_exp
  parent_id: String_comparison_exp
  path: ltree_comparison_exp
}

"""
unique or primary key constraints on table "category"
"""
enum category_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  category_pkey
}

"""
input type for inserting data into table "category"
"""
input category_insert_input {
  id: String
  parent_id: String
  path: ltree
}

"""aggregate max on columns"""
type category_max_fields {
  id: String
  parent_id: String
  path: ltree
}

"""aggregate min on columns"""
type category_min_fields {
  id: String
  parent_id: String
  path: ltree
}

"""
response of any mutation on the table "category"
"""
type category_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [category!]!
}

"""
input type for inserting object relation for remote table "category"
"""
input category_obj_rel_insert_input {
  data: category_insert_input!

  """upsert condition"""
  on_conflict: category_on_conflict
}

"""
on_conflict condition type for table "category"
"""
input category_on_conflict {
  constraint: category_constraint!
  update_columns: [category_update_column!]! = []
  where: category_bool_exp
}

"""Ordering options when selecting data from "category"."""
input category_order_by {
  id: order_by
  parent_id: order_by
  path: order_by
}

"""primary key columns input for table: category"""
input category_pk_columns_input {
  id: String!
}

"""
select columns of table "category"
"""
enum category_select_column {
  """column name"""
  id

  """column name"""
  parent_id

  """column name"""
  path
}

"""
input type for updating data in table "category"
"""
input category_set_input {
  id: String
  parent_id: String
  path: ltree
}

"""
Streaming cursor of the table "category"
"""
input category_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: category_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input category_stream_cursor_value_input {
  id: String
  parent_id: String
  path: ltree
}

"""
update columns of table "category"
"""
enum category_update_column {
  """column name"""
  id

  """column name"""
  parent_id

  """column name"""
  path
}

input category_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: category_set_input

  """filter the rows which have to be updated"""
  where: category_bool_exp!
}

scalar citext

"""
Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
"""
input citext_comparison_exp {
  _eq: citext
  _gt: citext
  _gte: citext

  """does the column match the given case-insensitive pattern"""
  _ilike: citext
  _in: [citext!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: citext
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: citext
  _lt: citext
  _lte: citext
  _neq: citext

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: citext
  _nin: [citext!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: citext

  """does the column NOT match the given pattern"""
  _nlike: citext

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: citext

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: citext

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: citext

  """does the column match the given SQL regular expression"""
  _similar: citext
}

input cleanup_input {
  organization_id: uuid
}

"""
columns and relationships of "contact"
"""
type contact {
  """An array relationship"""
  bookings(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): [booking!]!

  """An aggregate relationship"""
  bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): booking_aggregate!
  email: String!
  id: uuid!
  name: String!

  """An object relationship"""
  organization: organization!
  organization_id: uuid!
}

"""
aggregated selection of "contact"
"""
type contact_aggregate {
  aggregate: contact_aggregate_fields
  nodes: [contact!]!
}

input contact_aggregate_bool_exp {
  count: contact_aggregate_bool_exp_count
}

input contact_aggregate_bool_exp_count {
  arguments: [contact_select_column!]
  distinct: Boolean
  filter: contact_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "contact"
"""
type contact_aggregate_fields {
  count(columns: [contact_select_column!], distinct: Boolean): Int!
  max: contact_max_fields
  min: contact_min_fields
}

"""
order by aggregate values of table "contact"
"""
input contact_aggregate_order_by {
  count: order_by
  max: contact_max_order_by
  min: contact_min_order_by
}

"""
input type for inserting array relation for remote table "contact"
"""
input contact_arr_rel_insert_input {
  data: [contact_insert_input!]!

  """upsert condition"""
  on_conflict: contact_on_conflict
}

"""
Boolean expression to filter rows from the table "contact". All fields are combined with a logical 'AND'.
"""
input contact_bool_exp {
  _and: [contact_bool_exp!]
  _not: contact_bool_exp
  _or: [contact_bool_exp!]
  bookings: booking_bool_exp
  bookings_aggregate: booking_aggregate_bool_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  organization: organization_bool_exp
  organization_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "contact"
"""
enum contact_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  contact_pkey
}

input contact_input {
  email: String!
  message: String!
  name: String!
  organization_id: uuid!
}

"""
input type for inserting data into table "contact"
"""
input contact_insert_input {
  bookings: booking_arr_rel_insert_input
  email: String
  id: uuid
  name: String
  organization: organization_obj_rel_insert_input
  organization_id: uuid
}

"""aggregate max on columns"""
type contact_max_fields {
  email: String
  id: uuid
  name: String
  organization_id: uuid
}

"""
order by max() on columns of table "contact"
"""
input contact_max_order_by {
  email: order_by
  id: order_by
  name: order_by
  organization_id: order_by
}

"""aggregate min on columns"""
type contact_min_fields {
  email: String
  id: uuid
  name: String
  organization_id: uuid
}

"""
order by min() on columns of table "contact"
"""
input contact_min_order_by {
  email: order_by
  id: order_by
  name: order_by
  organization_id: order_by
}

"""
response of any mutation on the table "contact"
"""
type contact_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [contact!]!
}

"""
input type for inserting object relation for remote table "contact"
"""
input contact_obj_rel_insert_input {
  data: contact_insert_input!

  """upsert condition"""
  on_conflict: contact_on_conflict
}

"""
on_conflict condition type for table "contact"
"""
input contact_on_conflict {
  constraint: contact_constraint!
  update_columns: [contact_update_column!]! = []
  where: contact_bool_exp
}

"""Ordering options when selecting data from "contact"."""
input contact_order_by {
  bookings_aggregate: booking_aggregate_order_by
  email: order_by
  id: order_by
  name: order_by
  organization: organization_order_by
  organization_id: order_by
}

"""primary key columns input for table: contact"""
input contact_pk_columns_input {
  id: uuid!
}

"""
select columns of table "contact"
"""
enum contact_select_column {
  """column name"""
  email

  """column name"""
  id

  """column name"""
  name

  """column name"""
  organization_id
}

"""
input type for updating data in table "contact"
"""
input contact_set_input {
  email: String
  id: uuid
  name: String
  organization_id: uuid
}

"""
Streaming cursor of the table "contact"
"""
input contact_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: contact_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input contact_stream_cursor_value_input {
  email: String
  id: uuid
  name: String
  organization_id: uuid
}

"""
update columns of table "contact"
"""
enum contact_update_column {
  """column name"""
  email

  """column name"""
  id

  """column name"""
  name

  """column name"""
  organization_id
}

input contact_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: contact_set_input

  """filter the rows which have to be updated"""
  where: contact_bool_exp!
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

input date_range {
  from: timestamp!
  to: timestamp!
}

input date_range_with_value {
  from: timestamptz!
  to: timestamptz!
  value: numeric!
}

"""
columns and relationships of "feature"
"""
type feature {
  """An array relationship"""
  categories(
    """distinct select on columns"""
    distinct_on: [feature_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_category_order_by!]

    """filter the rows returned"""
    where: feature_category_bool_exp
  ): [feature_category!]!

  """An aggregate relationship"""
  categories_aggregate(
    """distinct select on columns"""
    distinct_on: [feature_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_category_order_by!]

    """filter the rows returned"""
    where: feature_category_bool_exp
  ): feature_category_aggregate!
  config(
    """JSON select path"""
    path: String
  ): jsonb!

  """An object relationship"""
  headline: translated_text!
  headline_id: uuid!
  id: uuid!
  internal_name: String!

  """An object relationship"""
  name: translated_text
  name_id: uuid!
  organization_id: uuid!
  symbol: feature_symbol_enum!
  type: feature_type_enum!
}

"""
aggregated selection of "feature"
"""
type feature_aggregate {
  aggregate: feature_aggregate_fields
  nodes: [feature!]!
}

input feature_aggregate_bool_exp {
  count: feature_aggregate_bool_exp_count
}

input feature_aggregate_bool_exp_count {
  arguments: [feature_select_column!]
  distinct: Boolean
  filter: feature_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "feature"
"""
type feature_aggregate_fields {
  count(columns: [feature_select_column!], distinct: Boolean): Int!
  max: feature_max_fields
  min: feature_min_fields
}

"""
order by aggregate values of table "feature"
"""
input feature_aggregate_order_by {
  count: order_by
  max: feature_max_order_by
  min: feature_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input feature_append_input {
  config: jsonb
}

"""
input type for inserting array relation for remote table "feature"
"""
input feature_arr_rel_insert_input {
  data: [feature_insert_input!]!

  """upsert condition"""
  on_conflict: feature_on_conflict
}

"""
Boolean expression to filter rows from the table "feature". All fields are combined with a logical 'AND'.
"""
input feature_bool_exp {
  _and: [feature_bool_exp!]
  _not: feature_bool_exp
  _or: [feature_bool_exp!]
  categories: feature_category_bool_exp
  categories_aggregate: feature_category_aggregate_bool_exp
  config: jsonb_comparison_exp
  headline: translated_text_bool_exp
  headline_id: uuid_comparison_exp
  id: uuid_comparison_exp
  internal_name: String_comparison_exp
  name: translated_text_bool_exp
  name_id: uuid_comparison_exp
  organization_id: uuid_comparison_exp
  symbol: feature_symbol_enum_comparison_exp
  type: feature_type_enum_comparison_exp
}

"""
columns and relationships of "feature_category"
"""
type feature_category {
  """An object relationship"""
  category: category!
  category_id: String!

  """An object relationship"""
  feature: feature!
  feature_id: uuid!
}

"""
aggregated selection of "feature_category"
"""
type feature_category_aggregate {
  aggregate: feature_category_aggregate_fields
  nodes: [feature_category!]!
}

input feature_category_aggregate_bool_exp {
  count: feature_category_aggregate_bool_exp_count
}

input feature_category_aggregate_bool_exp_count {
  arguments: [feature_category_select_column!]
  distinct: Boolean
  filter: feature_category_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "feature_category"
"""
type feature_category_aggregate_fields {
  count(columns: [feature_category_select_column!], distinct: Boolean): Int!
  max: feature_category_max_fields
  min: feature_category_min_fields
}

"""
order by aggregate values of table "feature_category"
"""
input feature_category_aggregate_order_by {
  count: order_by
  max: feature_category_max_order_by
  min: feature_category_min_order_by
}

"""
input type for inserting array relation for remote table "feature_category"
"""
input feature_category_arr_rel_insert_input {
  data: [feature_category_insert_input!]!

  """upsert condition"""
  on_conflict: feature_category_on_conflict
}

"""
Boolean expression to filter rows from the table "feature_category". All fields are combined with a logical 'AND'.
"""
input feature_category_bool_exp {
  _and: [feature_category_bool_exp!]
  _not: feature_category_bool_exp
  _or: [feature_category_bool_exp!]
  category: category_bool_exp
  category_id: String_comparison_exp
  feature: feature_bool_exp
  feature_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "feature_category"
"""
enum feature_category_constraint {
  """
  unique or primary key constraint on columns "feature_id", "category_id"
  """
  featute_category_pkey
}

"""
input type for inserting data into table "feature_category"
"""
input feature_category_insert_input {
  category: category_obj_rel_insert_input
  category_id: String
  feature: feature_obj_rel_insert_input
  feature_id: uuid
}

"""aggregate max on columns"""
type feature_category_max_fields {
  category_id: String
  feature_id: uuid
}

"""
order by max() on columns of table "feature_category"
"""
input feature_category_max_order_by {
  category_id: order_by
  feature_id: order_by
}

"""aggregate min on columns"""
type feature_category_min_fields {
  category_id: String
  feature_id: uuid
}

"""
order by min() on columns of table "feature_category"
"""
input feature_category_min_order_by {
  category_id: order_by
  feature_id: order_by
}

"""
response of any mutation on the table "feature_category"
"""
type feature_category_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [feature_category!]!
}

"""
on_conflict condition type for table "feature_category"
"""
input feature_category_on_conflict {
  constraint: feature_category_constraint!
  update_columns: [feature_category_update_column!]! = []
  where: feature_category_bool_exp
}

"""Ordering options when selecting data from "feature_category"."""
input feature_category_order_by {
  category: category_order_by
  category_id: order_by
  feature: feature_order_by
  feature_id: order_by
}

"""primary key columns input for table: feature_category"""
input feature_category_pk_columns_input {
  category_id: String!
  feature_id: uuid!
}

"""
select columns of table "feature_category"
"""
enum feature_category_select_column {
  """column name"""
  category_id

  """column name"""
  feature_id
}

"""
input type for updating data in table "feature_category"
"""
input feature_category_set_input {
  category_id: String
  feature_id: uuid
}

"""
Streaming cursor of the table "feature_category"
"""
input feature_category_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: feature_category_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input feature_category_stream_cursor_value_input {
  category_id: String
  feature_id: uuid
}

"""
update columns of table "feature_category"
"""
enum feature_category_update_column {
  """column name"""
  category_id

  """column name"""
  feature_id
}

input feature_category_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: feature_category_set_input

  """filter the rows which have to be updated"""
  where: feature_category_bool_exp!
}

"""
unique or primary key constraints on table "feature"
"""
enum feature_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  feature_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input feature_delete_at_path_input {
  config: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input feature_delete_elem_input {
  config: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input feature_delete_key_input {
  config: String
}

"""
input type for inserting data into table "feature"
"""
input feature_insert_input {
  categories: feature_category_arr_rel_insert_input
  config: jsonb
  headline: translated_text_obj_rel_insert_input
  headline_id: uuid
  id: uuid
  internal_name: String
  name: translated_text_obj_rel_insert_input
  name_id: uuid
  organization_id: uuid
  symbol: feature_symbol_enum
  type: feature_type_enum
}

"""aggregate max on columns"""
type feature_max_fields {
  headline_id: uuid
  id: uuid
  internal_name: String
  name_id: uuid
  organization_id: uuid
}

"""
order by max() on columns of table "feature"
"""
input feature_max_order_by {
  headline_id: order_by
  id: order_by
  internal_name: order_by
  name_id: order_by
  organization_id: order_by
}

"""aggregate min on columns"""
type feature_min_fields {
  headline_id: uuid
  id: uuid
  internal_name: String
  name_id: uuid
  organization_id: uuid
}

"""
order by min() on columns of table "feature"
"""
input feature_min_order_by {
  headline_id: order_by
  id: order_by
  internal_name: order_by
  name_id: order_by
  organization_id: order_by
}

"""
response of any mutation on the table "feature"
"""
type feature_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [feature!]!
}

"""
input type for inserting object relation for remote table "feature"
"""
input feature_obj_rel_insert_input {
  data: feature_insert_input!

  """upsert condition"""
  on_conflict: feature_on_conflict
}

"""
on_conflict condition type for table "feature"
"""
input feature_on_conflict {
  constraint: feature_constraint!
  update_columns: [feature_update_column!]! = []
  where: feature_bool_exp
}

"""Ordering options when selecting data from "feature"."""
input feature_order_by {
  categories_aggregate: feature_category_aggregate_order_by
  config: order_by
  headline: translated_text_order_by
  headline_id: order_by
  id: order_by
  internal_name: order_by
  name: translated_text_order_by
  name_id: order_by
  organization_id: order_by
  symbol: order_by
  type: order_by
}

"""primary key columns input for table: feature"""
input feature_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input feature_prepend_input {
  config: jsonb
}

"""
select columns of table "feature"
"""
enum feature_select_column {
  """column name"""
  config

  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  internal_name

  """column name"""
  name_id

  """column name"""
  organization_id

  """column name"""
  symbol

  """column name"""
  type
}

"""
input type for updating data in table "feature"
"""
input feature_set_input {
  config: jsonb
  headline_id: uuid
  id: uuid
  internal_name: String
  name_id: uuid
  organization_id: uuid
  symbol: feature_symbol_enum
  type: feature_type_enum
}

"""
Streaming cursor of the table "feature"
"""
input feature_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: feature_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input feature_stream_cursor_value_input {
  config: jsonb
  headline_id: uuid
  id: uuid
  internal_name: String
  name_id: uuid
  organization_id: uuid
  symbol: feature_symbol_enum
  type: feature_type_enum
}

"""
columns and relationships of "feature_symbol"
"""
type feature_symbol {
  description: String!
  id: String!
}

"""
aggregated selection of "feature_symbol"
"""
type feature_symbol_aggregate {
  aggregate: feature_symbol_aggregate_fields
  nodes: [feature_symbol!]!
}

"""
aggregate fields of "feature_symbol"
"""
type feature_symbol_aggregate_fields {
  count(columns: [feature_symbol_select_column!], distinct: Boolean): Int!
  max: feature_symbol_max_fields
  min: feature_symbol_min_fields
}

"""
Boolean expression to filter rows from the table "feature_symbol". All fields are combined with a logical 'AND'.
"""
input feature_symbol_bool_exp {
  _and: [feature_symbol_bool_exp!]
  _not: feature_symbol_bool_exp
  _or: [feature_symbol_bool_exp!]
  description: String_comparison_exp
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "feature_symbol"
"""
enum feature_symbol_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  feature_symbol_pkey
}

enum feature_symbol_enum {
  """Indicates whether the facility or service is suitable for children"""
  BABY

  """Indicates cancellation policy"""
  BAN

  """Represents number of beds or bedrooms"""
  BED

  """Nice view available"""
  BINOCULARS

  """Indicates if medical service are available"""
  BRIEFCASE_MEDICAL

  """Indicates if transportation is included"""
  BUS

  """Used for showing rental or service periods"""
  CALENDAR_ALT

  """Photo opportunity"""
  CAMERA

  """Indicates parking availability"""
  CAR

  """
  Indicates whether a certification or official document is required or provided
  """
  CERTIFICATE

  """Indicates if operational training is required"""
  CHALKBOARD_TEACHER

  """Indicates maintenance records"""
  CLIPBOARD_CHECK

  """
  Indicates whether drinks, specifically cocktails or alcoholic beverages, are included
  """
  COCKTAIL

  """Indicates whether coffee is available or included"""
  COFFEE

  """Indicates mechanical or engine types"""
  COGS

  """Living room available"""
  COUCH

  """Indicates room type or property access"""
  DOOR_OPEN

  """Gym and fitness center"""
  DUMBBELL

  """Elevator available"""
  ELEVATOR

  """Area"""
  EXPAND_ARROWS

  """Family friend"""
  FAMILY

  """Indicates fishing equipment included"""
  FISH

  """
  Indicates the type of fuel used or provided, applicable to rentals requiring fuel such as vehicles or generators
  """
  FUEL_PUMP

  """Indicates fuel type or capacity"""
  GAS_PUMP

  """
  Indicates whether heating is available or included in the facility or accommodation
  """
  HEATING

  """Represents outdoor or hiking activities"""
  HIKING

  """Entire place available"""
  HOME

  """Indicates duration of an activity"""
  HOURGLASS_HALF

  """Used for license requirements for boats"""
  ID_BADGE

  """Indicates if a special license is required"""
  ID_CARD

  """Indicates language options for a tour or activity"""
  LANGUAGE

  """Eco friendly"""
  LEAF

  """Represents safety equipment"""
  LIFE_RING

  """Smoking is forbiden."""
  NO_SMOKING

  """Parking"""
  PARKING

  """Indicates pet-friendly accommodation"""
  PAW

  """Indicates power requirements"""
  PLUG

  """
  Indicates whether the facility or service is welcoming and inclusive for the LGBTQ+ community
  """
  RAINBOW

  """Indicates the length of boats or other long items"""
  RULER_HORIZONTAL

  """Indicates GPS equipment"""
  SATELLITE_DISH

  """Historic places"""
  SCULPTURE

  """
  Indicates whether insurance is provided or required for participation in the service or activity
  """
  SHIELD

  """Indicates insurance coverage"""
  SHIELD_ALT

  """Used for boat types"""
  SHIP

  """Shower or bath available"""
  SHOWER

  """Indicates difficulty level of an activity"""
  SIGNAL

  """Smoking area. Smoking is allowed."""
  SMOKING

  """Represents air conditioning"""
  SNOWFLAKE

  """
  Indicates whether soft drinks are included with the service or activity
  """
  SODA_CAN

  """
  Indicates exposure to sunlight, relevant for properties or activities where sun exposure is a significant feature
  """
  SUN

  """Indicates a private pool"""
  SWIMMER

  """
  Indicates the presence of a swimming pool at the facility or within the rental property
  """
  SWIMMING_POOL

  """Indicates the top speed of a vehicle"""
  TACHOMETER_ALT

  """Entrance included"""
  TICKET

  """Represents tools or equipment required"""
  TOOLBOX

  """Indicates minimum age requirement"""
  USER

  """Indicates seating or capacity for people"""
  USERS

  """Indicates if a guide or instructor is available"""
  USER_TIE

  """Indicates kitchen facilities"""
  UTENSILS

  """Indicates the weight of an item"""
  WEIGHT_HANGING

  """Indicates accessibility for people with disabilities"""
  WHEELCHAIR

  """Indicates Wi-Fi availability"""
  WIFI
}

"""
Boolean expression to compare columns of type "feature_symbol_enum". All fields are combined with logical 'AND'.
"""
input feature_symbol_enum_comparison_exp {
  _eq: feature_symbol_enum
  _in: [feature_symbol_enum!]
  _is_null: Boolean
  _neq: feature_symbol_enum
  _nin: [feature_symbol_enum!]
}

"""
input type for inserting data into table "feature_symbol"
"""
input feature_symbol_insert_input {
  description: String
  id: String
}

"""aggregate max on columns"""
type feature_symbol_max_fields {
  description: String
  id: String
}

"""aggregate min on columns"""
type feature_symbol_min_fields {
  description: String
  id: String
}

"""
response of any mutation on the table "feature_symbol"
"""
type feature_symbol_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [feature_symbol!]!
}

"""
on_conflict condition type for table "feature_symbol"
"""
input feature_symbol_on_conflict {
  constraint: feature_symbol_constraint!
  update_columns: [feature_symbol_update_column!]! = []
  where: feature_symbol_bool_exp
}

"""Ordering options when selecting data from "feature_symbol"."""
input feature_symbol_order_by {
  description: order_by
  id: order_by
}

"""primary key columns input for table: feature_symbol"""
input feature_symbol_pk_columns_input {
  id: String!
}

"""
select columns of table "feature_symbol"
"""
enum feature_symbol_select_column {
  """column name"""
  description

  """column name"""
  id
}

"""
input type for updating data in table "feature_symbol"
"""
input feature_symbol_set_input {
  description: String
  id: String
}

"""
Streaming cursor of the table "feature_symbol"
"""
input feature_symbol_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: feature_symbol_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input feature_symbol_stream_cursor_value_input {
  description: String
  id: String
}

"""
update columns of table "feature_symbol"
"""
enum feature_symbol_update_column {
  """column name"""
  description

  """column name"""
  id
}

input feature_symbol_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: feature_symbol_set_input

  """filter the rows which have to be updated"""
  where: feature_symbol_bool_exp!
}

"""
columns and relationships of "feature_type"
"""
type feature_type {
  description: String!
  id: String!
}

"""
aggregated selection of "feature_type"
"""
type feature_type_aggregate {
  aggregate: feature_type_aggregate_fields
  nodes: [feature_type!]!
}

"""
aggregate fields of "feature_type"
"""
type feature_type_aggregate_fields {
  count(columns: [feature_type_select_column!], distinct: Boolean): Int!
  max: feature_type_max_fields
  min: feature_type_min_fields
}

"""
Boolean expression to filter rows from the table "feature_type". All fields are combined with a logical 'AND'.
"""
input feature_type_bool_exp {
  _and: [feature_type_bool_exp!]
  _not: feature_type_bool_exp
  _or: [feature_type_bool_exp!]
  description: String_comparison_exp
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "feature_type"
"""
enum feature_type_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  feature_type_pkey
}

enum feature_type_enum {
  """A true or false value, used for features that have binary options"""
  BOOLEAN

  """A numerical value with decimals, used for precise measurements"""
  DECIMAL

  """A predefined list of options from which one can be selected"""
  DROPDOWN

  """A numerical value without decimals, used for whole numbers"""
  INTEGER

  """Alphanumeric characters, used for descriptions or names"""
  TEXT
}

"""
Boolean expression to compare columns of type "feature_type_enum". All fields are combined with logical 'AND'.
"""
input feature_type_enum_comparison_exp {
  _eq: feature_type_enum
  _in: [feature_type_enum!]
  _is_null: Boolean
  _neq: feature_type_enum
  _nin: [feature_type_enum!]
}

"""
input type for inserting data into table "feature_type"
"""
input feature_type_insert_input {
  description: String
  id: String
}

"""aggregate max on columns"""
type feature_type_max_fields {
  description: String
  id: String
}

"""aggregate min on columns"""
type feature_type_min_fields {
  description: String
  id: String
}

"""
response of any mutation on the table "feature_type"
"""
type feature_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [feature_type!]!
}

"""
on_conflict condition type for table "feature_type"
"""
input feature_type_on_conflict {
  constraint: feature_type_constraint!
  update_columns: [feature_type_update_column!]! = []
  where: feature_type_bool_exp
}

"""Ordering options when selecting data from "feature_type"."""
input feature_type_order_by {
  description: order_by
  id: order_by
}

"""primary key columns input for table: feature_type"""
input feature_type_pk_columns_input {
  id: String!
}

"""
select columns of table "feature_type"
"""
enum feature_type_select_column {
  """column name"""
  description

  """column name"""
  id
}

"""
input type for updating data in table "feature_type"
"""
input feature_type_set_input {
  description: String
  id: String
}

"""
Streaming cursor of the table "feature_type"
"""
input feature_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: feature_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input feature_type_stream_cursor_value_input {
  description: String
  id: String
}

"""
update columns of table "feature_type"
"""
enum feature_type_update_column {
  """column name"""
  description

  """column name"""
  id
}

input feature_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: feature_type_set_input

  """filter the rows which have to be updated"""
  where: feature_type_bool_exp!
}

"""
update columns of table "feature"
"""
enum feature_update_column {
  """column name"""
  config

  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  internal_name

  """column name"""
  name_id

  """column name"""
  organization_id

  """column name"""
  symbol

  """column name"""
  type
}

input feature_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: feature_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: feature_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: feature_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: feature_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: feature_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: feature_set_input

  """filter the rows which have to be updated"""
  where: feature_bool_exp!
}

input feature_with_value_input {
  feature_id: uuid!
  value: json
}

"""
columns and relationships of "storage.files"
"""
type files {
  """An object relationship"""
  bucket: buckets!
  bucketId: String!
  createdAt: timestamptz!
  etag: String
  id: uuid!
  isUploaded: Boolean
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz!
  uploadedByUserId: uuid
}

"""
aggregated selection of "storage.files"
"""
type files_aggregate {
  aggregate: files_aggregate_fields
  nodes: [files!]!
}

input files_aggregate_bool_exp {
  bool_and: files_aggregate_bool_exp_bool_and
  bool_or: files_aggregate_bool_exp_bool_or
  count: files_aggregate_bool_exp_count
}

input files_aggregate_bool_exp_bool_and {
  arguments: files_select_column_files_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: files_bool_exp
  predicate: Boolean_comparison_exp!
}

input files_aggregate_bool_exp_bool_or {
  arguments: files_select_column_files_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: files_bool_exp
  predicate: Boolean_comparison_exp!
}

input files_aggregate_bool_exp_count {
  arguments: [files_select_column!]
  distinct: Boolean
  filter: files_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "storage.files"
"""
type files_aggregate_fields {
  avg: files_avg_fields
  count(columns: [files_select_column!], distinct: Boolean): Int!
  max: files_max_fields
  min: files_min_fields
  stddev: files_stddev_fields
  stddev_pop: files_stddev_pop_fields
  stddev_samp: files_stddev_samp_fields
  sum: files_sum_fields
  var_pop: files_var_pop_fields
  var_samp: files_var_samp_fields
  variance: files_variance_fields
}

"""
order by aggregate values of table "storage.files"
"""
input files_aggregate_order_by {
  avg: files_avg_order_by
  count: order_by
  max: files_max_order_by
  min: files_min_order_by
  stddev: files_stddev_order_by
  stddev_pop: files_stddev_pop_order_by
  stddev_samp: files_stddev_samp_order_by
  sum: files_sum_order_by
  var_pop: files_var_pop_order_by
  var_samp: files_var_samp_order_by
  variance: files_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input files_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "storage.files"
"""
input files_arr_rel_insert_input {
  data: [files_insert_input!]!

  """upsert condition"""
  on_conflict: files_on_conflict
}

"""aggregate avg on columns"""
type files_avg_fields {
  size: Float
}

"""
order by avg() on columns of table "storage.files"
"""
input files_avg_order_by {
  size: order_by
}

"""
Boolean expression to filter rows from the table "storage.files". All fields are combined with a logical 'AND'.
"""
input files_bool_exp {
  _and: [files_bool_exp!]
  _not: files_bool_exp
  _or: [files_bool_exp!]
  bucket: buckets_bool_exp
  bucketId: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  etag: String_comparison_exp
  id: uuid_comparison_exp
  isUploaded: Boolean_comparison_exp
  metadata: jsonb_comparison_exp
  mimeType: String_comparison_exp
  name: String_comparison_exp
  size: Int_comparison_exp
  updatedAt: timestamptz_comparison_exp
  uploadedByUserId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "storage.files"
"""
enum files_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  files_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input files_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input files_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input files_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "storage.files"
"""
input files_inc_input {
  size: Int
}

"""
input type for inserting data into table "storage.files"
"""
input files_insert_input {
  bucket: buckets_obj_rel_insert_input
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  metadata: jsonb
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate max on columns"""
type files_max_fields {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""
order by max() on columns of table "storage.files"
"""
input files_max_order_by {
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""aggregate min on columns"""
type files_min_fields {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""
order by min() on columns of table "storage.files"
"""
input files_min_order_by {
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""
response of any mutation on the table "storage.files"
"""
type files_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [files!]!
}

"""
input type for inserting object relation for remote table "storage.files"
"""
input files_obj_rel_insert_input {
  data: files_insert_input!

  """upsert condition"""
  on_conflict: files_on_conflict
}

"""
on_conflict condition type for table "storage.files"
"""
input files_on_conflict {
  constraint: files_constraint!
  update_columns: [files_update_column!]! = []
  where: files_bool_exp
}

"""Ordering options when selecting data from "storage.files"."""
input files_order_by {
  bucket: buckets_order_by
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  isUploaded: order_by
  metadata: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""primary key columns input for table: storage.files"""
input files_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input files_prepend_input {
  metadata: jsonb
}

"""
select columns of table "storage.files"
"""
enum files_select_column {
  """column name"""
  bucketId

  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  isUploaded

  """column name"""
  metadata

  """column name"""
  mimeType

  """column name"""
  name

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploadedByUserId
}

"""
select "files_aggregate_bool_exp_bool_and_arguments_columns" columns of table "storage.files"
"""
enum files_select_column_files_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  isUploaded
}

"""
select "files_aggregate_bool_exp_bool_or_arguments_columns" columns of table "storage.files"
"""
enum files_select_column_files_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  isUploaded
}

"""
input type for updating data in table "storage.files"
"""
input files_set_input {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  metadata: jsonb
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate stddev on columns"""
type files_stddev_fields {
  size: Float
}

"""
order by stddev() on columns of table "storage.files"
"""
input files_stddev_order_by {
  size: order_by
}

"""aggregate stddev_pop on columns"""
type files_stddev_pop_fields {
  size: Float
}

"""
order by stddev_pop() on columns of table "storage.files"
"""
input files_stddev_pop_order_by {
  size: order_by
}

"""aggregate stddev_samp on columns"""
type files_stddev_samp_fields {
  size: Float
}

"""
order by stddev_samp() on columns of table "storage.files"
"""
input files_stddev_samp_order_by {
  size: order_by
}

"""
Streaming cursor of the table "files"
"""
input files_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: files_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input files_stream_cursor_value_input {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  metadata: jsonb
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate sum on columns"""
type files_sum_fields {
  size: Int
}

"""
order by sum() on columns of table "storage.files"
"""
input files_sum_order_by {
  size: order_by
}

"""
update columns of table "storage.files"
"""
enum files_update_column {
  """column name"""
  bucketId

  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  isUploaded

  """column name"""
  metadata

  """column name"""
  mimeType

  """column name"""
  name

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploadedByUserId
}

input files_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: files_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: files_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: files_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: files_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: files_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: files_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: files_set_input

  """filter the rows which have to be updated"""
  where: files_bool_exp!
}

"""aggregate var_pop on columns"""
type files_var_pop_fields {
  size: Float
}

"""
order by var_pop() on columns of table "storage.files"
"""
input files_var_pop_order_by {
  size: order_by
}

"""aggregate var_samp on columns"""
type files_var_samp_fields {
  size: Float
}

"""
order by var_samp() on columns of table "storage.files"
"""
input files_var_samp_order_by {
  size: order_by
}

"""aggregate variance on columns"""
type files_variance_fields {
  size: Float
}

"""
order by variance() on columns of table "storage.files"
"""
input files_variance_order_by {
  size: order_by
}

input get_booking_input {
  contact_email: String!
  friendly_id: String!
}

scalar json

"""
Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

scalar lquery

scalar ltree

"""
Boolean expression to compare columns of type "ltree". All fields are combined with logical 'AND'.
"""
input ltree_comparison_exp {
  """is the left argument an ancestor of right (or equal)?"""
  _ancestor: ltree

  """does array contain an ancestor of `ltree`?"""
  _ancestor_any: [ltree!]

  """is the left argument a descendant of right (or equal)?"""
  _descendant: ltree

  """does array contain a descendant of `ltree`?"""
  _descendant_any: [ltree!]
  _eq: ltree
  _gt: ltree
  _gte: ltree
  _in: [ltree!]
  _is_null: Boolean
  _lt: ltree
  _lte: ltree

  """does `ltree` match `lquery`?"""
  _matches: lquery

  """does `ltree` match any `lquery` in array?"""
  _matches_any: [String!]

  """does `ltree` match `ltxtquery`?"""
  _matches_fulltext: ltxtquery
  _neq: ltree
  _nin: [ltree!]
}

scalar ltxtquery

"""
columns and relationships of "media_gallery"
"""
type media_gallery {
  """An object relationship"""
  headline: translated_text!
  headline_id: uuid!
  id: uuid!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinct_on: [media_gallery_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_gallery_item_order_by!]

    """filter the rows returned"""
    where: media_gallery_item_bool_exp
  ): [media_gallery_item!]!

  """An aggregate relationship"""
  items_aggregate(
    """distinct select on columns"""
    distinct_on: [media_gallery_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_gallery_item_order_by!]

    """filter the rows returned"""
    where: media_gallery_item_bool_exp
  ): media_gallery_item_aggregate!

  """An object relationship"""
  name: translated_text
  name_id: uuid!
}

"""
aggregated selection of "media_gallery"
"""
type media_gallery_aggregate {
  aggregate: media_gallery_aggregate_fields
  nodes: [media_gallery!]!
}

"""
aggregate fields of "media_gallery"
"""
type media_gallery_aggregate_fields {
  count(columns: [media_gallery_select_column!], distinct: Boolean): Int!
  max: media_gallery_max_fields
  min: media_gallery_min_fields
}

"""
Boolean expression to filter rows from the table "media_gallery". All fields are combined with a logical 'AND'.
"""
input media_gallery_bool_exp {
  _and: [media_gallery_bool_exp!]
  _not: media_gallery_bool_exp
  _or: [media_gallery_bool_exp!]
  headline: translated_text_bool_exp
  headline_id: uuid_comparison_exp
  id: uuid_comparison_exp
  items: media_gallery_item_bool_exp
  items_aggregate: media_gallery_item_aggregate_bool_exp
  name: translated_text_bool_exp
  name_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "media_gallery"
"""
enum media_gallery_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  media_gallery_pkey
}

input media_gallery_input {
  headline: multilanguage_field_input
  id: String!
  items: [media_gallery_item_input!]!
  name: multilanguage_field_input
}

"""
input type for inserting data into table "media_gallery"
"""
input media_gallery_insert_input {
  headline: translated_text_obj_rel_insert_input
  headline_id: uuid
  id: uuid
  items: media_gallery_item_arr_rel_insert_input
  name: translated_text_obj_rel_insert_input
  name_id: uuid
}

"""
columns and relationships of "media_gallery_item"
"""
type media_gallery_item {
  """An object relationship"""
  file: files!
  file_id: uuid!
  gallery_id: uuid!

  """An object relationship"""
  headline: translated_text
  headline_id: uuid!
  id: uuid!

  """An object relationship"""
  name: translated_text!
  name_id: uuid!
  position: numeric!
}

"""
aggregated selection of "media_gallery_item"
"""
type media_gallery_item_aggregate {
  aggregate: media_gallery_item_aggregate_fields
  nodes: [media_gallery_item!]!
}

input media_gallery_item_aggregate_bool_exp {
  count: media_gallery_item_aggregate_bool_exp_count
}

input media_gallery_item_aggregate_bool_exp_count {
  arguments: [media_gallery_item_select_column!]
  distinct: Boolean
  filter: media_gallery_item_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "media_gallery_item"
"""
type media_gallery_item_aggregate_fields {
  avg: media_gallery_item_avg_fields
  count(columns: [media_gallery_item_select_column!], distinct: Boolean): Int!
  max: media_gallery_item_max_fields
  min: media_gallery_item_min_fields
  stddev: media_gallery_item_stddev_fields
  stddev_pop: media_gallery_item_stddev_pop_fields
  stddev_samp: media_gallery_item_stddev_samp_fields
  sum: media_gallery_item_sum_fields
  var_pop: media_gallery_item_var_pop_fields
  var_samp: media_gallery_item_var_samp_fields
  variance: media_gallery_item_variance_fields
}

"""
order by aggregate values of table "media_gallery_item"
"""
input media_gallery_item_aggregate_order_by {
  avg: media_gallery_item_avg_order_by
  count: order_by
  max: media_gallery_item_max_order_by
  min: media_gallery_item_min_order_by
  stddev: media_gallery_item_stddev_order_by
  stddev_pop: media_gallery_item_stddev_pop_order_by
  stddev_samp: media_gallery_item_stddev_samp_order_by
  sum: media_gallery_item_sum_order_by
  var_pop: media_gallery_item_var_pop_order_by
  var_samp: media_gallery_item_var_samp_order_by
  variance: media_gallery_item_variance_order_by
}

"""
input type for inserting array relation for remote table "media_gallery_item"
"""
input media_gallery_item_arr_rel_insert_input {
  data: [media_gallery_item_insert_input!]!

  """upsert condition"""
  on_conflict: media_gallery_item_on_conflict
}

"""aggregate avg on columns"""
type media_gallery_item_avg_fields {
  position: Float
}

"""
order by avg() on columns of table "media_gallery_item"
"""
input media_gallery_item_avg_order_by {
  position: order_by
}

"""
Boolean expression to filter rows from the table "media_gallery_item". All fields are combined with a logical 'AND'.
"""
input media_gallery_item_bool_exp {
  _and: [media_gallery_item_bool_exp!]
  _not: media_gallery_item_bool_exp
  _or: [media_gallery_item_bool_exp!]
  file: files_bool_exp
  file_id: uuid_comparison_exp
  gallery_id: uuid_comparison_exp
  headline: translated_text_bool_exp
  headline_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: translated_text_bool_exp
  name_id: uuid_comparison_exp
  position: numeric_comparison_exp
}

"""
unique or primary key constraints on table "media_gallery_item"
"""
enum media_gallery_item_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  media_gallery_item_pkey
}

"""
input type for incrementing numeric columns in table "media_gallery_item"
"""
input media_gallery_item_inc_input {
  position: numeric
}

input media_gallery_item_input {
  file_id: uuid!
  headline: multilanguage_field_input
  name: multilanguage_field_input
}

"""
input type for inserting data into table "media_gallery_item"
"""
input media_gallery_item_insert_input {
  file: files_obj_rel_insert_input
  file_id: uuid
  gallery_id: uuid
  headline: translated_text_obj_rel_insert_input
  headline_id: uuid
  id: uuid
  name: translated_text_obj_rel_insert_input
  name_id: uuid
  position: numeric
}

"""aggregate max on columns"""
type media_gallery_item_max_fields {
  file_id: uuid
  gallery_id: uuid
  headline_id: uuid
  id: uuid
  name_id: uuid
  position: numeric
}

"""
order by max() on columns of table "media_gallery_item"
"""
input media_gallery_item_max_order_by {
  file_id: order_by
  gallery_id: order_by
  headline_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
}

"""aggregate min on columns"""
type media_gallery_item_min_fields {
  file_id: uuid
  gallery_id: uuid
  headline_id: uuid
  id: uuid
  name_id: uuid
  position: numeric
}

"""
order by min() on columns of table "media_gallery_item"
"""
input media_gallery_item_min_order_by {
  file_id: order_by
  gallery_id: order_by
  headline_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
}

"""
response of any mutation on the table "media_gallery_item"
"""
type media_gallery_item_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [media_gallery_item!]!
}

"""
on_conflict condition type for table "media_gallery_item"
"""
input media_gallery_item_on_conflict {
  constraint: media_gallery_item_constraint!
  update_columns: [media_gallery_item_update_column!]! = []
  where: media_gallery_item_bool_exp
}

"""Ordering options when selecting data from "media_gallery_item"."""
input media_gallery_item_order_by {
  file: files_order_by
  file_id: order_by
  gallery_id: order_by
  headline: translated_text_order_by
  headline_id: order_by
  id: order_by
  name: translated_text_order_by
  name_id: order_by
  position: order_by
}

"""primary key columns input for table: media_gallery_item"""
input media_gallery_item_pk_columns_input {
  id: uuid!
}

"""
select columns of table "media_gallery_item"
"""
enum media_gallery_item_select_column {
  """column name"""
  file_id

  """column name"""
  gallery_id

  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  position
}

"""
input type for updating data in table "media_gallery_item"
"""
input media_gallery_item_set_input {
  file_id: uuid
  gallery_id: uuid
  headline_id: uuid
  id: uuid
  name_id: uuid
  position: numeric
}

"""aggregate stddev on columns"""
type media_gallery_item_stddev_fields {
  position: Float
}

"""
order by stddev() on columns of table "media_gallery_item"
"""
input media_gallery_item_stddev_order_by {
  position: order_by
}

"""aggregate stddev_pop on columns"""
type media_gallery_item_stddev_pop_fields {
  position: Float
}

"""
order by stddev_pop() on columns of table "media_gallery_item"
"""
input media_gallery_item_stddev_pop_order_by {
  position: order_by
}

"""aggregate stddev_samp on columns"""
type media_gallery_item_stddev_samp_fields {
  position: Float
}

"""
order by stddev_samp() on columns of table "media_gallery_item"
"""
input media_gallery_item_stddev_samp_order_by {
  position: order_by
}

"""
Streaming cursor of the table "media_gallery_item"
"""
input media_gallery_item_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: media_gallery_item_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input media_gallery_item_stream_cursor_value_input {
  file_id: uuid
  gallery_id: uuid
  headline_id: uuid
  id: uuid
  name_id: uuid
  position: numeric
}

"""aggregate sum on columns"""
type media_gallery_item_sum_fields {
  position: numeric
}

"""
order by sum() on columns of table "media_gallery_item"
"""
input media_gallery_item_sum_order_by {
  position: order_by
}

"""
update columns of table "media_gallery_item"
"""
enum media_gallery_item_update_column {
  """column name"""
  file_id

  """column name"""
  gallery_id

  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  position
}

input media_gallery_item_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: media_gallery_item_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: media_gallery_item_set_input

  """filter the rows which have to be updated"""
  where: media_gallery_item_bool_exp!
}

"""aggregate var_pop on columns"""
type media_gallery_item_var_pop_fields {
  position: Float
}

"""
order by var_pop() on columns of table "media_gallery_item"
"""
input media_gallery_item_var_pop_order_by {
  position: order_by
}

"""aggregate var_samp on columns"""
type media_gallery_item_var_samp_fields {
  position: Float
}

"""
order by var_samp() on columns of table "media_gallery_item"
"""
input media_gallery_item_var_samp_order_by {
  position: order_by
}

"""aggregate variance on columns"""
type media_gallery_item_variance_fields {
  position: Float
}

"""
order by variance() on columns of table "media_gallery_item"
"""
input media_gallery_item_variance_order_by {
  position: order_by
}

"""aggregate max on columns"""
type media_gallery_max_fields {
  headline_id: uuid
  id: uuid
  name_id: uuid
}

"""aggregate min on columns"""
type media_gallery_min_fields {
  headline_id: uuid
  id: uuid
  name_id: uuid
}

"""
response of any mutation on the table "media_gallery"
"""
type media_gallery_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [media_gallery!]!
}

"""
input type for inserting object relation for remote table "media_gallery"
"""
input media_gallery_obj_rel_insert_input {
  data: media_gallery_insert_input!

  """upsert condition"""
  on_conflict: media_gallery_on_conflict
}

"""
on_conflict condition type for table "media_gallery"
"""
input media_gallery_on_conflict {
  constraint: media_gallery_constraint!
  update_columns: [media_gallery_update_column!]! = []
  where: media_gallery_bool_exp
}

"""Ordering options when selecting data from "media_gallery"."""
input media_gallery_order_by {
  headline: translated_text_order_by
  headline_id: order_by
  id: order_by
  items_aggregate: media_gallery_item_aggregate_order_by
  name: translated_text_order_by
  name_id: order_by
}

"""primary key columns input for table: media_gallery"""
input media_gallery_pk_columns_input {
  id: uuid!
}

"""
select columns of table "media_gallery"
"""
enum media_gallery_select_column {
  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  name_id
}

"""
input type for updating data in table "media_gallery"
"""
input media_gallery_set_input {
  headline_id: uuid
  id: uuid
  name_id: uuid
}

"""
Streaming cursor of the table "media_gallery"
"""
input media_gallery_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: media_gallery_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input media_gallery_stream_cursor_value_input {
  headline_id: uuid
  id: uuid
  name_id: uuid
}

"""
update columns of table "media_gallery"
"""
enum media_gallery_update_column {
  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  name_id
}

input media_gallery_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: media_gallery_set_input

  """filter the rows which have to be updated"""
  where: media_gallery_bool_exp!
}

input multilanguage_field_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""mutation root"""
type mutation_root {
  """activate_organization_features"""
  activate_organization_features(arg: activate_organization_features_input!): json!
  booking_accept(arg: booking_accept_input!): json!
  booking_add_note(arg: booking_add_note_input!): json!
  booking_cancel(arg: booking_cancel_input!): json!
  booking_create(arg: booking_create_input!): json!
  booking_reject(arg: booking_reject_input!): json!
  cleanup(arg: cleanup_input): json!
  contact(arg: contact_input!): json!
  create_product(arg: product_create_input!): json!
  create_rate(arg: rate_create_input!): json!

  """
  delete single row from the table: "auth.providers"
  """
  deleteAuthProvider(id: String!): authProviders

  """
  delete single row from the table: "auth.provider_requests"
  """
  deleteAuthProviderRequest(id: uuid!): authProviderRequests

  """
  delete data from the table: "auth.provider_requests"
  """
  deleteAuthProviderRequests(
    """filter the rows which have to be deleted"""
    where: authProviderRequests_bool_exp!
  ): authProviderRequests_mutation_response

  """
  delete data from the table: "auth.providers"
  """
  deleteAuthProviders(
    """filter the rows which have to be deleted"""
    where: authProviders_bool_exp!
  ): authProviders_mutation_response

  """
  delete single row from the table: "auth.refresh_tokens"
  """
  deleteAuthRefreshToken(id: uuid!): authRefreshTokens

  """
  delete single row from the table: "auth.refresh_token_types"
  """
  deleteAuthRefreshTokenType(value: String!): authRefreshTokenTypes

  """
  delete data from the table: "auth.refresh_token_types"
  """
  deleteAuthRefreshTokenTypes(
    """filter the rows which have to be deleted"""
    where: authRefreshTokenTypes_bool_exp!
  ): authRefreshTokenTypes_mutation_response

  """
  delete data from the table: "auth.refresh_tokens"
  """
  deleteAuthRefreshTokens(
    """filter the rows which have to be deleted"""
    where: authRefreshTokens_bool_exp!
  ): authRefreshTokens_mutation_response

  """
  delete single row from the table: "auth.roles"
  """
  deleteAuthRole(role: String!): authRoles

  """
  delete data from the table: "auth.roles"
  """
  deleteAuthRoles(
    """filter the rows which have to be deleted"""
    where: authRoles_bool_exp!
  ): authRoles_mutation_response

  """
  delete single row from the table: "auth.user_providers"
  """
  deleteAuthUserProvider(id: uuid!): authUserProviders

  """
  delete data from the table: "auth.user_providers"
  """
  deleteAuthUserProviders(
    """filter the rows which have to be deleted"""
    where: authUserProviders_bool_exp!
  ): authUserProviders_mutation_response

  """
  delete single row from the table: "auth.user_roles"
  """
  deleteAuthUserRole(id: uuid!): authUserRoles

  """
  delete data from the table: "auth.user_roles"
  """
  deleteAuthUserRoles(
    """filter the rows which have to be deleted"""
    where: authUserRoles_bool_exp!
  ): authUserRoles_mutation_response

  """
  delete single row from the table: "auth.user_security_keys"
  """
  deleteAuthUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  delete data from the table: "auth.user_security_keys"
  """
  deleteAuthUserSecurityKeys(
    """filter the rows which have to be deleted"""
    where: authUserSecurityKeys_bool_exp!
  ): authUserSecurityKeys_mutation_response

  """
  delete single row from the table: "storage.buckets"
  """
  deleteBucket(id: String!): buckets

  """
  delete data from the table: "storage.buckets"
  """
  deleteBuckets(
    """filter the rows which have to be deleted"""
    where: buckets_bool_exp!
  ): buckets_mutation_response

  """
  delete single row from the table: "storage.files"
  """
  deleteFile(id: uuid!): files

  """
  delete data from the table: "storage.files"
  """
  deleteFiles(
    """filter the rows which have to be deleted"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  delete single row from the table: "auth.users"
  """
  deleteUser(id: uuid!): users

  """
  delete data from the table: "auth.users"
  """
  deleteUsers(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "storage.virus"
  """
  deleteVirus(id: uuid!): virus

  """
  delete data from the table: "storage.virus"
  """
  deleteViruses(
    """filter the rows which have to be deleted"""
    where: virus_bool_exp!
  ): virus_mutation_response

  """
  delete data from the table: "booking"
  """
  delete_booking(
    """filter the rows which have to be deleted"""
    where: booking_bool_exp!
  ): booking_mutation_response

  """
  delete single row from the table: "booking"
  """
  delete_booking_by_pk(id: uuid!): booking

  """
  delete data from the table: "booking_events.event_type"
  """
  delete_booking_events_event_type(
    """filter the rows which have to be deleted"""
    where: booking_events_event_type_bool_exp!
  ): booking_events_event_type_mutation_response

  """
  delete single row from the table: "booking_events.event_type"
  """
  delete_booking_events_event_type_by_pk(id: String!): booking_events_event_type

  """
  delete data from the table: "booking_events.main"
  """
  delete_booking_events_main(
    """filter the rows which have to be deleted"""
    where: booking_events_main_bool_exp!
  ): booking_events_main_mutation_response

  """
  delete single row from the table: "booking_events.main"
  """
  delete_booking_events_main_by_pk(id: uuid!): booking_events_main

  """
  delete data from the table: "booking_events.version"
  """
  delete_booking_events_version(
    """filter the rows which have to be deleted"""
    where: booking_events_version_bool_exp!
  ): booking_events_version_mutation_response

  """
  delete single row from the table: "booking_events.version"
  """
  delete_booking_events_version_by_pk(id: uuid!): booking_events_version

  """
  delete data from the table: "booking_history_entry"
  """
  delete_booking_history_entry(
    """filter the rows which have to be deleted"""
    where: booking_history_entry_bool_exp!
  ): booking_history_entry_mutation_response

  """
  delete single row from the table: "booking_history_entry"
  """
  delete_booking_history_entry_by_pk(id: uuid!): booking_history_entry

  """
  delete data from the table: "booking_product"
  """
  delete_booking_product(
    """filter the rows which have to be deleted"""
    where: booking_product_bool_exp!
  ): booking_product_mutation_response

  """
  delete single row from the table: "booking_product"
  """
  delete_booking_product_by_pk(id: uuid!): booking_product

  """
  delete data from the table: "booking_question_scope"
  """
  delete_booking_question_scope(
    """filter the rows which have to be deleted"""
    where: booking_question_scope_bool_exp!
  ): booking_question_scope_mutation_response

  """
  delete single row from the table: "booking_question_scope"
  """
  delete_booking_question_scope_by_pk(id: String!): booking_question_scope

  """
  delete data from the table: "booking_question_type"
  """
  delete_booking_question_type(
    """filter the rows which have to be deleted"""
    where: booking_question_type_bool_exp!
  ): booking_question_type_mutation_response

  """
  delete single row from the table: "booking_question_type"
  """
  delete_booking_question_type_by_pk(id: String!): booking_question_type

  """
  delete data from the table: "booking_state"
  """
  delete_booking_state(
    """filter the rows which have to be deleted"""
    where: booking_state_bool_exp!
  ): booking_state_mutation_response

  """
  delete single row from the table: "booking_state"
  """
  delete_booking_state_by_pk(id: String!): booking_state

  """
  delete data from the table: "category"
  """
  delete_category(
    """filter the rows which have to be deleted"""
    where: category_bool_exp!
  ): category_mutation_response

  """
  delete single row from the table: "category"
  """
  delete_category_by_pk(id: String!): category

  """
  delete data from the table: "contact"
  """
  delete_contact(
    """filter the rows which have to be deleted"""
    where: contact_bool_exp!
  ): contact_mutation_response

  """
  delete single row from the table: "contact"
  """
  delete_contact_by_pk(id: uuid!): contact

  """
  delete data from the table: "feature"
  """
  delete_feature(
    """filter the rows which have to be deleted"""
    where: feature_bool_exp!
  ): feature_mutation_response

  """
  delete single row from the table: "feature"
  """
  delete_feature_by_pk(id: uuid!): feature

  """
  delete data from the table: "feature_category"
  """
  delete_feature_category(
    """filter the rows which have to be deleted"""
    where: feature_category_bool_exp!
  ): feature_category_mutation_response

  """
  delete single row from the table: "feature_category"
  """
  delete_feature_category_by_pk(category_id: String!, feature_id: uuid!): feature_category

  """
  delete data from the table: "feature_symbol"
  """
  delete_feature_symbol(
    """filter the rows which have to be deleted"""
    where: feature_symbol_bool_exp!
  ): feature_symbol_mutation_response

  """
  delete single row from the table: "feature_symbol"
  """
  delete_feature_symbol_by_pk(id: String!): feature_symbol

  """
  delete data from the table: "feature_type"
  """
  delete_feature_type(
    """filter the rows which have to be deleted"""
    where: feature_type_bool_exp!
  ): feature_type_mutation_response

  """
  delete single row from the table: "feature_type"
  """
  delete_feature_type_by_pk(id: String!): feature_type

  """
  delete data from the table: "media_gallery"
  """
  delete_media_gallery(
    """filter the rows which have to be deleted"""
    where: media_gallery_bool_exp!
  ): media_gallery_mutation_response

  """
  delete single row from the table: "media_gallery"
  """
  delete_media_gallery_by_pk(id: uuid!): media_gallery

  """
  delete data from the table: "media_gallery_item"
  """
  delete_media_gallery_item(
    """filter the rows which have to be deleted"""
    where: media_gallery_item_bool_exp!
  ): media_gallery_item_mutation_response

  """
  delete single row from the table: "media_gallery_item"
  """
  delete_media_gallery_item_by_pk(id: uuid!): media_gallery_item

  """
  delete data from the table: "my_web_section"
  """
  delete_my_web_section(
    """filter the rows which have to be deleted"""
    where: my_web_section_bool_exp!
  ): my_web_section_mutation_response

  """
  delete single row from the table: "my_web_section"
  """
  delete_my_web_section_by_pk(organization_id: uuid!, section_id: String!): my_web_section

  """
  delete data from the table: "organization"
  """
  delete_organization(
    """filter the rows which have to be deleted"""
    where: organization_bool_exp!
  ): organization_mutation_response

  """
  delete data from the table: "organization_booking_question"
  """
  delete_organization_booking_question(
    """filter the rows which have to be deleted"""
    where: organization_booking_question_bool_exp!
  ): organization_booking_question_mutation_response

  """
  delete single row from the table: "organization_booking_question"
  """
  delete_organization_booking_question_by_pk(id: uuid!): organization_booking_question

  """
  delete data from the table: "organization_branding"
  """
  delete_organization_branding(
    """filter the rows which have to be deleted"""
    where: organization_branding_bool_exp!
  ): organization_branding_mutation_response

  """
  delete single row from the table: "organization_branding"
  """
  delete_organization_branding_by_pk(id: uuid!): organization_branding

  """
  delete data from the table: "organization_branding_meta_description"
  """
  delete_organization_branding_meta_description(
    """filter the rows which have to be deleted"""
    where: organization_branding_meta_description_bool_exp!
  ): organization_branding_meta_description_mutation_response

  """
  delete single row from the table: "organization_branding_meta_description"
  """
  delete_organization_branding_meta_description_by_pk(id: uuid!): organization_branding_meta_description

  """
  delete data from the table: "organization_branding_meta_title"
  """
  delete_organization_branding_meta_title(
    """filter the rows which have to be deleted"""
    where: organization_branding_meta_title_bool_exp!
  ): organization_branding_meta_title_mutation_response

  """
  delete single row from the table: "organization_branding_meta_title"
  """
  delete_organization_branding_meta_title_by_pk(id: uuid!): organization_branding_meta_title

  """
  delete data from the table: "organization_business_model"
  """
  delete_organization_business_model(
    """filter the rows which have to be deleted"""
    where: organization_business_model_bool_exp!
  ): organization_business_model_mutation_response

  """
  delete single row from the table: "organization_business_model"
  """
  delete_organization_business_model_by_pk(id: uuid!): organization_business_model

  """
  delete single row from the table: "organization"
  """
  delete_organization_by_pk(id: uuid!): organization

  """
  delete data from the table: "organization_headline"
  """
  delete_organization_headline(
    """filter the rows which have to be deleted"""
    where: organization_headline_bool_exp!
  ): organization_headline_mutation_response

  """
  delete single row from the table: "organization_headline"
  """
  delete_organization_headline_by_pk(id: uuid!): organization_headline

  """
  delete data from the table: "organization_member"
  """
  delete_organization_member(
    """filter the rows which have to be deleted"""
    where: organization_member_bool_exp!
  ): organization_member_mutation_response

  """
  delete single row from the table: "organization_member"
  """
  delete_organization_member_by_pk(organization_id: uuid!, user_id: uuid!): organization_member

  """
  delete data from the table: "organization_socials"
  """
  delete_organization_socials(
    """filter the rows which have to be deleted"""
    where: organization_socials_bool_exp!
  ): organization_socials_mutation_response

  """
  delete single row from the table: "organization_socials"
  """
  delete_organization_socials_by_pk(id: uuid!): organization_socials

  """
  delete data from the table: "place"
  """
  delete_place(
    """filter the rows which have to be deleted"""
    where: place_bool_exp!
  ): place_mutation_response

  """
  delete single row from the table: "place"
  """
  delete_place_by_pk(id: uuid!): place

  """
  delete data from the table: "product"
  """
  delete_product(
    """filter the rows which have to be deleted"""
    where: product_bool_exp!
  ): product_mutation_response

  """
  delete data from the table: "product_allotment_range"
  """
  delete_product_allotment_range(
    """filter the rows which have to be deleted"""
    where: product_allotment_range_bool_exp!
  ): product_allotment_range_mutation_response

  """
  delete single row from the table: "product_allotment_range"
  """
  delete_product_allotment_range_by_pk(id: uuid!): product_allotment_range

  """
  delete data from the table: "product_business_model"
  """
  delete_product_business_model(
    """filter the rows which have to be deleted"""
    where: product_business_model_bool_exp!
  ): product_business_model_mutation_response

  """
  delete single row from the table: "product_business_model"
  """
  delete_product_business_model_by_pk(id: uuid!): product_business_model

  """
  delete single row from the table: "product"
  """
  delete_product_by_pk(id: uuid!): product

  """
  delete data from the table: "product_description"
  """
  delete_product_description(
    """filter the rows which have to be deleted"""
    where: product_description_bool_exp!
  ): product_description_mutation_response

  """
  delete single row from the table: "product_description"
  """
  delete_product_description_by_pk(id: uuid!): product_description

  """
  delete data from the table: "product_feature"
  """
  delete_product_feature(
    """filter the rows which have to be deleted"""
    where: product_feature_bool_exp!
  ): product_feature_mutation_response

  """
  delete single row from the table: "product_feature"
  """
  delete_product_feature_by_pk(feature_id: uuid!, product_id: uuid!): product_feature

  """
  delete data from the table: "product_group"
  """
  delete_product_group(
    """filter the rows which have to be deleted"""
    where: product_group_bool_exp!
  ): product_group_mutation_response

  """
  delete single row from the table: "product_group"
  """
  delete_product_group_by_pk(id: uuid!): product_group

  """
  delete data from the table: "product_group_product"
  """
  delete_product_group_product(
    """filter the rows which have to be deleted"""
    where: product_group_product_bool_exp!
  ): product_group_product_mutation_response

  """
  delete single row from the table: "product_group_product"
  """
  delete_product_group_product_by_pk(group_id: uuid!, product_id: uuid!): product_group_product

  """
  delete data from the table: "product_headline"
  """
  delete_product_headline(
    """filter the rows which have to be deleted"""
    where: product_headline_bool_exp!
  ): product_headline_mutation_response

  """
  delete single row from the table: "product_headline"
  """
  delete_product_headline_by_pk(id: uuid!): product_headline

  """
  delete data from the table: "product_name"
  """
  delete_product_name(
    """filter the rows which have to be deleted"""
    where: product_name_bool_exp!
  ): product_name_mutation_response

  """
  delete single row from the table: "product_name"
  """
  delete_product_name_by_pk(id: uuid!): product_name

  """
  delete data from the table: "product_supplement"
  """
  delete_product_supplement(
    """filter the rows which have to be deleted"""
    where: product_supplement_bool_exp!
  ): product_supplement_mutation_response

  """
  delete single row from the table: "product_supplement"
  """
  delete_product_supplement_by_pk(product_id: uuid!, supplement_id: uuid!): product_supplement

  """
  delete data from the table: "rate"
  """
  delete_rate(
    """filter the rows which have to be deleted"""
    where: rate_bool_exp!
  ): rate_mutation_response

  """
  delete single row from the table: "rate"
  """
  delete_rate_by_pk(id: uuid!): rate

  """
  delete data from the table: "rate_headline"
  """
  delete_rate_headline(
    """filter the rows which have to be deleted"""
    where: rate_headline_bool_exp!
  ): rate_headline_mutation_response

  """
  delete single row from the table: "rate_headline"
  """
  delete_rate_headline_by_pk(id: uuid!): rate_headline

  """
  delete data from the table: "rate_name"
  """
  delete_rate_name(
    """filter the rows which have to be deleted"""
    where: rate_name_bool_exp!
  ): rate_name_mutation_response

  """
  delete single row from the table: "rate_name"
  """
  delete_rate_name_by_pk(id: uuid!): rate_name

  """
  delete data from the table: "rate_price_range"
  """
  delete_rate_price_range(
    """filter the rows which have to be deleted"""
    where: rate_price_range_bool_exp!
  ): rate_price_range_mutation_response

  """
  delete single row from the table: "rate_price_range"
  """
  delete_rate_price_range_by_pk(id: uuid!): rate_price_range

  """
  delete data from the table: "rate_type"
  """
  delete_rate_type(
    """filter the rows which have to be deleted"""
    where: rate_type_bool_exp!
  ): rate_type_mutation_response

  """
  delete single row from the table: "rate_type"
  """
  delete_rate_type_by_pk(id: String!): rate_type

  """
  delete data from the table: "role"
  """
  delete_role(
    """filter the rows which have to be deleted"""
    where: role_bool_exp!
  ): role_mutation_response

  """
  delete single row from the table: "role"
  """
  delete_role_by_pk(id: String!): role

  """
  delete data from the table: "site"
  """
  delete_site(
    """filter the rows which have to be deleted"""
    where: site_bool_exp!
  ): site_mutation_response

  """
  delete single row from the table: "site"
  """
  delete_site_by_pk(id: uuid!): site

  """
  delete data from the table: "slug"
  """
  delete_slug(
    """filter the rows which have to be deleted"""
    where: slug_bool_exp!
  ): slug_mutation_response

  """
  delete single row from the table: "slug"
  """
  delete_slug_by_pk(id: uuid!): slug

  """
  delete data from the table: "supplement"
  """
  delete_supplement(
    """filter the rows which have to be deleted"""
    where: supplement_bool_exp!
  ): supplement_mutation_response

  """
  delete single row from the table: "supplement"
  """
  delete_supplement_by_pk(id: uuid!): supplement

  """
  delete data from the table: "supplement_prices"
  """
  delete_supplement_prices(
    """filter the rows which have to be deleted"""
    where: supplement_prices_bool_exp!
  ): supplement_prices_mutation_response

  """
  delete data from the table: "supplement_type"
  """
  delete_supplement_type(
    """filter the rows which have to be deleted"""
    where: supplement_type_bool_exp!
  ): supplement_type_mutation_response

  """
  delete single row from the table: "supplement_type"
  """
  delete_supplement_type_by_pk(id: String!): supplement_type

  """
  delete data from the table: "translated_text"
  """
  delete_translated_text(
    """filter the rows which have to be deleted"""
    where: translated_text_bool_exp!
  ): translated_text_mutation_response

  """
  delete single row from the table: "translated_text"
  """
  delete_translated_text_by_pk(id: uuid!): translated_text

  """
  delete data from the table: "unit_management"
  """
  delete_unit_management(
    """filter the rows which have to be deleted"""
    where: unit_management_bool_exp!
  ): unit_management_mutation_response

  """
  delete single row from the table: "unit_management"
  """
  delete_unit_management_by_pk(id: String!): unit_management

  """
  delete data from the table: "venue"
  """
  delete_venue(
    """filter the rows which have to be deleted"""
    where: venue_bool_exp!
  ): venue_mutation_response

  """
  delete single row from the table: "venue"
  """
  delete_venue_by_pk(id: uuid!): venue

  """
  delete data from the table: "venue_description"
  """
  delete_venue_description(
    """filter the rows which have to be deleted"""
    where: venue_description_bool_exp!
  ): venue_description_mutation_response

  """
  delete single row from the table: "venue_description"
  """
  delete_venue_description_by_pk(id: uuid!): venue_description

  """
  delete data from the table: "venue_facility"
  """
  delete_venue_facility(
    """filter the rows which have to be deleted"""
    where: venue_facility_bool_exp!
  ): venue_facility_mutation_response

  """
  delete single row from the table: "venue_facility"
  """
  delete_venue_facility_by_pk(id: uuid!): venue_facility

  """
  delete data from the table: "venue_facility_headline"
  """
  delete_venue_facility_headline(
    """filter the rows which have to be deleted"""
    where: venue_facility_headline_bool_exp!
  ): venue_facility_headline_mutation_response

  """
  delete single row from the table: "venue_facility_headline"
  """
  delete_venue_facility_headline_by_pk(id: uuid!): venue_facility_headline

  """
  delete data from the table: "venue_facility_name"
  """
  delete_venue_facility_name(
    """filter the rows which have to be deleted"""
    where: venue_facility_name_bool_exp!
  ): venue_facility_name_mutation_response

  """
  delete single row from the table: "venue_facility_name"
  """
  delete_venue_facility_name_by_pk(id: uuid!): venue_facility_name

  """
  delete data from the table: "venue_good_to_know"
  """
  delete_venue_good_to_know(
    """filter the rows which have to be deleted"""
    where: venue_good_to_know_bool_exp!
  ): venue_good_to_know_mutation_response

  """
  delete single row from the table: "venue_good_to_know"
  """
  delete_venue_good_to_know_by_pk(id: uuid!): venue_good_to_know

  """
  delete data from the table: "venue_usps"
  """
  delete_venue_usps(
    """filter the rows which have to be deleted"""
    where: venue_usps_bool_exp!
  ): venue_usps_mutation_response

  """
  delete single row from the table: "venue_usps"
  """
  delete_venue_usps_by_pk(id: uuid!): venue_usps

  """
  delete data from the table: "venue_usps_line"
  """
  delete_venue_usps_line(
    """filter the rows which have to be deleted"""
    where: venue_usps_line_bool_exp!
  ): venue_usps_line_mutation_response

  """
  delete single row from the table: "venue_usps_line"
  """
  delete_venue_usps_line_by_pk(id: uuid!): venue_usps_line

  """
  insert a single row into the table: "auth.providers"
  """
  insertAuthProvider(
    """the row to be inserted"""
    object: authProviders_insert_input!

    """upsert condition"""
    on_conflict: authProviders_on_conflict
  ): authProviders

  """
  insert a single row into the table: "auth.provider_requests"
  """
  insertAuthProviderRequest(
    """the row to be inserted"""
    object: authProviderRequests_insert_input!

    """upsert condition"""
    on_conflict: authProviderRequests_on_conflict
  ): authProviderRequests

  """
  insert data into the table: "auth.provider_requests"
  """
  insertAuthProviderRequests(
    """the rows to be inserted"""
    objects: [authProviderRequests_insert_input!]!

    """upsert condition"""
    on_conflict: authProviderRequests_on_conflict
  ): authProviderRequests_mutation_response

  """
  insert data into the table: "auth.providers"
  """
  insertAuthProviders(
    """the rows to be inserted"""
    objects: [authProviders_insert_input!]!

    """upsert condition"""
    on_conflict: authProviders_on_conflict
  ): authProviders_mutation_response

  """
  insert a single row into the table: "auth.refresh_tokens"
  """
  insertAuthRefreshToken(
    """the row to be inserted"""
    object: authRefreshTokens_insert_input!

    """upsert condition"""
    on_conflict: authRefreshTokens_on_conflict
  ): authRefreshTokens

  """
  insert a single row into the table: "auth.refresh_token_types"
  """
  insertAuthRefreshTokenType(
    """the row to be inserted"""
    object: authRefreshTokenTypes_insert_input!

    """upsert condition"""
    on_conflict: authRefreshTokenTypes_on_conflict
  ): authRefreshTokenTypes

  """
  insert data into the table: "auth.refresh_token_types"
  """
  insertAuthRefreshTokenTypes(
    """the rows to be inserted"""
    objects: [authRefreshTokenTypes_insert_input!]!

    """upsert condition"""
    on_conflict: authRefreshTokenTypes_on_conflict
  ): authRefreshTokenTypes_mutation_response

  """
  insert data into the table: "auth.refresh_tokens"
  """
  insertAuthRefreshTokens(
    """the rows to be inserted"""
    objects: [authRefreshTokens_insert_input!]!

    """upsert condition"""
    on_conflict: authRefreshTokens_on_conflict
  ): authRefreshTokens_mutation_response

  """
  insert a single row into the table: "auth.roles"
  """
  insertAuthRole(
    """the row to be inserted"""
    object: authRoles_insert_input!

    """upsert condition"""
    on_conflict: authRoles_on_conflict
  ): authRoles

  """
  insert data into the table: "auth.roles"
  """
  insertAuthRoles(
    """the rows to be inserted"""
    objects: [authRoles_insert_input!]!

    """upsert condition"""
    on_conflict: authRoles_on_conflict
  ): authRoles_mutation_response

  """
  insert a single row into the table: "auth.user_providers"
  """
  insertAuthUserProvider(
    """the row to be inserted"""
    object: authUserProviders_insert_input!

    """upsert condition"""
    on_conflict: authUserProviders_on_conflict
  ): authUserProviders

  """
  insert data into the table: "auth.user_providers"
  """
  insertAuthUserProviders(
    """the rows to be inserted"""
    objects: [authUserProviders_insert_input!]!

    """upsert condition"""
    on_conflict: authUserProviders_on_conflict
  ): authUserProviders_mutation_response

  """
  insert a single row into the table: "auth.user_roles"
  """
  insertAuthUserRole(
    """the row to be inserted"""
    object: authUserRoles_insert_input!

    """upsert condition"""
    on_conflict: authUserRoles_on_conflict
  ): authUserRoles

  """
  insert data into the table: "auth.user_roles"
  """
  insertAuthUserRoles(
    """the rows to be inserted"""
    objects: [authUserRoles_insert_input!]!

    """upsert condition"""
    on_conflict: authUserRoles_on_conflict
  ): authUserRoles_mutation_response

  """
  insert a single row into the table: "auth.user_security_keys"
  """
  insertAuthUserSecurityKey(
    """the row to be inserted"""
    object: authUserSecurityKeys_insert_input!

    """upsert condition"""
    on_conflict: authUserSecurityKeys_on_conflict
  ): authUserSecurityKeys

  """
  insert data into the table: "auth.user_security_keys"
  """
  insertAuthUserSecurityKeys(
    """the rows to be inserted"""
    objects: [authUserSecurityKeys_insert_input!]!

    """upsert condition"""
    on_conflict: authUserSecurityKeys_on_conflict
  ): authUserSecurityKeys_mutation_response

  """
  insert a single row into the table: "storage.buckets"
  """
  insertBucket(
    """the row to be inserted"""
    object: buckets_insert_input!

    """upsert condition"""
    on_conflict: buckets_on_conflict
  ): buckets

  """
  insert data into the table: "storage.buckets"
  """
  insertBuckets(
    """the rows to be inserted"""
    objects: [buckets_insert_input!]!

    """upsert condition"""
    on_conflict: buckets_on_conflict
  ): buckets_mutation_response

  """
  insert a single row into the table: "storage.files"
  """
  insertFile(
    """the row to be inserted"""
    object: files_insert_input!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files

  """
  insert data into the table: "storage.files"
  """
  insertFiles(
    """the rows to be inserted"""
    objects: [files_insert_input!]!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files_mutation_response

  """
  insert a single row into the table: "auth.users"
  """
  insertUser(
    """the row to be inserted"""
    object: users_insert_input!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "auth.users"
  """
  insertUsers(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "storage.virus"
  """
  insertVirus(
    """the row to be inserted"""
    object: virus_insert_input!

    """upsert condition"""
    on_conflict: virus_on_conflict
  ): virus

  """
  insert data into the table: "storage.virus"
  """
  insertViruses(
    """the rows to be inserted"""
    objects: [virus_insert_input!]!

    """upsert condition"""
    on_conflict: virus_on_conflict
  ): virus_mutation_response

  """
  insert data into the table: "booking"
  """
  insert_booking(
    """the rows to be inserted"""
    objects: [booking_insert_input!]!

    """upsert condition"""
    on_conflict: booking_on_conflict
  ): booking_mutation_response

  """
  insert data into the table: "booking_events.event_type"
  """
  insert_booking_events_event_type(
    """the rows to be inserted"""
    objects: [booking_events_event_type_insert_input!]!

    """upsert condition"""
    on_conflict: booking_events_event_type_on_conflict
  ): booking_events_event_type_mutation_response

  """
  insert a single row into the table: "booking_events.event_type"
  """
  insert_booking_events_event_type_one(
    """the row to be inserted"""
    object: booking_events_event_type_insert_input!

    """upsert condition"""
    on_conflict: booking_events_event_type_on_conflict
  ): booking_events_event_type

  """
  insert data into the table: "booking_events.main"
  """
  insert_booking_events_main(
    """the rows to be inserted"""
    objects: [booking_events_main_insert_input!]!

    """upsert condition"""
    on_conflict: booking_events_main_on_conflict
  ): booking_events_main_mutation_response

  """
  insert a single row into the table: "booking_events.main"
  """
  insert_booking_events_main_one(
    """the row to be inserted"""
    object: booking_events_main_insert_input!

    """upsert condition"""
    on_conflict: booking_events_main_on_conflict
  ): booking_events_main

  """
  insert data into the table: "booking_events.version"
  """
  insert_booking_events_version(
    """the rows to be inserted"""
    objects: [booking_events_version_insert_input!]!

    """upsert condition"""
    on_conflict: booking_events_version_on_conflict
  ): booking_events_version_mutation_response

  """
  insert a single row into the table: "booking_events.version"
  """
  insert_booking_events_version_one(
    """the row to be inserted"""
    object: booking_events_version_insert_input!

    """upsert condition"""
    on_conflict: booking_events_version_on_conflict
  ): booking_events_version

  """
  insert data into the table: "booking_history_entry"
  """
  insert_booking_history_entry(
    """the rows to be inserted"""
    objects: [booking_history_entry_insert_input!]!

    """upsert condition"""
    on_conflict: booking_history_entry_on_conflict
  ): booking_history_entry_mutation_response

  """
  insert a single row into the table: "booking_history_entry"
  """
  insert_booking_history_entry_one(
    """the row to be inserted"""
    object: booking_history_entry_insert_input!

    """upsert condition"""
    on_conflict: booking_history_entry_on_conflict
  ): booking_history_entry

  """
  insert a single row into the table: "booking"
  """
  insert_booking_one(
    """the row to be inserted"""
    object: booking_insert_input!

    """upsert condition"""
    on_conflict: booking_on_conflict
  ): booking

  """
  insert data into the table: "booking_product"
  """
  insert_booking_product(
    """the rows to be inserted"""
    objects: [booking_product_insert_input!]!

    """upsert condition"""
    on_conflict: booking_product_on_conflict
  ): booking_product_mutation_response

  """
  insert a single row into the table: "booking_product"
  """
  insert_booking_product_one(
    """the row to be inserted"""
    object: booking_product_insert_input!

    """upsert condition"""
    on_conflict: booking_product_on_conflict
  ): booking_product

  """
  insert data into the table: "booking_question_scope"
  """
  insert_booking_question_scope(
    """the rows to be inserted"""
    objects: [booking_question_scope_insert_input!]!

    """upsert condition"""
    on_conflict: booking_question_scope_on_conflict
  ): booking_question_scope_mutation_response

  """
  insert a single row into the table: "booking_question_scope"
  """
  insert_booking_question_scope_one(
    """the row to be inserted"""
    object: booking_question_scope_insert_input!

    """upsert condition"""
    on_conflict: booking_question_scope_on_conflict
  ): booking_question_scope

  """
  insert data into the table: "booking_question_type"
  """
  insert_booking_question_type(
    """the rows to be inserted"""
    objects: [booking_question_type_insert_input!]!

    """upsert condition"""
    on_conflict: booking_question_type_on_conflict
  ): booking_question_type_mutation_response

  """
  insert a single row into the table: "booking_question_type"
  """
  insert_booking_question_type_one(
    """the row to be inserted"""
    object: booking_question_type_insert_input!

    """upsert condition"""
    on_conflict: booking_question_type_on_conflict
  ): booking_question_type

  """
  insert data into the table: "booking_state"
  """
  insert_booking_state(
    """the rows to be inserted"""
    objects: [booking_state_insert_input!]!

    """upsert condition"""
    on_conflict: booking_state_on_conflict
  ): booking_state_mutation_response

  """
  insert a single row into the table: "booking_state"
  """
  insert_booking_state_one(
    """the row to be inserted"""
    object: booking_state_insert_input!

    """upsert condition"""
    on_conflict: booking_state_on_conflict
  ): booking_state

  """
  insert data into the table: "category"
  """
  insert_category(
    """the rows to be inserted"""
    objects: [category_insert_input!]!

    """upsert condition"""
    on_conflict: category_on_conflict
  ): category_mutation_response

  """
  insert a single row into the table: "category"
  """
  insert_category_one(
    """the row to be inserted"""
    object: category_insert_input!

    """upsert condition"""
    on_conflict: category_on_conflict
  ): category

  """
  insert data into the table: "contact"
  """
  insert_contact(
    """the rows to be inserted"""
    objects: [contact_insert_input!]!

    """upsert condition"""
    on_conflict: contact_on_conflict
  ): contact_mutation_response

  """
  insert a single row into the table: "contact"
  """
  insert_contact_one(
    """the row to be inserted"""
    object: contact_insert_input!

    """upsert condition"""
    on_conflict: contact_on_conflict
  ): contact

  """
  insert data into the table: "feature"
  """
  insert_feature(
    """the rows to be inserted"""
    objects: [feature_insert_input!]!

    """upsert condition"""
    on_conflict: feature_on_conflict
  ): feature_mutation_response

  """
  insert data into the table: "feature_category"
  """
  insert_feature_category(
    """the rows to be inserted"""
    objects: [feature_category_insert_input!]!

    """upsert condition"""
    on_conflict: feature_category_on_conflict
  ): feature_category_mutation_response

  """
  insert a single row into the table: "feature_category"
  """
  insert_feature_category_one(
    """the row to be inserted"""
    object: feature_category_insert_input!

    """upsert condition"""
    on_conflict: feature_category_on_conflict
  ): feature_category

  """
  insert a single row into the table: "feature"
  """
  insert_feature_one(
    """the row to be inserted"""
    object: feature_insert_input!

    """upsert condition"""
    on_conflict: feature_on_conflict
  ): feature

  """
  insert data into the table: "feature_symbol"
  """
  insert_feature_symbol(
    """the rows to be inserted"""
    objects: [feature_symbol_insert_input!]!

    """upsert condition"""
    on_conflict: feature_symbol_on_conflict
  ): feature_symbol_mutation_response

  """
  insert a single row into the table: "feature_symbol"
  """
  insert_feature_symbol_one(
    """the row to be inserted"""
    object: feature_symbol_insert_input!

    """upsert condition"""
    on_conflict: feature_symbol_on_conflict
  ): feature_symbol

  """
  insert data into the table: "feature_type"
  """
  insert_feature_type(
    """the rows to be inserted"""
    objects: [feature_type_insert_input!]!

    """upsert condition"""
    on_conflict: feature_type_on_conflict
  ): feature_type_mutation_response

  """
  insert a single row into the table: "feature_type"
  """
  insert_feature_type_one(
    """the row to be inserted"""
    object: feature_type_insert_input!

    """upsert condition"""
    on_conflict: feature_type_on_conflict
  ): feature_type

  """
  insert data into the table: "media_gallery"
  """
  insert_media_gallery(
    """the rows to be inserted"""
    objects: [media_gallery_insert_input!]!

    """upsert condition"""
    on_conflict: media_gallery_on_conflict
  ): media_gallery_mutation_response

  """
  insert data into the table: "media_gallery_item"
  """
  insert_media_gallery_item(
    """the rows to be inserted"""
    objects: [media_gallery_item_insert_input!]!

    """upsert condition"""
    on_conflict: media_gallery_item_on_conflict
  ): media_gallery_item_mutation_response

  """
  insert a single row into the table: "media_gallery_item"
  """
  insert_media_gallery_item_one(
    """the row to be inserted"""
    object: media_gallery_item_insert_input!

    """upsert condition"""
    on_conflict: media_gallery_item_on_conflict
  ): media_gallery_item

  """
  insert a single row into the table: "media_gallery"
  """
  insert_media_gallery_one(
    """the row to be inserted"""
    object: media_gallery_insert_input!

    """upsert condition"""
    on_conflict: media_gallery_on_conflict
  ): media_gallery

  """
  insert data into the table: "my_web_section"
  """
  insert_my_web_section(
    """the rows to be inserted"""
    objects: [my_web_section_insert_input!]!

    """upsert condition"""
    on_conflict: my_web_section_on_conflict
  ): my_web_section_mutation_response

  """
  insert a single row into the table: "my_web_section"
  """
  insert_my_web_section_one(
    """the row to be inserted"""
    object: my_web_section_insert_input!

    """upsert condition"""
    on_conflict: my_web_section_on_conflict
  ): my_web_section

  """
  insert data into the table: "organization"
  """
  insert_organization(
    """the rows to be inserted"""
    objects: [organization_insert_input!]!

    """upsert condition"""
    on_conflict: organization_on_conflict
  ): organization_mutation_response

  """
  insert data into the table: "organization_booking_question"
  """
  insert_organization_booking_question(
    """the rows to be inserted"""
    objects: [organization_booking_question_insert_input!]!

    """upsert condition"""
    on_conflict: organization_booking_question_on_conflict
  ): organization_booking_question_mutation_response

  """
  insert a single row into the table: "organization_booking_question"
  """
  insert_organization_booking_question_one(
    """the row to be inserted"""
    object: organization_booking_question_insert_input!

    """upsert condition"""
    on_conflict: organization_booking_question_on_conflict
  ): organization_booking_question

  """
  insert data into the table: "organization_branding"
  """
  insert_organization_branding(
    """the rows to be inserted"""
    objects: [organization_branding_insert_input!]!

    """upsert condition"""
    on_conflict: organization_branding_on_conflict
  ): organization_branding_mutation_response

  """
  insert data into the table: "organization_branding_meta_description"
  """
  insert_organization_branding_meta_description(
    """the rows to be inserted"""
    objects: [organization_branding_meta_description_insert_input!]!

    """upsert condition"""
    on_conflict: organization_branding_meta_description_on_conflict
  ): organization_branding_meta_description_mutation_response

  """
  insert a single row into the table: "organization_branding_meta_description"
  """
  insert_organization_branding_meta_description_one(
    """the row to be inserted"""
    object: organization_branding_meta_description_insert_input!

    """upsert condition"""
    on_conflict: organization_branding_meta_description_on_conflict
  ): organization_branding_meta_description

  """
  insert data into the table: "organization_branding_meta_title"
  """
  insert_organization_branding_meta_title(
    """the rows to be inserted"""
    objects: [organization_branding_meta_title_insert_input!]!

    """upsert condition"""
    on_conflict: organization_branding_meta_title_on_conflict
  ): organization_branding_meta_title_mutation_response

  """
  insert a single row into the table: "organization_branding_meta_title"
  """
  insert_organization_branding_meta_title_one(
    """the row to be inserted"""
    object: organization_branding_meta_title_insert_input!

    """upsert condition"""
    on_conflict: organization_branding_meta_title_on_conflict
  ): organization_branding_meta_title

  """
  insert a single row into the table: "organization_branding"
  """
  insert_organization_branding_one(
    """the row to be inserted"""
    object: organization_branding_insert_input!

    """upsert condition"""
    on_conflict: organization_branding_on_conflict
  ): organization_branding

  """
  insert data into the table: "organization_business_model"
  """
  insert_organization_business_model(
    """the rows to be inserted"""
    objects: [organization_business_model_insert_input!]!

    """upsert condition"""
    on_conflict: organization_business_model_on_conflict
  ): organization_business_model_mutation_response

  """
  insert a single row into the table: "organization_business_model"
  """
  insert_organization_business_model_one(
    """the row to be inserted"""
    object: organization_business_model_insert_input!

    """upsert condition"""
    on_conflict: organization_business_model_on_conflict
  ): organization_business_model

  """
  insert data into the table: "organization_headline"
  """
  insert_organization_headline(
    """the rows to be inserted"""
    objects: [organization_headline_insert_input!]!

    """upsert condition"""
    on_conflict: organization_headline_on_conflict
  ): organization_headline_mutation_response

  """
  insert a single row into the table: "organization_headline"
  """
  insert_organization_headline_one(
    """the row to be inserted"""
    object: organization_headline_insert_input!

    """upsert condition"""
    on_conflict: organization_headline_on_conflict
  ): organization_headline

  """
  insert data into the table: "organization_member"
  """
  insert_organization_member(
    """the rows to be inserted"""
    objects: [organization_member_insert_input!]!

    """upsert condition"""
    on_conflict: organization_member_on_conflict
  ): organization_member_mutation_response

  """
  insert a single row into the table: "organization_member"
  """
  insert_organization_member_one(
    """the row to be inserted"""
    object: organization_member_insert_input!

    """upsert condition"""
    on_conflict: organization_member_on_conflict
  ): organization_member

  """
  insert a single row into the table: "organization"
  """
  insert_organization_one(
    """the row to be inserted"""
    object: organization_insert_input!

    """upsert condition"""
    on_conflict: organization_on_conflict
  ): organization

  """
  insert data into the table: "organization_socials"
  """
  insert_organization_socials(
    """the rows to be inserted"""
    objects: [organization_socials_insert_input!]!

    """upsert condition"""
    on_conflict: organization_socials_on_conflict
  ): organization_socials_mutation_response

  """
  insert a single row into the table: "organization_socials"
  """
  insert_organization_socials_one(
    """the row to be inserted"""
    object: organization_socials_insert_input!

    """upsert condition"""
    on_conflict: organization_socials_on_conflict
  ): organization_socials

  """
  insert data into the table: "place"
  """
  insert_place(
    """the rows to be inserted"""
    objects: [place_insert_input!]!

    """upsert condition"""
    on_conflict: place_on_conflict
  ): place_mutation_response

  """
  insert a single row into the table: "place"
  """
  insert_place_one(
    """the row to be inserted"""
    object: place_insert_input!

    """upsert condition"""
    on_conflict: place_on_conflict
  ): place

  """
  insert data into the table: "product"
  """
  insert_product(
    """the rows to be inserted"""
    objects: [product_insert_input!]!

    """upsert condition"""
    on_conflict: product_on_conflict
  ): product_mutation_response

  """
  insert data into the table: "product_allotment_range"
  """
  insert_product_allotment_range(
    """the rows to be inserted"""
    objects: [product_allotment_range_insert_input!]!

    """upsert condition"""
    on_conflict: product_allotment_range_on_conflict
  ): product_allotment_range_mutation_response

  """
  insert a single row into the table: "product_allotment_range"
  """
  insert_product_allotment_range_one(
    """the row to be inserted"""
    object: product_allotment_range_insert_input!

    """upsert condition"""
    on_conflict: product_allotment_range_on_conflict
  ): product_allotment_range

  """
  insert data into the table: "product_business_model"
  """
  insert_product_business_model(
    """the rows to be inserted"""
    objects: [product_business_model_insert_input!]!

    """upsert condition"""
    on_conflict: product_business_model_on_conflict
  ): product_business_model_mutation_response

  """
  insert a single row into the table: "product_business_model"
  """
  insert_product_business_model_one(
    """the row to be inserted"""
    object: product_business_model_insert_input!

    """upsert condition"""
    on_conflict: product_business_model_on_conflict
  ): product_business_model

  """
  insert data into the table: "product_description"
  """
  insert_product_description(
    """the rows to be inserted"""
    objects: [product_description_insert_input!]!

    """upsert condition"""
    on_conflict: product_description_on_conflict
  ): product_description_mutation_response

  """
  insert a single row into the table: "product_description"
  """
  insert_product_description_one(
    """the row to be inserted"""
    object: product_description_insert_input!

    """upsert condition"""
    on_conflict: product_description_on_conflict
  ): product_description

  """
  insert data into the table: "product_feature"
  """
  insert_product_feature(
    """the rows to be inserted"""
    objects: [product_feature_insert_input!]!

    """upsert condition"""
    on_conflict: product_feature_on_conflict
  ): product_feature_mutation_response

  """
  insert a single row into the table: "product_feature"
  """
  insert_product_feature_one(
    """the row to be inserted"""
    object: product_feature_insert_input!

    """upsert condition"""
    on_conflict: product_feature_on_conflict
  ): product_feature

  """
  insert data into the table: "product_group"
  """
  insert_product_group(
    """the rows to be inserted"""
    objects: [product_group_insert_input!]!

    """upsert condition"""
    on_conflict: product_group_on_conflict
  ): product_group_mutation_response

  """
  insert a single row into the table: "product_group"
  """
  insert_product_group_one(
    """the row to be inserted"""
    object: product_group_insert_input!

    """upsert condition"""
    on_conflict: product_group_on_conflict
  ): product_group

  """
  insert data into the table: "product_group_product"
  """
  insert_product_group_product(
    """the rows to be inserted"""
    objects: [product_group_product_insert_input!]!

    """upsert condition"""
    on_conflict: product_group_product_on_conflict
  ): product_group_product_mutation_response

  """
  insert a single row into the table: "product_group_product"
  """
  insert_product_group_product_one(
    """the row to be inserted"""
    object: product_group_product_insert_input!

    """upsert condition"""
    on_conflict: product_group_product_on_conflict
  ): product_group_product

  """
  insert data into the table: "product_headline"
  """
  insert_product_headline(
    """the rows to be inserted"""
    objects: [product_headline_insert_input!]!

    """upsert condition"""
    on_conflict: product_headline_on_conflict
  ): product_headline_mutation_response

  """
  insert a single row into the table: "product_headline"
  """
  insert_product_headline_one(
    """the row to be inserted"""
    object: product_headline_insert_input!

    """upsert condition"""
    on_conflict: product_headline_on_conflict
  ): product_headline

  """
  insert data into the table: "product_name"
  """
  insert_product_name(
    """the rows to be inserted"""
    objects: [product_name_insert_input!]!

    """upsert condition"""
    on_conflict: product_name_on_conflict
  ): product_name_mutation_response

  """
  insert a single row into the table: "product_name"
  """
  insert_product_name_one(
    """the row to be inserted"""
    object: product_name_insert_input!

    """upsert condition"""
    on_conflict: product_name_on_conflict
  ): product_name

  """
  insert a single row into the table: "product"
  """
  insert_product_one(
    """the row to be inserted"""
    object: product_insert_input!

    """upsert condition"""
    on_conflict: product_on_conflict
  ): product

  """
  insert data into the table: "product_supplement"
  """
  insert_product_supplement(
    """the rows to be inserted"""
    objects: [product_supplement_insert_input!]!

    """upsert condition"""
    on_conflict: product_supplement_on_conflict
  ): product_supplement_mutation_response

  """
  insert a single row into the table: "product_supplement"
  """
  insert_product_supplement_one(
    """the row to be inserted"""
    object: product_supplement_insert_input!

    """upsert condition"""
    on_conflict: product_supplement_on_conflict
  ): product_supplement

  """
  insert data into the table: "rate"
  """
  insert_rate(
    """the rows to be inserted"""
    objects: [rate_insert_input!]!

    """upsert condition"""
    on_conflict: rate_on_conflict
  ): rate_mutation_response

  """
  insert data into the table: "rate_headline"
  """
  insert_rate_headline(
    """the rows to be inserted"""
    objects: [rate_headline_insert_input!]!

    """upsert condition"""
    on_conflict: rate_headline_on_conflict
  ): rate_headline_mutation_response

  """
  insert a single row into the table: "rate_headline"
  """
  insert_rate_headline_one(
    """the row to be inserted"""
    object: rate_headline_insert_input!

    """upsert condition"""
    on_conflict: rate_headline_on_conflict
  ): rate_headline

  """
  insert data into the table: "rate_name"
  """
  insert_rate_name(
    """the rows to be inserted"""
    objects: [rate_name_insert_input!]!

    """upsert condition"""
    on_conflict: rate_name_on_conflict
  ): rate_name_mutation_response

  """
  insert a single row into the table: "rate_name"
  """
  insert_rate_name_one(
    """the row to be inserted"""
    object: rate_name_insert_input!

    """upsert condition"""
    on_conflict: rate_name_on_conflict
  ): rate_name

  """
  insert a single row into the table: "rate"
  """
  insert_rate_one(
    """the row to be inserted"""
    object: rate_insert_input!

    """upsert condition"""
    on_conflict: rate_on_conflict
  ): rate

  """
  insert data into the table: "rate_price_range"
  """
  insert_rate_price_range(
    """the rows to be inserted"""
    objects: [rate_price_range_insert_input!]!

    """upsert condition"""
    on_conflict: rate_price_range_on_conflict
  ): rate_price_range_mutation_response

  """
  insert a single row into the table: "rate_price_range"
  """
  insert_rate_price_range_one(
    """the row to be inserted"""
    object: rate_price_range_insert_input!

    """upsert condition"""
    on_conflict: rate_price_range_on_conflict
  ): rate_price_range

  """
  insert data into the table: "rate_type"
  """
  insert_rate_type(
    """the rows to be inserted"""
    objects: [rate_type_insert_input!]!

    """upsert condition"""
    on_conflict: rate_type_on_conflict
  ): rate_type_mutation_response

  """
  insert a single row into the table: "rate_type"
  """
  insert_rate_type_one(
    """the row to be inserted"""
    object: rate_type_insert_input!

    """upsert condition"""
    on_conflict: rate_type_on_conflict
  ): rate_type

  """
  insert data into the table: "role"
  """
  insert_role(
    """the rows to be inserted"""
    objects: [role_insert_input!]!

    """upsert condition"""
    on_conflict: role_on_conflict
  ): role_mutation_response

  """
  insert a single row into the table: "role"
  """
  insert_role_one(
    """the row to be inserted"""
    object: role_insert_input!

    """upsert condition"""
    on_conflict: role_on_conflict
  ): role

  """
  insert data into the table: "site"
  """
  insert_site(
    """the rows to be inserted"""
    objects: [site_insert_input!]!

    """upsert condition"""
    on_conflict: site_on_conflict
  ): site_mutation_response

  """
  insert a single row into the table: "site"
  """
  insert_site_one(
    """the row to be inserted"""
    object: site_insert_input!

    """upsert condition"""
    on_conflict: site_on_conflict
  ): site

  """
  insert data into the table: "slug"
  """
  insert_slug(
    """the rows to be inserted"""
    objects: [slug_insert_input!]!

    """upsert condition"""
    on_conflict: slug_on_conflict
  ): slug_mutation_response

  """
  insert a single row into the table: "slug"
  """
  insert_slug_one(
    """the row to be inserted"""
    object: slug_insert_input!

    """upsert condition"""
    on_conflict: slug_on_conflict
  ): slug

  """
  insert data into the table: "supplement"
  """
  insert_supplement(
    """the rows to be inserted"""
    objects: [supplement_insert_input!]!

    """upsert condition"""
    on_conflict: supplement_on_conflict
  ): supplement_mutation_response

  """
  insert a single row into the table: "supplement"
  """
  insert_supplement_one(
    """the row to be inserted"""
    object: supplement_insert_input!

    """upsert condition"""
    on_conflict: supplement_on_conflict
  ): supplement

  """
  insert data into the table: "supplement_prices"
  """
  insert_supplement_prices(
    """the rows to be inserted"""
    objects: [supplement_prices_insert_input!]!
  ): supplement_prices_mutation_response

  """
  insert a single row into the table: "supplement_prices"
  """
  insert_supplement_prices_one(
    """the row to be inserted"""
    object: supplement_prices_insert_input!
  ): supplement_prices

  """
  insert data into the table: "supplement_type"
  """
  insert_supplement_type(
    """the rows to be inserted"""
    objects: [supplement_type_insert_input!]!

    """upsert condition"""
    on_conflict: supplement_type_on_conflict
  ): supplement_type_mutation_response

  """
  insert a single row into the table: "supplement_type"
  """
  insert_supplement_type_one(
    """the row to be inserted"""
    object: supplement_type_insert_input!

    """upsert condition"""
    on_conflict: supplement_type_on_conflict
  ): supplement_type

  """
  insert data into the table: "translated_text"
  """
  insert_translated_text(
    """the rows to be inserted"""
    objects: [translated_text_insert_input!]!

    """upsert condition"""
    on_conflict: translated_text_on_conflict
  ): translated_text_mutation_response

  """
  insert a single row into the table: "translated_text"
  """
  insert_translated_text_one(
    """the row to be inserted"""
    object: translated_text_insert_input!

    """upsert condition"""
    on_conflict: translated_text_on_conflict
  ): translated_text

  """
  insert data into the table: "unit_management"
  """
  insert_unit_management(
    """the rows to be inserted"""
    objects: [unit_management_insert_input!]!

    """upsert condition"""
    on_conflict: unit_management_on_conflict
  ): unit_management_mutation_response

  """
  insert a single row into the table: "unit_management"
  """
  insert_unit_management_one(
    """the row to be inserted"""
    object: unit_management_insert_input!

    """upsert condition"""
    on_conflict: unit_management_on_conflict
  ): unit_management

  """
  insert data into the table: "venue"
  """
  insert_venue(
    """the rows to be inserted"""
    objects: [venue_insert_input!]!

    """upsert condition"""
    on_conflict: venue_on_conflict
  ): venue_mutation_response

  """
  insert data into the table: "venue_description"
  """
  insert_venue_description(
    """the rows to be inserted"""
    objects: [venue_description_insert_input!]!

    """upsert condition"""
    on_conflict: venue_description_on_conflict
  ): venue_description_mutation_response

  """
  insert a single row into the table: "venue_description"
  """
  insert_venue_description_one(
    """the row to be inserted"""
    object: venue_description_insert_input!

    """upsert condition"""
    on_conflict: venue_description_on_conflict
  ): venue_description

  """
  insert data into the table: "venue_facility"
  """
  insert_venue_facility(
    """the rows to be inserted"""
    objects: [venue_facility_insert_input!]!

    """upsert condition"""
    on_conflict: venue_facility_on_conflict
  ): venue_facility_mutation_response

  """
  insert data into the table: "venue_facility_headline"
  """
  insert_venue_facility_headline(
    """the rows to be inserted"""
    objects: [venue_facility_headline_insert_input!]!

    """upsert condition"""
    on_conflict: venue_facility_headline_on_conflict
  ): venue_facility_headline_mutation_response

  """
  insert a single row into the table: "venue_facility_headline"
  """
  insert_venue_facility_headline_one(
    """the row to be inserted"""
    object: venue_facility_headline_insert_input!

    """upsert condition"""
    on_conflict: venue_facility_headline_on_conflict
  ): venue_facility_headline

  """
  insert data into the table: "venue_facility_name"
  """
  insert_venue_facility_name(
    """the rows to be inserted"""
    objects: [venue_facility_name_insert_input!]!

    """upsert condition"""
    on_conflict: venue_facility_name_on_conflict
  ): venue_facility_name_mutation_response

  """
  insert a single row into the table: "venue_facility_name"
  """
  insert_venue_facility_name_one(
    """the row to be inserted"""
    object: venue_facility_name_insert_input!

    """upsert condition"""
    on_conflict: venue_facility_name_on_conflict
  ): venue_facility_name

  """
  insert a single row into the table: "venue_facility"
  """
  insert_venue_facility_one(
    """the row to be inserted"""
    object: venue_facility_insert_input!

    """upsert condition"""
    on_conflict: venue_facility_on_conflict
  ): venue_facility

  """
  insert data into the table: "venue_good_to_know"
  """
  insert_venue_good_to_know(
    """the rows to be inserted"""
    objects: [venue_good_to_know_insert_input!]!

    """upsert condition"""
    on_conflict: venue_good_to_know_on_conflict
  ): venue_good_to_know_mutation_response

  """
  insert a single row into the table: "venue_good_to_know"
  """
  insert_venue_good_to_know_one(
    """the row to be inserted"""
    object: venue_good_to_know_insert_input!

    """upsert condition"""
    on_conflict: venue_good_to_know_on_conflict
  ): venue_good_to_know

  """
  insert a single row into the table: "venue"
  """
  insert_venue_one(
    """the row to be inserted"""
    object: venue_insert_input!

    """upsert condition"""
    on_conflict: venue_on_conflict
  ): venue

  """
  insert data into the table: "venue_usps"
  """
  insert_venue_usps(
    """the rows to be inserted"""
    objects: [venue_usps_insert_input!]!

    """upsert condition"""
    on_conflict: venue_usps_on_conflict
  ): venue_usps_mutation_response

  """
  insert data into the table: "venue_usps_line"
  """
  insert_venue_usps_line(
    """the rows to be inserted"""
    objects: [venue_usps_line_insert_input!]!

    """upsert condition"""
    on_conflict: venue_usps_line_on_conflict
  ): venue_usps_line_mutation_response

  """
  insert a single row into the table: "venue_usps_line"
  """
  insert_venue_usps_line_one(
    """the row to be inserted"""
    object: venue_usps_line_insert_input!

    """upsert condition"""
    on_conflict: venue_usps_line_on_conflict
  ): venue_usps_line

  """
  insert a single row into the table: "venue_usps"
  """
  insert_venue_usps_one(
    """the row to be inserted"""
    object: venue_usps_insert_input!

    """upsert condition"""
    on_conflict: venue_usps_on_conflict
  ): venue_usps
  my_web_section_save(arg: my_web_section_save_input!): json!
  organization_booking_questions_save(arg: organization_booking_questions_save_input!): json!
  organization_branding_save(arg: organization_branding_save_input!): json!
  organization_create(arg: organization_create_input!): json!
  organization_settings_save(arg: organization_settings_save_input!): json!
  product_group_save(arg: product_group_save_input!): json!

  """product_save"""
  product_save(arg: product_save_input!): json!
  rate_save(arg: rate_save_input!): json!
  save_product_features(arg: save_product_features_input!): json!
  supplement_create(arg: supplement_create_input!): json!
  supplement_save(arg: supplement_save_input!): json!
  test(arg: json!): json!
  test_error(arg: json!): json!

  """
  update single row of the table: "auth.providers"
  """
  updateAuthProvider(
    """sets the columns of the filtered rows to the given values"""
    _set: authProviders_set_input
    pk_columns: authProviders_pk_columns_input!
  ): authProviders

  """
  update single row of the table: "auth.provider_requests"
  """
  updateAuthProviderRequest(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authProviderRequests_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authProviderRequests_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: authProviderRequests_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authProviderRequests_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authProviderRequests_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authProviderRequests_set_input
    pk_columns: authProviderRequests_pk_columns_input!
  ): authProviderRequests

  """
  update data of the table: "auth.provider_requests"
  """
  updateAuthProviderRequests(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authProviderRequests_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authProviderRequests_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: authProviderRequests_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authProviderRequests_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authProviderRequests_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authProviderRequests_set_input

    """filter the rows which have to be updated"""
    where: authProviderRequests_bool_exp!
  ): authProviderRequests_mutation_response

  """
  update data of the table: "auth.providers"
  """
  updateAuthProviders(
    """sets the columns of the filtered rows to the given values"""
    _set: authProviders_set_input

    """filter the rows which have to be updated"""
    where: authProviders_bool_exp!
  ): authProviders_mutation_response

  """
  update single row of the table: "auth.refresh_tokens"
  """
  updateAuthRefreshToken(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authRefreshTokens_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authRefreshTokens_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: authRefreshTokens_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authRefreshTokens_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authRefreshTokens_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokens_set_input
    pk_columns: authRefreshTokens_pk_columns_input!
  ): authRefreshTokens

  """
  update single row of the table: "auth.refresh_token_types"
  """
  updateAuthRefreshTokenType(
    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokenTypes_set_input
    pk_columns: authRefreshTokenTypes_pk_columns_input!
  ): authRefreshTokenTypes

  """
  update data of the table: "auth.refresh_token_types"
  """
  updateAuthRefreshTokenTypes(
    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokenTypes_set_input

    """filter the rows which have to be updated"""
    where: authRefreshTokenTypes_bool_exp!
  ): authRefreshTokenTypes_mutation_response

  """
  update data of the table: "auth.refresh_tokens"
  """
  updateAuthRefreshTokens(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authRefreshTokens_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authRefreshTokens_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: authRefreshTokens_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authRefreshTokens_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authRefreshTokens_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokens_set_input

    """filter the rows which have to be updated"""
    where: authRefreshTokens_bool_exp!
  ): authRefreshTokens_mutation_response

  """
  update single row of the table: "auth.roles"
  """
  updateAuthRole(
    """sets the columns of the filtered rows to the given values"""
    _set: authRoles_set_input
    pk_columns: authRoles_pk_columns_input!
  ): authRoles

  """
  update data of the table: "auth.roles"
  """
  updateAuthRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: authRoles_set_input

    """filter the rows which have to be updated"""
    where: authRoles_bool_exp!
  ): authRoles_mutation_response

  """
  update single row of the table: "auth.user_providers"
  """
  updateAuthUserProvider(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserProviders_set_input
    pk_columns: authUserProviders_pk_columns_input!
  ): authUserProviders

  """
  update data of the table: "auth.user_providers"
  """
  updateAuthUserProviders(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserProviders_set_input

    """filter the rows which have to be updated"""
    where: authUserProviders_bool_exp!
  ): authUserProviders_mutation_response

  """
  update single row of the table: "auth.user_roles"
  """
  updateAuthUserRole(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserRoles_set_input
    pk_columns: authUserRoles_pk_columns_input!
  ): authUserRoles

  """
  update data of the table: "auth.user_roles"
  """
  updateAuthUserRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserRoles_set_input

    """filter the rows which have to be updated"""
    where: authUserRoles_bool_exp!
  ): authUserRoles_mutation_response

  """
  update single row of the table: "auth.user_security_keys"
  """
  updateAuthUserSecurityKey(
    """increments the numeric columns with given value of the filtered values"""
    _inc: authUserSecurityKeys_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: authUserSecurityKeys_set_input
    pk_columns: authUserSecurityKeys_pk_columns_input!
  ): authUserSecurityKeys

  """
  update data of the table: "auth.user_security_keys"
  """
  updateAuthUserSecurityKeys(
    """increments the numeric columns with given value of the filtered values"""
    _inc: authUserSecurityKeys_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: authUserSecurityKeys_set_input

    """filter the rows which have to be updated"""
    where: authUserSecurityKeys_bool_exp!
  ): authUserSecurityKeys_mutation_response

  """
  update single row of the table: "storage.buckets"
  """
  updateBucket(
    """increments the numeric columns with given value of the filtered values"""
    _inc: buckets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: buckets_set_input
    pk_columns: buckets_pk_columns_input!
  ): buckets

  """
  update data of the table: "storage.buckets"
  """
  updateBuckets(
    """increments the numeric columns with given value of the filtered values"""
    _inc: buckets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: buckets_set_input

    """filter the rows which have to be updated"""
    where: buckets_bool_exp!
  ): buckets_mutation_response

  """
  update single row of the table: "storage.files"
  """
  updateFile(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: files_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: files_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: files_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: files_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: files_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input
    pk_columns: files_pk_columns_input!
  ): files

  """
  update data of the table: "storage.files"
  """
  updateFiles(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: files_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: files_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: files_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: files_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: files_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input

    """filter the rows which have to be updated"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  update single row of the table: "auth.users"
  """
  updateUser(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update data of the table: "auth.users"
  """
  updateUsers(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "storage.virus"
  """
  updateVirus(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: virus_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: virus_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: virus_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: virus_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: virus_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: virus_set_input
    pk_columns: virus_pk_columns_input!
  ): virus

  """
  update data of the table: "storage.virus"
  """
  updateViruses(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: virus_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: virus_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: virus_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: virus_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: virus_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: virus_set_input

    """filter the rows which have to be updated"""
    where: virus_bool_exp!
  ): virus_mutation_response

  """
  update multiples rows of table: "auth.provider_requests"
  """
  update_authProviderRequests_many(
    """updates to execute, in order"""
    updates: [authProviderRequests_updates!]!
  ): [authProviderRequests_mutation_response]

  """
  update multiples rows of table: "auth.providers"
  """
  update_authProviders_many(
    """updates to execute, in order"""
    updates: [authProviders_updates!]!
  ): [authProviders_mutation_response]

  """
  update multiples rows of table: "auth.refresh_token_types"
  """
  update_authRefreshTokenTypes_many(
    """updates to execute, in order"""
    updates: [authRefreshTokenTypes_updates!]!
  ): [authRefreshTokenTypes_mutation_response]

  """
  update multiples rows of table: "auth.refresh_tokens"
  """
  update_authRefreshTokens_many(
    """updates to execute, in order"""
    updates: [authRefreshTokens_updates!]!
  ): [authRefreshTokens_mutation_response]

  """
  update multiples rows of table: "auth.roles"
  """
  update_authRoles_many(
    """updates to execute, in order"""
    updates: [authRoles_updates!]!
  ): [authRoles_mutation_response]

  """
  update multiples rows of table: "auth.user_providers"
  """
  update_authUserProviders_many(
    """updates to execute, in order"""
    updates: [authUserProviders_updates!]!
  ): [authUserProviders_mutation_response]

  """
  update multiples rows of table: "auth.user_roles"
  """
  update_authUserRoles_many(
    """updates to execute, in order"""
    updates: [authUserRoles_updates!]!
  ): [authUserRoles_mutation_response]

  """
  update multiples rows of table: "auth.user_security_keys"
  """
  update_authUserSecurityKeys_many(
    """updates to execute, in order"""
    updates: [authUserSecurityKeys_updates!]!
  ): [authUserSecurityKeys_mutation_response]

  """
  update data of the table: "booking"
  """
  update_booking(
    """increments the numeric columns with given value of the filtered values"""
    _inc: booking_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: booking_set_input

    """filter the rows which have to be updated"""
    where: booking_bool_exp!
  ): booking_mutation_response

  """
  update single row of the table: "booking"
  """
  update_booking_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: booking_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: booking_set_input
    pk_columns: booking_pk_columns_input!
  ): booking

  """
  update data of the table: "booking_events.event_type"
  """
  update_booking_events_event_type(
    """sets the columns of the filtered rows to the given values"""
    _set: booking_events_event_type_set_input

    """filter the rows which have to be updated"""
    where: booking_events_event_type_bool_exp!
  ): booking_events_event_type_mutation_response

  """
  update single row of the table: "booking_events.event_type"
  """
  update_booking_events_event_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: booking_events_event_type_set_input
    pk_columns: booking_events_event_type_pk_columns_input!
  ): booking_events_event_type

  """
  update multiples rows of table: "booking_events.event_type"
  """
  update_booking_events_event_type_many(
    """updates to execute, in order"""
    updates: [booking_events_event_type_updates!]!
  ): [booking_events_event_type_mutation_response]

  """
  update data of the table: "booking_events.main"
  """
  update_booking_events_main(
    """increments the numeric columns with given value of the filtered values"""
    _inc: booking_events_main_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: booking_events_main_set_input

    """filter the rows which have to be updated"""
    where: booking_events_main_bool_exp!
  ): booking_events_main_mutation_response

  """
  update single row of the table: "booking_events.main"
  """
  update_booking_events_main_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: booking_events_main_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: booking_events_main_set_input
    pk_columns: booking_events_main_pk_columns_input!
  ): booking_events_main

  """
  update multiples rows of table: "booking_events.main"
  """
  update_booking_events_main_many(
    """updates to execute, in order"""
    updates: [booking_events_main_updates!]!
  ): [booking_events_main_mutation_response]

  """
  update data of the table: "booking_events.version"
  """
  update_booking_events_version(
    """increments the numeric columns with given value of the filtered values"""
    _inc: booking_events_version_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: booking_events_version_set_input

    """filter the rows which have to be updated"""
    where: booking_events_version_bool_exp!
  ): booking_events_version_mutation_response

  """
  update single row of the table: "booking_events.version"
  """
  update_booking_events_version_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: booking_events_version_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: booking_events_version_set_input
    pk_columns: booking_events_version_pk_columns_input!
  ): booking_events_version

  """
  update multiples rows of table: "booking_events.version"
  """
  update_booking_events_version_many(
    """updates to execute, in order"""
    updates: [booking_events_version_updates!]!
  ): [booking_events_version_mutation_response]

  """
  update data of the table: "booking_history_entry"
  """
  update_booking_history_entry(
    """increments the numeric columns with given value of the filtered values"""
    _inc: booking_history_entry_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: booking_history_entry_set_input

    """filter the rows which have to be updated"""
    where: booking_history_entry_bool_exp!
  ): booking_history_entry_mutation_response

  """
  update single row of the table: "booking_history_entry"
  """
  update_booking_history_entry_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: booking_history_entry_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: booking_history_entry_set_input
    pk_columns: booking_history_entry_pk_columns_input!
  ): booking_history_entry

  """
  update multiples rows of table: "booking_history_entry"
  """
  update_booking_history_entry_many(
    """updates to execute, in order"""
    updates: [booking_history_entry_updates!]!
  ): [booking_history_entry_mutation_response]

  """
  update multiples rows of table: "booking"
  """
  update_booking_many(
    """updates to execute, in order"""
    updates: [booking_updates!]!
  ): [booking_mutation_response]

  """
  update data of the table: "booking_product"
  """
  update_booking_product(
    """increments the numeric columns with given value of the filtered values"""
    _inc: booking_product_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: booking_product_set_input

    """filter the rows which have to be updated"""
    where: booking_product_bool_exp!
  ): booking_product_mutation_response

  """
  update single row of the table: "booking_product"
  """
  update_booking_product_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: booking_product_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: booking_product_set_input
    pk_columns: booking_product_pk_columns_input!
  ): booking_product

  """
  update multiples rows of table: "booking_product"
  """
  update_booking_product_many(
    """updates to execute, in order"""
    updates: [booking_product_updates!]!
  ): [booking_product_mutation_response]

  """
  update data of the table: "booking_question_scope"
  """
  update_booking_question_scope(
    """sets the columns of the filtered rows to the given values"""
    _set: booking_question_scope_set_input

    """filter the rows which have to be updated"""
    where: booking_question_scope_bool_exp!
  ): booking_question_scope_mutation_response

  """
  update single row of the table: "booking_question_scope"
  """
  update_booking_question_scope_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: booking_question_scope_set_input
    pk_columns: booking_question_scope_pk_columns_input!
  ): booking_question_scope

  """
  update multiples rows of table: "booking_question_scope"
  """
  update_booking_question_scope_many(
    """updates to execute, in order"""
    updates: [booking_question_scope_updates!]!
  ): [booking_question_scope_mutation_response]

  """
  update data of the table: "booking_question_type"
  """
  update_booking_question_type(
    """sets the columns of the filtered rows to the given values"""
    _set: booking_question_type_set_input

    """filter the rows which have to be updated"""
    where: booking_question_type_bool_exp!
  ): booking_question_type_mutation_response

  """
  update single row of the table: "booking_question_type"
  """
  update_booking_question_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: booking_question_type_set_input
    pk_columns: booking_question_type_pk_columns_input!
  ): booking_question_type

  """
  update multiples rows of table: "booking_question_type"
  """
  update_booking_question_type_many(
    """updates to execute, in order"""
    updates: [booking_question_type_updates!]!
  ): [booking_question_type_mutation_response]

  """
  update data of the table: "booking_state"
  """
  update_booking_state(
    """sets the columns of the filtered rows to the given values"""
    _set: booking_state_set_input

    """filter the rows which have to be updated"""
    where: booking_state_bool_exp!
  ): booking_state_mutation_response

  """
  update single row of the table: "booking_state"
  """
  update_booking_state_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: booking_state_set_input
    pk_columns: booking_state_pk_columns_input!
  ): booking_state

  """
  update multiples rows of table: "booking_state"
  """
  update_booking_state_many(
    """updates to execute, in order"""
    updates: [booking_state_updates!]!
  ): [booking_state_mutation_response]
  update_booking_version_with_optimistic_lock(arg: update_booking_version_with_optimistic_lock_input!): json!

  """
  update multiples rows of table: "storage.buckets"
  """
  update_buckets_many(
    """updates to execute, in order"""
    updates: [buckets_updates!]!
  ): [buckets_mutation_response]

  """
  update data of the table: "category"
  """
  update_category(
    """sets the columns of the filtered rows to the given values"""
    _set: category_set_input

    """filter the rows which have to be updated"""
    where: category_bool_exp!
  ): category_mutation_response

  """
  update single row of the table: "category"
  """
  update_category_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: category_set_input
    pk_columns: category_pk_columns_input!
  ): category

  """
  update multiples rows of table: "category"
  """
  update_category_many(
    """updates to execute, in order"""
    updates: [category_updates!]!
  ): [category_mutation_response]

  """
  update data of the table: "contact"
  """
  update_contact(
    """sets the columns of the filtered rows to the given values"""
    _set: contact_set_input

    """filter the rows which have to be updated"""
    where: contact_bool_exp!
  ): contact_mutation_response

  """
  update single row of the table: "contact"
  """
  update_contact_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: contact_set_input
    pk_columns: contact_pk_columns_input!
  ): contact

  """
  update multiples rows of table: "contact"
  """
  update_contact_many(
    """updates to execute, in order"""
    updates: [contact_updates!]!
  ): [contact_mutation_response]

  """
  update data of the table: "feature"
  """
  update_feature(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: feature_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: feature_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: feature_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: feature_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: feature_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: feature_set_input

    """filter the rows which have to be updated"""
    where: feature_bool_exp!
  ): feature_mutation_response

  """
  update single row of the table: "feature"
  """
  update_feature_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: feature_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: feature_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: feature_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: feature_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: feature_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: feature_set_input
    pk_columns: feature_pk_columns_input!
  ): feature

  """
  update data of the table: "feature_category"
  """
  update_feature_category(
    """sets the columns of the filtered rows to the given values"""
    _set: feature_category_set_input

    """filter the rows which have to be updated"""
    where: feature_category_bool_exp!
  ): feature_category_mutation_response

  """
  update single row of the table: "feature_category"
  """
  update_feature_category_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: feature_category_set_input
    pk_columns: feature_category_pk_columns_input!
  ): feature_category

  """
  update multiples rows of table: "feature_category"
  """
  update_feature_category_many(
    """updates to execute, in order"""
    updates: [feature_category_updates!]!
  ): [feature_category_mutation_response]

  """
  update multiples rows of table: "feature"
  """
  update_feature_many(
    """updates to execute, in order"""
    updates: [feature_updates!]!
  ): [feature_mutation_response]

  """
  update data of the table: "feature_symbol"
  """
  update_feature_symbol(
    """sets the columns of the filtered rows to the given values"""
    _set: feature_symbol_set_input

    """filter the rows which have to be updated"""
    where: feature_symbol_bool_exp!
  ): feature_symbol_mutation_response

  """
  update single row of the table: "feature_symbol"
  """
  update_feature_symbol_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: feature_symbol_set_input
    pk_columns: feature_symbol_pk_columns_input!
  ): feature_symbol

  """
  update multiples rows of table: "feature_symbol"
  """
  update_feature_symbol_many(
    """updates to execute, in order"""
    updates: [feature_symbol_updates!]!
  ): [feature_symbol_mutation_response]

  """
  update data of the table: "feature_type"
  """
  update_feature_type(
    """sets the columns of the filtered rows to the given values"""
    _set: feature_type_set_input

    """filter the rows which have to be updated"""
    where: feature_type_bool_exp!
  ): feature_type_mutation_response

  """
  update single row of the table: "feature_type"
  """
  update_feature_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: feature_type_set_input
    pk_columns: feature_type_pk_columns_input!
  ): feature_type

  """
  update multiples rows of table: "feature_type"
  """
  update_feature_type_many(
    """updates to execute, in order"""
    updates: [feature_type_updates!]!
  ): [feature_type_mutation_response]

  """
  update multiples rows of table: "storage.files"
  """
  update_files_many(
    """updates to execute, in order"""
    updates: [files_updates!]!
  ): [files_mutation_response]

  """
  update data of the table: "media_gallery"
  """
  update_media_gallery(
    """sets the columns of the filtered rows to the given values"""
    _set: media_gallery_set_input

    """filter the rows which have to be updated"""
    where: media_gallery_bool_exp!
  ): media_gallery_mutation_response

  """
  update single row of the table: "media_gallery"
  """
  update_media_gallery_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: media_gallery_set_input
    pk_columns: media_gallery_pk_columns_input!
  ): media_gallery

  """
  update data of the table: "media_gallery_item"
  """
  update_media_gallery_item(
    """increments the numeric columns with given value of the filtered values"""
    _inc: media_gallery_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: media_gallery_item_set_input

    """filter the rows which have to be updated"""
    where: media_gallery_item_bool_exp!
  ): media_gallery_item_mutation_response

  """
  update single row of the table: "media_gallery_item"
  """
  update_media_gallery_item_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: media_gallery_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: media_gallery_item_set_input
    pk_columns: media_gallery_item_pk_columns_input!
  ): media_gallery_item

  """
  update multiples rows of table: "media_gallery_item"
  """
  update_media_gallery_item_many(
    """updates to execute, in order"""
    updates: [media_gallery_item_updates!]!
  ): [media_gallery_item_mutation_response]

  """
  update multiples rows of table: "media_gallery"
  """
  update_media_gallery_many(
    """updates to execute, in order"""
    updates: [media_gallery_updates!]!
  ): [media_gallery_mutation_response]

  """
  update data of the table: "my_web_section"
  """
  update_my_web_section(
    """sets the columns of the filtered rows to the given values"""
    _set: my_web_section_set_input

    """filter the rows which have to be updated"""
    where: my_web_section_bool_exp!
  ): my_web_section_mutation_response

  """
  update single row of the table: "my_web_section"
  """
  update_my_web_section_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: my_web_section_set_input
    pk_columns: my_web_section_pk_columns_input!
  ): my_web_section

  """
  update multiples rows of table: "my_web_section"
  """
  update_my_web_section_many(
    """updates to execute, in order"""
    updates: [my_web_section_updates!]!
  ): [my_web_section_mutation_response]

  """
  update data of the table: "organization"
  """
  update_organization(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_set_input

    """filter the rows which have to be updated"""
    where: organization_bool_exp!
  ): organization_mutation_response

  """
  update data of the table: "organization_booking_question"
  """
  update_organization_booking_question(
    """increments the numeric columns with given value of the filtered values"""
    _inc: organization_booking_question_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: organization_booking_question_set_input

    """filter the rows which have to be updated"""
    where: organization_booking_question_bool_exp!
  ): organization_booking_question_mutation_response

  """
  update single row of the table: "organization_booking_question"
  """
  update_organization_booking_question_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: organization_booking_question_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: organization_booking_question_set_input
    pk_columns: organization_booking_question_pk_columns_input!
  ): organization_booking_question

  """
  update multiples rows of table: "organization_booking_question"
  """
  update_organization_booking_question_many(
    """updates to execute, in order"""
    updates: [organization_booking_question_updates!]!
  ): [organization_booking_question_mutation_response]

  """
  update data of the table: "organization_branding"
  """
  update_organization_branding(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_branding_set_input

    """filter the rows which have to be updated"""
    where: organization_branding_bool_exp!
  ): organization_branding_mutation_response

  """
  update single row of the table: "organization_branding"
  """
  update_organization_branding_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_branding_set_input
    pk_columns: organization_branding_pk_columns_input!
  ): organization_branding

  """
  update multiples rows of table: "organization_branding"
  """
  update_organization_branding_many(
    """updates to execute, in order"""
    updates: [organization_branding_updates!]!
  ): [organization_branding_mutation_response]

  """
  update data of the table: "organization_branding_meta_description"
  """
  update_organization_branding_meta_description(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_branding_meta_description_set_input

    """filter the rows which have to be updated"""
    where: organization_branding_meta_description_bool_exp!
  ): organization_branding_meta_description_mutation_response

  """
  update single row of the table: "organization_branding_meta_description"
  """
  update_organization_branding_meta_description_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_branding_meta_description_set_input
    pk_columns: organization_branding_meta_description_pk_columns_input!
  ): organization_branding_meta_description

  """
  update multiples rows of table: "organization_branding_meta_description"
  """
  update_organization_branding_meta_description_many(
    """updates to execute, in order"""
    updates: [organization_branding_meta_description_updates!]!
  ): [organization_branding_meta_description_mutation_response]

  """
  update data of the table: "organization_branding_meta_title"
  """
  update_organization_branding_meta_title(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_branding_meta_title_set_input

    """filter the rows which have to be updated"""
    where: organization_branding_meta_title_bool_exp!
  ): organization_branding_meta_title_mutation_response

  """
  update single row of the table: "organization_branding_meta_title"
  """
  update_organization_branding_meta_title_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_branding_meta_title_set_input
    pk_columns: organization_branding_meta_title_pk_columns_input!
  ): organization_branding_meta_title

  """
  update multiples rows of table: "organization_branding_meta_title"
  """
  update_organization_branding_meta_title_many(
    """updates to execute, in order"""
    updates: [organization_branding_meta_title_updates!]!
  ): [organization_branding_meta_title_mutation_response]

  """
  update data of the table: "organization_business_model"
  """
  update_organization_business_model(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_business_model_set_input

    """filter the rows which have to be updated"""
    where: organization_business_model_bool_exp!
  ): organization_business_model_mutation_response

  """
  update single row of the table: "organization_business_model"
  """
  update_organization_business_model_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_business_model_set_input
    pk_columns: organization_business_model_pk_columns_input!
  ): organization_business_model

  """
  update multiples rows of table: "organization_business_model"
  """
  update_organization_business_model_many(
    """updates to execute, in order"""
    updates: [organization_business_model_updates!]!
  ): [organization_business_model_mutation_response]

  """
  update single row of the table: "organization"
  """
  update_organization_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_set_input
    pk_columns: organization_pk_columns_input!
  ): organization

  """
  update data of the table: "organization_headline"
  """
  update_organization_headline(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_headline_set_input

    """filter the rows which have to be updated"""
    where: organization_headline_bool_exp!
  ): organization_headline_mutation_response

  """
  update single row of the table: "organization_headline"
  """
  update_organization_headline_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_headline_set_input
    pk_columns: organization_headline_pk_columns_input!
  ): organization_headline

  """
  update multiples rows of table: "organization_headline"
  """
  update_organization_headline_many(
    """updates to execute, in order"""
    updates: [organization_headline_updates!]!
  ): [organization_headline_mutation_response]

  """
  update multiples rows of table: "organization"
  """
  update_organization_many(
    """updates to execute, in order"""
    updates: [organization_updates!]!
  ): [organization_mutation_response]

  """
  update data of the table: "organization_member"
  """
  update_organization_member(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_member_set_input

    """filter the rows which have to be updated"""
    where: organization_member_bool_exp!
  ): organization_member_mutation_response

  """
  update single row of the table: "organization_member"
  """
  update_organization_member_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_member_set_input
    pk_columns: organization_member_pk_columns_input!
  ): organization_member

  """
  update multiples rows of table: "organization_member"
  """
  update_organization_member_many(
    """updates to execute, in order"""
    updates: [organization_member_updates!]!
  ): [organization_member_mutation_response]

  """
  update data of the table: "organization_socials"
  """
  update_organization_socials(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_socials_set_input

    """filter the rows which have to be updated"""
    where: organization_socials_bool_exp!
  ): organization_socials_mutation_response

  """
  update single row of the table: "organization_socials"
  """
  update_organization_socials_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: organization_socials_set_input
    pk_columns: organization_socials_pk_columns_input!
  ): organization_socials

  """
  update multiples rows of table: "organization_socials"
  """
  update_organization_socials_many(
    """updates to execute, in order"""
    updates: [organization_socials_updates!]!
  ): [organization_socials_mutation_response]

  """
  update data of the table: "place"
  """
  update_place(
    """increments the numeric columns with given value of the filtered values"""
    _inc: place_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: place_set_input

    """filter the rows which have to be updated"""
    where: place_bool_exp!
  ): place_mutation_response

  """
  update single row of the table: "place"
  """
  update_place_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: place_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: place_set_input
    pk_columns: place_pk_columns_input!
  ): place

  """
  update multiples rows of table: "place"
  """
  update_place_many(
    """updates to execute, in order"""
    updates: [place_updates!]!
  ): [place_mutation_response]

  """
  update data of the table: "product"
  """
  update_product(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_set_input

    """filter the rows which have to be updated"""
    where: product_bool_exp!
  ): product_mutation_response

  """
  update data of the table: "product_allotment_range"
  """
  update_product_allotment_range(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_allotment_range_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_allotment_range_set_input

    """filter the rows which have to be updated"""
    where: product_allotment_range_bool_exp!
  ): product_allotment_range_mutation_response

  """
  update single row of the table: "product_allotment_range"
  """
  update_product_allotment_range_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_allotment_range_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_allotment_range_set_input
    pk_columns: product_allotment_range_pk_columns_input!
  ): product_allotment_range

  """
  update multiples rows of table: "product_allotment_range"
  """
  update_product_allotment_range_many(
    """updates to execute, in order"""
    updates: [product_allotment_range_updates!]!
  ): [product_allotment_range_mutation_response]

  """
  update data of the table: "product_business_model"
  """
  update_product_business_model(
    """sets the columns of the filtered rows to the given values"""
    _set: product_business_model_set_input

    """filter the rows which have to be updated"""
    where: product_business_model_bool_exp!
  ): product_business_model_mutation_response

  """
  update single row of the table: "product_business_model"
  """
  update_product_business_model_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: product_business_model_set_input
    pk_columns: product_business_model_pk_columns_input!
  ): product_business_model

  """
  update multiples rows of table: "product_business_model"
  """
  update_product_business_model_many(
    """updates to execute, in order"""
    updates: [product_business_model_updates!]!
  ): [product_business_model_mutation_response]

  """
  update single row of the table: "product"
  """
  update_product_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_set_input
    pk_columns: product_pk_columns_input!
  ): product

  """
  update data of the table: "product_description"
  """
  update_product_description(
    """sets the columns of the filtered rows to the given values"""
    _set: product_description_set_input

    """filter the rows which have to be updated"""
    where: product_description_bool_exp!
  ): product_description_mutation_response

  """
  update single row of the table: "product_description"
  """
  update_product_description_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: product_description_set_input
    pk_columns: product_description_pk_columns_input!
  ): product_description

  """
  update multiples rows of table: "product_description"
  """
  update_product_description_many(
    """updates to execute, in order"""
    updates: [product_description_updates!]!
  ): [product_description_mutation_response]

  """
  update data of the table: "product_feature"
  """
  update_product_feature(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: product_feature_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: product_feature_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: product_feature_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: product_feature_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: product_feature_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: product_feature_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_feature_set_input

    """filter the rows which have to be updated"""
    where: product_feature_bool_exp!
  ): product_feature_mutation_response

  """
  update single row of the table: "product_feature"
  """
  update_product_feature_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: product_feature_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: product_feature_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: product_feature_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: product_feature_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: product_feature_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: product_feature_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_feature_set_input
    pk_columns: product_feature_pk_columns_input!
  ): product_feature

  """
  update multiples rows of table: "product_feature"
  """
  update_product_feature_many(
    """updates to execute, in order"""
    updates: [product_feature_updates!]!
  ): [product_feature_mutation_response]

  """
  update data of the table: "product_group"
  """
  update_product_group(
    """sets the columns of the filtered rows to the given values"""
    _set: product_group_set_input

    """filter the rows which have to be updated"""
    where: product_group_bool_exp!
  ): product_group_mutation_response

  """
  update single row of the table: "product_group"
  """
  update_product_group_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: product_group_set_input
    pk_columns: product_group_pk_columns_input!
  ): product_group

  """
  update multiples rows of table: "product_group"
  """
  update_product_group_many(
    """updates to execute, in order"""
    updates: [product_group_updates!]!
  ): [product_group_mutation_response]

  """
  update data of the table: "product_group_product"
  """
  update_product_group_product(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_group_product_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_group_product_set_input

    """filter the rows which have to be updated"""
    where: product_group_product_bool_exp!
  ): product_group_product_mutation_response

  """
  update single row of the table: "product_group_product"
  """
  update_product_group_product_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_group_product_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_group_product_set_input
    pk_columns: product_group_product_pk_columns_input!
  ): product_group_product

  """
  update multiples rows of table: "product_group_product"
  """
  update_product_group_product_many(
    """updates to execute, in order"""
    updates: [product_group_product_updates!]!
  ): [product_group_product_mutation_response]

  """
  update data of the table: "product_headline"
  """
  update_product_headline(
    """sets the columns of the filtered rows to the given values"""
    _set: product_headline_set_input

    """filter the rows which have to be updated"""
    where: product_headline_bool_exp!
  ): product_headline_mutation_response

  """
  update single row of the table: "product_headline"
  """
  update_product_headline_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: product_headline_set_input
    pk_columns: product_headline_pk_columns_input!
  ): product_headline

  """
  update multiples rows of table: "product_headline"
  """
  update_product_headline_many(
    """updates to execute, in order"""
    updates: [product_headline_updates!]!
  ): [product_headline_mutation_response]

  """
  update multiples rows of table: "product"
  """
  update_product_many(
    """updates to execute, in order"""
    updates: [product_updates!]!
  ): [product_mutation_response]

  """
  update data of the table: "product_name"
  """
  update_product_name(
    """sets the columns of the filtered rows to the given values"""
    _set: product_name_set_input

    """filter the rows which have to be updated"""
    where: product_name_bool_exp!
  ): product_name_mutation_response

  """
  update single row of the table: "product_name"
  """
  update_product_name_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: product_name_set_input
    pk_columns: product_name_pk_columns_input!
  ): product_name

  """
  update multiples rows of table: "product_name"
  """
  update_product_name_many(
    """updates to execute, in order"""
    updates: [product_name_updates!]!
  ): [product_name_mutation_response]

  """
  update data of the table: "product_supplement"
  """
  update_product_supplement(
    """sets the columns of the filtered rows to the given values"""
    _set: product_supplement_set_input

    """filter the rows which have to be updated"""
    where: product_supplement_bool_exp!
  ): product_supplement_mutation_response

  """
  update single row of the table: "product_supplement"
  """
  update_product_supplement_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: product_supplement_set_input
    pk_columns: product_supplement_pk_columns_input!
  ): product_supplement

  """
  update multiples rows of table: "product_supplement"
  """
  update_product_supplement_many(
    """updates to execute, in order"""
    updates: [product_supplement_updates!]!
  ): [product_supplement_mutation_response]

  """
  update data of the table: "rate"
  """
  update_rate(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: rate_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: rate_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: rate_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: rate_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: rate_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: rate_set_input

    """filter the rows which have to be updated"""
    where: rate_bool_exp!
  ): rate_mutation_response

  """
  update single row of the table: "rate"
  """
  update_rate_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: rate_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: rate_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: rate_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: rate_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: rate_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: rate_set_input
    pk_columns: rate_pk_columns_input!
  ): rate

  """
  update data of the table: "rate_headline"
  """
  update_rate_headline(
    """sets the columns of the filtered rows to the given values"""
    _set: rate_headline_set_input

    """filter the rows which have to be updated"""
    where: rate_headline_bool_exp!
  ): rate_headline_mutation_response

  """
  update single row of the table: "rate_headline"
  """
  update_rate_headline_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rate_headline_set_input
    pk_columns: rate_headline_pk_columns_input!
  ): rate_headline

  """
  update multiples rows of table: "rate_headline"
  """
  update_rate_headline_many(
    """updates to execute, in order"""
    updates: [rate_headline_updates!]!
  ): [rate_headline_mutation_response]

  """
  update multiples rows of table: "rate"
  """
  update_rate_many(
    """updates to execute, in order"""
    updates: [rate_updates!]!
  ): [rate_mutation_response]

  """
  update data of the table: "rate_name"
  """
  update_rate_name(
    """sets the columns of the filtered rows to the given values"""
    _set: rate_name_set_input

    """filter the rows which have to be updated"""
    where: rate_name_bool_exp!
  ): rate_name_mutation_response

  """
  update single row of the table: "rate_name"
  """
  update_rate_name_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rate_name_set_input
    pk_columns: rate_name_pk_columns_input!
  ): rate_name

  """
  update multiples rows of table: "rate_name"
  """
  update_rate_name_many(
    """updates to execute, in order"""
    updates: [rate_name_updates!]!
  ): [rate_name_mutation_response]

  """
  update data of the table: "rate_price_range"
  """
  update_rate_price_range(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rate_price_range_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rate_price_range_set_input

    """filter the rows which have to be updated"""
    where: rate_price_range_bool_exp!
  ): rate_price_range_mutation_response

  """
  update single row of the table: "rate_price_range"
  """
  update_rate_price_range_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rate_price_range_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rate_price_range_set_input
    pk_columns: rate_price_range_pk_columns_input!
  ): rate_price_range

  """
  update multiples rows of table: "rate_price_range"
  """
  update_rate_price_range_many(
    """updates to execute, in order"""
    updates: [rate_price_range_updates!]!
  ): [rate_price_range_mutation_response]

  """
  update data of the table: "rate_type"
  """
  update_rate_type(
    """sets the columns of the filtered rows to the given values"""
    _set: rate_type_set_input

    """filter the rows which have to be updated"""
    where: rate_type_bool_exp!
  ): rate_type_mutation_response

  """
  update single row of the table: "rate_type"
  """
  update_rate_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rate_type_set_input
    pk_columns: rate_type_pk_columns_input!
  ): rate_type

  """
  update multiples rows of table: "rate_type"
  """
  update_rate_type_many(
    """updates to execute, in order"""
    updates: [rate_type_updates!]!
  ): [rate_type_mutation_response]

  """
  update data of the table: "role"
  """
  update_role(
    """sets the columns of the filtered rows to the given values"""
    _set: role_set_input

    """filter the rows which have to be updated"""
    where: role_bool_exp!
  ): role_mutation_response

  """
  update single row of the table: "role"
  """
  update_role_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: role_set_input
    pk_columns: role_pk_columns_input!
  ): role

  """
  update multiples rows of table: "role"
  """
  update_role_many(
    """updates to execute, in order"""
    updates: [role_updates!]!
  ): [role_mutation_response]

  """
  update data of the table: "site"
  """
  update_site(
    """sets the columns of the filtered rows to the given values"""
    _set: site_set_input

    """filter the rows which have to be updated"""
    where: site_bool_exp!
  ): site_mutation_response

  """
  update single row of the table: "site"
  """
  update_site_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: site_set_input
    pk_columns: site_pk_columns_input!
  ): site

  """
  update multiples rows of table: "site"
  """
  update_site_many(
    """updates to execute, in order"""
    updates: [site_updates!]!
  ): [site_mutation_response]

  """
  update data of the table: "slug"
  """
  update_slug(
    """sets the columns of the filtered rows to the given values"""
    _set: slug_set_input

    """filter the rows which have to be updated"""
    where: slug_bool_exp!
  ): slug_mutation_response

  """
  update single row of the table: "slug"
  """
  update_slug_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: slug_set_input
    pk_columns: slug_pk_columns_input!
  ): slug

  """
  update multiples rows of table: "slug"
  """
  update_slug_many(
    """updates to execute, in order"""
    updates: [slug_updates!]!
  ): [slug_mutation_response]

  """
  update data of the table: "supplement"
  """
  update_supplement(
    """increments the numeric columns with given value of the filtered values"""
    _inc: supplement_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: supplement_set_input

    """filter the rows which have to be updated"""
    where: supplement_bool_exp!
  ): supplement_mutation_response

  """
  update single row of the table: "supplement"
  """
  update_supplement_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: supplement_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: supplement_set_input
    pk_columns: supplement_pk_columns_input!
  ): supplement

  """
  update multiples rows of table: "supplement"
  """
  update_supplement_many(
    """updates to execute, in order"""
    updates: [supplement_updates!]!
  ): [supplement_mutation_response]

  """
  update data of the table: "supplement_prices"
  """
  update_supplement_prices(
    """increments the numeric columns with given value of the filtered values"""
    _inc: supplement_prices_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: supplement_prices_set_input

    """filter the rows which have to be updated"""
    where: supplement_prices_bool_exp!
  ): supplement_prices_mutation_response

  """
  update multiples rows of table: "supplement_prices"
  """
  update_supplement_prices_many(
    """updates to execute, in order"""
    updates: [supplement_prices_updates!]!
  ): [supplement_prices_mutation_response]

  """
  update data of the table: "supplement_type"
  """
  update_supplement_type(
    """sets the columns of the filtered rows to the given values"""
    _set: supplement_type_set_input

    """filter the rows which have to be updated"""
    where: supplement_type_bool_exp!
  ): supplement_type_mutation_response

  """
  update single row of the table: "supplement_type"
  """
  update_supplement_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: supplement_type_set_input
    pk_columns: supplement_type_pk_columns_input!
  ): supplement_type

  """
  update multiples rows of table: "supplement_type"
  """
  update_supplement_type_many(
    """updates to execute, in order"""
    updates: [supplement_type_updates!]!
  ): [supplement_type_mutation_response]

  """
  update data of the table: "translated_text"
  """
  update_translated_text(
    """sets the columns of the filtered rows to the given values"""
    _set: translated_text_set_input

    """filter the rows which have to be updated"""
    where: translated_text_bool_exp!
  ): translated_text_mutation_response

  """
  update single row of the table: "translated_text"
  """
  update_translated_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: translated_text_set_input
    pk_columns: translated_text_pk_columns_input!
  ): translated_text

  """
  update multiples rows of table: "translated_text"
  """
  update_translated_text_many(
    """updates to execute, in order"""
    updates: [translated_text_updates!]!
  ): [translated_text_mutation_response]

  """
  update data of the table: "unit_management"
  """
  update_unit_management(
    """sets the columns of the filtered rows to the given values"""
    _set: unit_management_set_input

    """filter the rows which have to be updated"""
    where: unit_management_bool_exp!
  ): unit_management_mutation_response

  """
  update single row of the table: "unit_management"
  """
  update_unit_management_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: unit_management_set_input
    pk_columns: unit_management_pk_columns_input!
  ): unit_management

  """
  update multiples rows of table: "unit_management"
  """
  update_unit_management_many(
    """updates to execute, in order"""
    updates: [unit_management_updates!]!
  ): [unit_management_mutation_response]

  """
  update multiples rows of table: "auth.users"
  """
  update_users_many(
    """updates to execute, in order"""
    updates: [users_updates!]!
  ): [users_mutation_response]

  """
  update data of the table: "venue"
  """
  update_venue(
    """sets the columns of the filtered rows to the given values"""
    _set: venue_set_input

    """filter the rows which have to be updated"""
    where: venue_bool_exp!
  ): venue_mutation_response

  """
  update single row of the table: "venue"
  """
  update_venue_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: venue_set_input
    pk_columns: venue_pk_columns_input!
  ): venue

  """
  update data of the table: "venue_description"
  """
  update_venue_description(
    """sets the columns of the filtered rows to the given values"""
    _set: venue_description_set_input

    """filter the rows which have to be updated"""
    where: venue_description_bool_exp!
  ): venue_description_mutation_response

  """
  update single row of the table: "venue_description"
  """
  update_venue_description_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: venue_description_set_input
    pk_columns: venue_description_pk_columns_input!
  ): venue_description

  """
  update multiples rows of table: "venue_description"
  """
  update_venue_description_many(
    """updates to execute, in order"""
    updates: [venue_description_updates!]!
  ): [venue_description_mutation_response]

  """
  update data of the table: "venue_facility"
  """
  update_venue_facility(
    """increments the numeric columns with given value of the filtered values"""
    _inc: venue_facility_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: venue_facility_set_input

    """filter the rows which have to be updated"""
    where: venue_facility_bool_exp!
  ): venue_facility_mutation_response

  """
  update single row of the table: "venue_facility"
  """
  update_venue_facility_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: venue_facility_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: venue_facility_set_input
    pk_columns: venue_facility_pk_columns_input!
  ): venue_facility

  """
  update data of the table: "venue_facility_headline"
  """
  update_venue_facility_headline(
    """sets the columns of the filtered rows to the given values"""
    _set: venue_facility_headline_set_input

    """filter the rows which have to be updated"""
    where: venue_facility_headline_bool_exp!
  ): venue_facility_headline_mutation_response

  """
  update single row of the table: "venue_facility_headline"
  """
  update_venue_facility_headline_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: venue_facility_headline_set_input
    pk_columns: venue_facility_headline_pk_columns_input!
  ): venue_facility_headline

  """
  update multiples rows of table: "venue_facility_headline"
  """
  update_venue_facility_headline_many(
    """updates to execute, in order"""
    updates: [venue_facility_headline_updates!]!
  ): [venue_facility_headline_mutation_response]

  """
  update multiples rows of table: "venue_facility"
  """
  update_venue_facility_many(
    """updates to execute, in order"""
    updates: [venue_facility_updates!]!
  ): [venue_facility_mutation_response]

  """
  update data of the table: "venue_facility_name"
  """
  update_venue_facility_name(
    """sets the columns of the filtered rows to the given values"""
    _set: venue_facility_name_set_input

    """filter the rows which have to be updated"""
    where: venue_facility_name_bool_exp!
  ): venue_facility_name_mutation_response

  """
  update single row of the table: "venue_facility_name"
  """
  update_venue_facility_name_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: venue_facility_name_set_input
    pk_columns: venue_facility_name_pk_columns_input!
  ): venue_facility_name

  """
  update multiples rows of table: "venue_facility_name"
  """
  update_venue_facility_name_many(
    """updates to execute, in order"""
    updates: [venue_facility_name_updates!]!
  ): [venue_facility_name_mutation_response]

  """
  update data of the table: "venue_good_to_know"
  """
  update_venue_good_to_know(
    """sets the columns of the filtered rows to the given values"""
    _set: venue_good_to_know_set_input

    """filter the rows which have to be updated"""
    where: venue_good_to_know_bool_exp!
  ): venue_good_to_know_mutation_response

  """
  update single row of the table: "venue_good_to_know"
  """
  update_venue_good_to_know_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: venue_good_to_know_set_input
    pk_columns: venue_good_to_know_pk_columns_input!
  ): venue_good_to_know

  """
  update multiples rows of table: "venue_good_to_know"
  """
  update_venue_good_to_know_many(
    """updates to execute, in order"""
    updates: [venue_good_to_know_updates!]!
  ): [venue_good_to_know_mutation_response]

  """
  update multiples rows of table: "venue"
  """
  update_venue_many(
    """updates to execute, in order"""
    updates: [venue_updates!]!
  ): [venue_mutation_response]

  """
  update data of the table: "venue_usps"
  """
  update_venue_usps(
    """sets the columns of the filtered rows to the given values"""
    _set: venue_usps_set_input

    """filter the rows which have to be updated"""
    where: venue_usps_bool_exp!
  ): venue_usps_mutation_response

  """
  update single row of the table: "venue_usps"
  """
  update_venue_usps_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: venue_usps_set_input
    pk_columns: venue_usps_pk_columns_input!
  ): venue_usps

  """
  update data of the table: "venue_usps_line"
  """
  update_venue_usps_line(
    """increments the numeric columns with given value of the filtered values"""
    _inc: venue_usps_line_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: venue_usps_line_set_input

    """filter the rows which have to be updated"""
    where: venue_usps_line_bool_exp!
  ): venue_usps_line_mutation_response

  """
  update single row of the table: "venue_usps_line"
  """
  update_venue_usps_line_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: venue_usps_line_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: venue_usps_line_set_input
    pk_columns: venue_usps_line_pk_columns_input!
  ): venue_usps_line

  """
  update multiples rows of table: "venue_usps_line"
  """
  update_venue_usps_line_many(
    """updates to execute, in order"""
    updates: [venue_usps_line_updates!]!
  ): [venue_usps_line_mutation_response]

  """
  update multiples rows of table: "venue_usps"
  """
  update_venue_usps_many(
    """updates to execute, in order"""
    updates: [venue_usps_updates!]!
  ): [venue_usps_mutation_response]

  """
  update multiples rows of table: "storage.virus"
  """
  update_virus_many(
    """updates to execute, in order"""
    updates: [virus_updates!]!
  ): [virus_mutation_response]
  venue_facilities_save(arg: venue_facilities_save_input!): json!
  venue_gallery_save(arg: venue_gallery_save_input!): json!
  venue_main_save(arg: venue_main_save_input!): json!
  venue_usps_save(arg: venue_usps_save_input!): json!
}

"""
columns and relationships of "my_web_section"
"""
type my_web_section {
  organization_id: uuid!
  section_id: String!
  value(
    """JSON select path"""
    path: String
  ): json!
}

"""
aggregated selection of "my_web_section"
"""
type my_web_section_aggregate {
  aggregate: my_web_section_aggregate_fields
  nodes: [my_web_section!]!
}

input my_web_section_aggregate_bool_exp {
  count: my_web_section_aggregate_bool_exp_count
}

input my_web_section_aggregate_bool_exp_count {
  arguments: [my_web_section_select_column!]
  distinct: Boolean
  filter: my_web_section_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "my_web_section"
"""
type my_web_section_aggregate_fields {
  count(columns: [my_web_section_select_column!], distinct: Boolean): Int!
  max: my_web_section_max_fields
  min: my_web_section_min_fields
}

"""
order by aggregate values of table "my_web_section"
"""
input my_web_section_aggregate_order_by {
  count: order_by
  max: my_web_section_max_order_by
  min: my_web_section_min_order_by
}

"""
input type for inserting array relation for remote table "my_web_section"
"""
input my_web_section_arr_rel_insert_input {
  data: [my_web_section_insert_input!]!

  """upsert condition"""
  on_conflict: my_web_section_on_conflict
}

"""
Boolean expression to filter rows from the table "my_web_section". All fields are combined with a logical 'AND'.
"""
input my_web_section_bool_exp {
  _and: [my_web_section_bool_exp!]
  _not: my_web_section_bool_exp
  _or: [my_web_section_bool_exp!]
  organization_id: uuid_comparison_exp
  section_id: String_comparison_exp
  value: json_comparison_exp
}

"""
unique or primary key constraints on table "my_web_section"
"""
enum my_web_section_constraint {
  """
  unique or primary key constraint on columns "section_id", "organization_id"
  """
  my_web_section_pkey
}

"""
input type for inserting data into table "my_web_section"
"""
input my_web_section_insert_input {
  organization_id: uuid
  section_id: String
  value: json
}

"""aggregate max on columns"""
type my_web_section_max_fields {
  organization_id: uuid
  section_id: String
}

"""
order by max() on columns of table "my_web_section"
"""
input my_web_section_max_order_by {
  organization_id: order_by
  section_id: order_by
}

"""aggregate min on columns"""
type my_web_section_min_fields {
  organization_id: uuid
  section_id: String
}

"""
order by min() on columns of table "my_web_section"
"""
input my_web_section_min_order_by {
  organization_id: order_by
  section_id: order_by
}

"""
response of any mutation on the table "my_web_section"
"""
type my_web_section_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [my_web_section!]!
}

"""
on_conflict condition type for table "my_web_section"
"""
input my_web_section_on_conflict {
  constraint: my_web_section_constraint!
  update_columns: [my_web_section_update_column!]! = []
  where: my_web_section_bool_exp
}

"""Ordering options when selecting data from "my_web_section"."""
input my_web_section_order_by {
  organization_id: order_by
  section_id: order_by
  value: order_by
}

"""primary key columns input for table: my_web_section"""
input my_web_section_pk_columns_input {
  organization_id: uuid!
  section_id: String!
}

input my_web_section_save_input {
  organization_id: uuid!
  section_id: String!
  value: json!
}

"""
select columns of table "my_web_section"
"""
enum my_web_section_select_column {
  """column name"""
  organization_id

  """column name"""
  section_id

  """column name"""
  value
}

"""
input type for updating data in table "my_web_section"
"""
input my_web_section_set_input {
  organization_id: uuid
  section_id: String
  value: json
}

"""
Streaming cursor of the table "my_web_section"
"""
input my_web_section_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: my_web_section_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input my_web_section_stream_cursor_value_input {
  organization_id: uuid
  section_id: String
  value: json
}

"""
update columns of table "my_web_section"
"""
enum my_web_section_update_column {
  """column name"""
  organization_id

  """column name"""
  section_id

  """column name"""
  value
}

input my_web_section_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: my_web_section_set_input

  """filter the rows which have to be updated"""
  where: my_web_section_bool_exp!
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "organization"
"""
type organization {
  """An array relationship"""
  booking_questions(
    """distinct select on columns"""
    distinct_on: [organization_booking_question_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_booking_question_order_by!]

    """filter the rows returned"""
    where: organization_booking_question_bool_exp
  ): [organization_booking_question!]!

  """An aggregate relationship"""
  booking_questions_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_booking_question_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_booking_question_order_by!]

    """filter the rows returned"""
    where: organization_booking_question_bool_exp
  ): organization_booking_question_aggregate!

  """An array relationship"""
  bookings(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): [booking!]!

  """An aggregate relationship"""
  bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): booking_aggregate!

  """An object relationship"""
  branding: organization_branding!
  branding_id: uuid!

  """An object relationship"""
  business_model: organization_business_model
  business_model_id: uuid

  """An array relationship"""
  contacts(
    """distinct select on columns"""
    distinct_on: [contact_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contact_order_by!]

    """filter the rows returned"""
    where: contact_bool_exp
  ): [contact!]!

  """An aggregate relationship"""
  contacts_aggregate(
    """distinct select on columns"""
    distinct_on: [contact_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contact_order_by!]

    """filter the rows returned"""
    where: contact_bool_exp
  ): contact_aggregate!
  currency: String!
  email: String

  """An array relationship"""
  features(
    """distinct select on columns"""
    distinct_on: [feature_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_order_by!]

    """filter the rows returned"""
    where: feature_bool_exp
  ): [feature!]!

  """An aggregate relationship"""
  features_aggregate(
    """distinct select on columns"""
    distinct_on: [feature_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_order_by!]

    """filter the rows returned"""
    where: feature_bool_exp
  ): feature_aggregate!

  """An object relationship"""
  headline: organization_headline!
  headline_id: uuid!
  id: uuid!
  language: String!

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [organization_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_member_order_by!]

    """filter the rows returned"""
    where: organization_member_bool_exp
  ): [organization_member!]!

  """An aggregate relationship"""
  members_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_member_order_by!]

    """filter the rows returned"""
    where: organization_member_bool_exp
  ): organization_member_aggregate!
  name: String!
  phone_number: String

  """An array relationship"""
  product_groups(
    """distinct select on columns"""
    distinct_on: [product_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_group_order_by!]

    """filter the rows returned"""
    where: product_group_bool_exp
  ): [product_group!]!

  """An aggregate relationship"""
  product_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [product_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_group_order_by!]

    """filter the rows returned"""
    where: product_group_bool_exp
  ): product_group_aggregate!

  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """An aggregate relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!

  """An array relationship"""
  sections(
    """distinct select on columns"""
    distinct_on: [my_web_section_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [my_web_section_order_by!]

    """filter the rows returned"""
    where: my_web_section_bool_exp
  ): [my_web_section!]!

  """An aggregate relationship"""
  sections_aggregate(
    """distinct select on columns"""
    distinct_on: [my_web_section_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [my_web_section_order_by!]

    """filter the rows returned"""
    where: my_web_section_bool_exp
  ): my_web_section_aggregate!

  """An array relationship"""
  sites(
    """distinct select on columns"""
    distinct_on: [site_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [site_order_by!]

    """filter the rows returned"""
    where: site_bool_exp
  ): [site!]!

  """An aggregate relationship"""
  sites_aggregate(
    """distinct select on columns"""
    distinct_on: [site_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [site_order_by!]

    """filter the rows returned"""
    where: site_bool_exp
  ): site_aggregate!

  """An object relationship"""
  socials: organization_socials!
  socials_id: uuid!

  """An array relationship"""
  supplements(
    """distinct select on columns"""
    distinct_on: [supplement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supplement_order_by!]

    """filter the rows returned"""
    where: supplement_bool_exp
  ): [supplement!]!

  """An aggregate relationship"""
  supplements_aggregate(
    """distinct select on columns"""
    distinct_on: [supplement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supplement_order_by!]

    """filter the rows returned"""
    where: supplement_bool_exp
  ): supplement_aggregate!

  """An array relationship"""
  venues(
    """distinct select on columns"""
    distinct_on: [venue_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_order_by!]

    """filter the rows returned"""
    where: venue_bool_exp
  ): [venue!]!

  """An aggregate relationship"""
  venues_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_order_by!]

    """filter the rows returned"""
    where: venue_bool_exp
  ): venue_aggregate!
}

"""
aggregated selection of "organization"
"""
type organization_aggregate {
  aggregate: organization_aggregate_fields
  nodes: [organization!]!
}

"""
aggregate fields of "organization"
"""
type organization_aggregate_fields {
  count(columns: [organization_select_column!], distinct: Boolean): Int!
  max: organization_max_fields
  min: organization_min_fields
}

"""
columns and relationships of "organization_booking_question"
"""
type organization_booking_question {
  id: uuid!
  organization_id: uuid!
  position: numeric!
  scope: booking_question_scope_enum!

  """An object relationship"""
  text: translated_text!
  text_id: uuid!
  type: booking_question_type_enum!
  value(
    """JSON select path"""
    path: String
  ): json!
}

"""
aggregated selection of "organization_booking_question"
"""
type organization_booking_question_aggregate {
  aggregate: organization_booking_question_aggregate_fields
  nodes: [organization_booking_question!]!
}

input organization_booking_question_aggregate_bool_exp {
  count: organization_booking_question_aggregate_bool_exp_count
}

input organization_booking_question_aggregate_bool_exp_count {
  arguments: [organization_booking_question_select_column!]
  distinct: Boolean
  filter: organization_booking_question_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "organization_booking_question"
"""
type organization_booking_question_aggregate_fields {
  avg: organization_booking_question_avg_fields
  count(columns: [organization_booking_question_select_column!], distinct: Boolean): Int!
  max: organization_booking_question_max_fields
  min: organization_booking_question_min_fields
  stddev: organization_booking_question_stddev_fields
  stddev_pop: organization_booking_question_stddev_pop_fields
  stddev_samp: organization_booking_question_stddev_samp_fields
  sum: organization_booking_question_sum_fields
  var_pop: organization_booking_question_var_pop_fields
  var_samp: organization_booking_question_var_samp_fields
  variance: organization_booking_question_variance_fields
}

"""
order by aggregate values of table "organization_booking_question"
"""
input organization_booking_question_aggregate_order_by {
  avg: organization_booking_question_avg_order_by
  count: order_by
  max: organization_booking_question_max_order_by
  min: organization_booking_question_min_order_by
  stddev: organization_booking_question_stddev_order_by
  stddev_pop: organization_booking_question_stddev_pop_order_by
  stddev_samp: organization_booking_question_stddev_samp_order_by
  sum: organization_booking_question_sum_order_by
  var_pop: organization_booking_question_var_pop_order_by
  var_samp: organization_booking_question_var_samp_order_by
  variance: organization_booking_question_variance_order_by
}

"""
input type for inserting array relation for remote table "organization_booking_question"
"""
input organization_booking_question_arr_rel_insert_input {
  data: [organization_booking_question_insert_input!]!

  """upsert condition"""
  on_conflict: organization_booking_question_on_conflict
}

"""aggregate avg on columns"""
type organization_booking_question_avg_fields {
  position: Float
}

"""
order by avg() on columns of table "organization_booking_question"
"""
input organization_booking_question_avg_order_by {
  position: order_by
}

"""
Boolean expression to filter rows from the table "organization_booking_question". All fields are combined with a logical 'AND'.
"""
input organization_booking_question_bool_exp {
  _and: [organization_booking_question_bool_exp!]
  _not: organization_booking_question_bool_exp
  _or: [organization_booking_question_bool_exp!]
  id: uuid_comparison_exp
  organization_id: uuid_comparison_exp
  position: numeric_comparison_exp
  scope: booking_question_scope_enum_comparison_exp
  text: translated_text_bool_exp
  text_id: uuid_comparison_exp
  type: booking_question_type_enum_comparison_exp
  value: json_comparison_exp
}

"""
unique or primary key constraints on table "organization_booking_question"
"""
enum organization_booking_question_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  organization_booking_question_pkey
}

"""
input type for incrementing numeric columns in table "organization_booking_question"
"""
input organization_booking_question_inc_input {
  position: numeric
}

"""
input type for inserting data into table "organization_booking_question"
"""
input organization_booking_question_insert_input {
  id: uuid
  organization_id: uuid
  position: numeric
  scope: booking_question_scope_enum
  text: translated_text_obj_rel_insert_input
  text_id: uuid
  type: booking_question_type_enum
  value: json
}

"""aggregate max on columns"""
type organization_booking_question_max_fields {
  id: uuid
  organization_id: uuid
  position: numeric
  text_id: uuid
}

"""
order by max() on columns of table "organization_booking_question"
"""
input organization_booking_question_max_order_by {
  id: order_by
  organization_id: order_by
  position: order_by
  text_id: order_by
}

"""aggregate min on columns"""
type organization_booking_question_min_fields {
  id: uuid
  organization_id: uuid
  position: numeric
  text_id: uuid
}

"""
order by min() on columns of table "organization_booking_question"
"""
input organization_booking_question_min_order_by {
  id: order_by
  organization_id: order_by
  position: order_by
  text_id: order_by
}

"""
response of any mutation on the table "organization_booking_question"
"""
type organization_booking_question_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [organization_booking_question!]!
}

"""
on_conflict condition type for table "organization_booking_question"
"""
input organization_booking_question_on_conflict {
  constraint: organization_booking_question_constraint!
  update_columns: [organization_booking_question_update_column!]! = []
  where: organization_booking_question_bool_exp
}

"""
Ordering options when selecting data from "organization_booking_question".
"""
input organization_booking_question_order_by {
  id: order_by
  organization_id: order_by
  position: order_by
  scope: order_by
  text: translated_text_order_by
  text_id: order_by
  type: order_by
  value: order_by
}

"""primary key columns input for table: organization_booking_question"""
input organization_booking_question_pk_columns_input {
  id: uuid!
}

input organization_booking_question_save_input {
  id: uuid
  scope: String!
  text: multilanguage_field_input!
  type: String!
  value: json!
}

"""
select columns of table "organization_booking_question"
"""
enum organization_booking_question_select_column {
  """column name"""
  id

  """column name"""
  organization_id

  """column name"""
  position

  """column name"""
  scope

  """column name"""
  text_id

  """column name"""
  type

  """column name"""
  value
}

"""
input type for updating data in table "organization_booking_question"
"""
input organization_booking_question_set_input {
  id: uuid
  organization_id: uuid
  position: numeric
  scope: booking_question_scope_enum
  text_id: uuid
  type: booking_question_type_enum
  value: json
}

"""aggregate stddev on columns"""
type organization_booking_question_stddev_fields {
  position: Float
}

"""
order by stddev() on columns of table "organization_booking_question"
"""
input organization_booking_question_stddev_order_by {
  position: order_by
}

"""aggregate stddev_pop on columns"""
type organization_booking_question_stddev_pop_fields {
  position: Float
}

"""
order by stddev_pop() on columns of table "organization_booking_question"
"""
input organization_booking_question_stddev_pop_order_by {
  position: order_by
}

"""aggregate stddev_samp on columns"""
type organization_booking_question_stddev_samp_fields {
  position: Float
}

"""
order by stddev_samp() on columns of table "organization_booking_question"
"""
input organization_booking_question_stddev_samp_order_by {
  position: order_by
}

"""
Streaming cursor of the table "organization_booking_question"
"""
input organization_booking_question_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: organization_booking_question_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input organization_booking_question_stream_cursor_value_input {
  id: uuid
  organization_id: uuid
  position: numeric
  scope: booking_question_scope_enum
  text_id: uuid
  type: booking_question_type_enum
  value: json
}

"""aggregate sum on columns"""
type organization_booking_question_sum_fields {
  position: numeric
}

"""
order by sum() on columns of table "organization_booking_question"
"""
input organization_booking_question_sum_order_by {
  position: order_by
}

"""
update columns of table "organization_booking_question"
"""
enum organization_booking_question_update_column {
  """column name"""
  id

  """column name"""
  organization_id

  """column name"""
  position

  """column name"""
  scope

  """column name"""
  text_id

  """column name"""
  type

  """column name"""
  value
}

input organization_booking_question_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: organization_booking_question_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: organization_booking_question_set_input

  """filter the rows which have to be updated"""
  where: organization_booking_question_bool_exp!
}

"""aggregate var_pop on columns"""
type organization_booking_question_var_pop_fields {
  position: Float
}

"""
order by var_pop() on columns of table "organization_booking_question"
"""
input organization_booking_question_var_pop_order_by {
  position: order_by
}

"""aggregate var_samp on columns"""
type organization_booking_question_var_samp_fields {
  position: Float
}

"""
order by var_samp() on columns of table "organization_booking_question"
"""
input organization_booking_question_var_samp_order_by {
  position: order_by
}

"""aggregate variance on columns"""
type organization_booking_question_variance_fields {
  position: Float
}

"""
order by variance() on columns of table "organization_booking_question"
"""
input organization_booking_question_variance_order_by {
  position: order_by
}

input organization_booking_questions_save_input {
  organization_id: uuid!
  questions: [organization_booking_question_save_input!]!
}

"""
Boolean expression to filter rows from the table "organization". All fields are combined with a logical 'AND'.
"""
input organization_bool_exp {
  _and: [organization_bool_exp!]
  _not: organization_bool_exp
  _or: [organization_bool_exp!]
  booking_questions: organization_booking_question_bool_exp
  booking_questions_aggregate: organization_booking_question_aggregate_bool_exp
  bookings: booking_bool_exp
  bookings_aggregate: booking_aggregate_bool_exp
  branding: organization_branding_bool_exp
  branding_id: uuid_comparison_exp
  business_model: organization_business_model_bool_exp
  business_model_id: uuid_comparison_exp
  contacts: contact_bool_exp
  contacts_aggregate: contact_aggregate_bool_exp
  currency: String_comparison_exp
  email: String_comparison_exp
  features: feature_bool_exp
  features_aggregate: feature_aggregate_bool_exp
  headline: organization_headline_bool_exp
  headline_id: uuid_comparison_exp
  id: uuid_comparison_exp
  language: String_comparison_exp
  members: organization_member_bool_exp
  members_aggregate: organization_member_aggregate_bool_exp
  name: String_comparison_exp
  phone_number: String_comparison_exp
  product_groups: product_group_bool_exp
  product_groups_aggregate: product_group_aggregate_bool_exp
  products: product_bool_exp
  products_aggregate: product_aggregate_bool_exp
  sections: my_web_section_bool_exp
  sections_aggregate: my_web_section_aggregate_bool_exp
  sites: site_bool_exp
  sites_aggregate: site_aggregate_bool_exp
  socials: organization_socials_bool_exp
  socials_id: uuid_comparison_exp
  supplements: supplement_bool_exp
  supplements_aggregate: supplement_aggregate_bool_exp
  venues: venue_bool_exp
  venues_aggregate: venue_aggregate_bool_exp
}

"""
columns and relationships of "organization_branding"
"""
type organization_branding {
  favicon_id: uuid
  id: uuid!
  logo_id: uuid
  logo_light_id: uuid

  """An object relationship"""
  meta_description: organization_branding_meta_description
  meta_description_id: uuid

  """An object relationship"""
  meta_title: organization_branding_meta_title!
  meta_title_id: uuid!

  """An object relationship"""
  organization: organization
}

"""
aggregated selection of "organization_branding"
"""
type organization_branding_aggregate {
  aggregate: organization_branding_aggregate_fields
  nodes: [organization_branding!]!
}

"""
aggregate fields of "organization_branding"
"""
type organization_branding_aggregate_fields {
  count(columns: [organization_branding_select_column!], distinct: Boolean): Int!
  max: organization_branding_max_fields
  min: organization_branding_min_fields
}

"""
Boolean expression to filter rows from the table "organization_branding". All fields are combined with a logical 'AND'.
"""
input organization_branding_bool_exp {
  _and: [organization_branding_bool_exp!]
  _not: organization_branding_bool_exp
  _or: [organization_branding_bool_exp!]
  favicon_id: uuid_comparison_exp
  id: uuid_comparison_exp
  logo_id: uuid_comparison_exp
  logo_light_id: uuid_comparison_exp
  meta_description: organization_branding_meta_description_bool_exp
  meta_description_id: uuid_comparison_exp
  meta_title: organization_branding_meta_title_bool_exp
  meta_title_id: uuid_comparison_exp
  organization: organization_bool_exp
}

"""
unique or primary key constraints on table "organization_branding"
"""
enum organization_branding_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  organization_branding_pkey
}

"""
input type for inserting data into table "organization_branding"
"""
input organization_branding_insert_input {
  favicon_id: uuid
  id: uuid
  logo_id: uuid
  logo_light_id: uuid
  meta_description: organization_branding_meta_description_obj_rel_insert_input
  meta_description_id: uuid
  meta_title: organization_branding_meta_title_obj_rel_insert_input
  meta_title_id: uuid
  organization: organization_obj_rel_insert_input
}

"""aggregate max on columns"""
type organization_branding_max_fields {
  favicon_id: uuid
  id: uuid
  logo_id: uuid
  logo_light_id: uuid
  meta_description_id: uuid
  meta_title_id: uuid
}

"""
columns and relationships of "organization_branding_meta_description"
"""
type organization_branding_meta_description {
  de: String
  en: String
  es: String
  fr: String
  id: uuid!
}

"""
aggregated selection of "organization_branding_meta_description"
"""
type organization_branding_meta_description_aggregate {
  aggregate: organization_branding_meta_description_aggregate_fields
  nodes: [organization_branding_meta_description!]!
}

"""
aggregate fields of "organization_branding_meta_description"
"""
type organization_branding_meta_description_aggregate_fields {
  count(columns: [organization_branding_meta_description_select_column!], distinct: Boolean): Int!
  max: organization_branding_meta_description_max_fields
  min: organization_branding_meta_description_min_fields
}

"""
Boolean expression to filter rows from the table "organization_branding_meta_description". All fields are combined with a logical 'AND'.
"""
input organization_branding_meta_description_bool_exp {
  _and: [organization_branding_meta_description_bool_exp!]
  _not: organization_branding_meta_description_bool_exp
  _or: [organization_branding_meta_description_bool_exp!]
  de: String_comparison_exp
  en: String_comparison_exp
  es: String_comparison_exp
  fr: String_comparison_exp
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "organization_branding_meta_description"
"""
enum organization_branding_meta_description_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  organization_branding_meta_description_pkey
}

"""
input type for inserting data into table "organization_branding_meta_description"
"""
input organization_branding_meta_description_insert_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate max on columns"""
type organization_branding_meta_description_max_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate min on columns"""
type organization_branding_meta_description_min_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
response of any mutation on the table "organization_branding_meta_description"
"""
type organization_branding_meta_description_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [organization_branding_meta_description!]!
}

"""
input type for inserting object relation for remote table "organization_branding_meta_description"
"""
input organization_branding_meta_description_obj_rel_insert_input {
  data: organization_branding_meta_description_insert_input!

  """upsert condition"""
  on_conflict: organization_branding_meta_description_on_conflict
}

"""
on_conflict condition type for table "organization_branding_meta_description"
"""
input organization_branding_meta_description_on_conflict {
  constraint: organization_branding_meta_description_constraint!
  update_columns: [organization_branding_meta_description_update_column!]! = []
  where: organization_branding_meta_description_bool_exp
}

"""
Ordering options when selecting data from "organization_branding_meta_description".
"""
input organization_branding_meta_description_order_by {
  de: order_by
  en: order_by
  es: order_by
  fr: order_by
  id: order_by
}

"""
primary key columns input for table: organization_branding_meta_description
"""
input organization_branding_meta_description_pk_columns_input {
  id: uuid!
}

"""
select columns of table "organization_branding_meta_description"
"""
enum organization_branding_meta_description_select_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

"""
input type for updating data in table "organization_branding_meta_description"
"""
input organization_branding_meta_description_set_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
Streaming cursor of the table "organization_branding_meta_description"
"""
input organization_branding_meta_description_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: organization_branding_meta_description_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input organization_branding_meta_description_stream_cursor_value_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
update columns of table "organization_branding_meta_description"
"""
enum organization_branding_meta_description_update_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

input organization_branding_meta_description_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: organization_branding_meta_description_set_input

  """filter the rows which have to be updated"""
  where: organization_branding_meta_description_bool_exp!
}

"""
columns and relationships of "organization_branding_meta_title"
"""
type organization_branding_meta_title {
  de: String
  en: String
  es: String
  fr: String
  id: uuid!
}

"""
aggregated selection of "organization_branding_meta_title"
"""
type organization_branding_meta_title_aggregate {
  aggregate: organization_branding_meta_title_aggregate_fields
  nodes: [organization_branding_meta_title!]!
}

"""
aggregate fields of "organization_branding_meta_title"
"""
type organization_branding_meta_title_aggregate_fields {
  count(columns: [organization_branding_meta_title_select_column!], distinct: Boolean): Int!
  max: organization_branding_meta_title_max_fields
  min: organization_branding_meta_title_min_fields
}

"""
Boolean expression to filter rows from the table "organization_branding_meta_title". All fields are combined with a logical 'AND'.
"""
input organization_branding_meta_title_bool_exp {
  _and: [organization_branding_meta_title_bool_exp!]
  _not: organization_branding_meta_title_bool_exp
  _or: [organization_branding_meta_title_bool_exp!]
  de: String_comparison_exp
  en: String_comparison_exp
  es: String_comparison_exp
  fr: String_comparison_exp
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "organization_branding_meta_title"
"""
enum organization_branding_meta_title_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  organization_branding_meta_title_pkey
}

"""
input type for inserting data into table "organization_branding_meta_title"
"""
input organization_branding_meta_title_insert_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate max on columns"""
type organization_branding_meta_title_max_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate min on columns"""
type organization_branding_meta_title_min_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
response of any mutation on the table "organization_branding_meta_title"
"""
type organization_branding_meta_title_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [organization_branding_meta_title!]!
}

"""
input type for inserting object relation for remote table "organization_branding_meta_title"
"""
input organization_branding_meta_title_obj_rel_insert_input {
  data: organization_branding_meta_title_insert_input!

  """upsert condition"""
  on_conflict: organization_branding_meta_title_on_conflict
}

"""
on_conflict condition type for table "organization_branding_meta_title"
"""
input organization_branding_meta_title_on_conflict {
  constraint: organization_branding_meta_title_constraint!
  update_columns: [organization_branding_meta_title_update_column!]! = []
  where: organization_branding_meta_title_bool_exp
}

"""
Ordering options when selecting data from "organization_branding_meta_title".
"""
input organization_branding_meta_title_order_by {
  de: order_by
  en: order_by
  es: order_by
  fr: order_by
  id: order_by
}

"""primary key columns input for table: organization_branding_meta_title"""
input organization_branding_meta_title_pk_columns_input {
  id: uuid!
}

"""
select columns of table "organization_branding_meta_title"
"""
enum organization_branding_meta_title_select_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

"""
input type for updating data in table "organization_branding_meta_title"
"""
input organization_branding_meta_title_set_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
Streaming cursor of the table "organization_branding_meta_title"
"""
input organization_branding_meta_title_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: organization_branding_meta_title_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input organization_branding_meta_title_stream_cursor_value_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
update columns of table "organization_branding_meta_title"
"""
enum organization_branding_meta_title_update_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

input organization_branding_meta_title_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: organization_branding_meta_title_set_input

  """filter the rows which have to be updated"""
  where: organization_branding_meta_title_bool_exp!
}

"""aggregate min on columns"""
type organization_branding_min_fields {
  favicon_id: uuid
  id: uuid
  logo_id: uuid
  logo_light_id: uuid
  meta_description_id: uuid
  meta_title_id: uuid
}

"""
response of any mutation on the table "organization_branding"
"""
type organization_branding_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [organization_branding!]!
}

"""
input type for inserting object relation for remote table "organization_branding"
"""
input organization_branding_obj_rel_insert_input {
  data: organization_branding_insert_input!

  """upsert condition"""
  on_conflict: organization_branding_on_conflict
}

"""
on_conflict condition type for table "organization_branding"
"""
input organization_branding_on_conflict {
  constraint: organization_branding_constraint!
  update_columns: [organization_branding_update_column!]! = []
  where: organization_branding_bool_exp
}

"""Ordering options when selecting data from "organization_branding"."""
input organization_branding_order_by {
  favicon_id: order_by
  id: order_by
  logo_id: order_by
  logo_light_id: order_by
  meta_description: organization_branding_meta_description_order_by
  meta_description_id: order_by
  meta_title: organization_branding_meta_title_order_by
  meta_title_id: order_by
  organization: organization_order_by
}

"""primary key columns input for table: organization_branding"""
input organization_branding_pk_columns_input {
  id: uuid!
}

input organization_branding_save_input {
  favicon_id: uuid
  id: uuid!
  logo_id: uuid
  logo_light_id: uuid
  meta_description: multilanguage_field_input
  meta_title: multilanguage_field_input
}

"""
select columns of table "organization_branding"
"""
enum organization_branding_select_column {
  """column name"""
  favicon_id

  """column name"""
  id

  """column name"""
  logo_id

  """column name"""
  logo_light_id

  """column name"""
  meta_description_id

  """column name"""
  meta_title_id
}

"""
input type for updating data in table "organization_branding"
"""
input organization_branding_set_input {
  favicon_id: uuid
  id: uuid
  logo_id: uuid
  logo_light_id: uuid
  meta_description_id: uuid
  meta_title_id: uuid
}

"""
Streaming cursor of the table "organization_branding"
"""
input organization_branding_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: organization_branding_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input organization_branding_stream_cursor_value_input {
  favicon_id: uuid
  id: uuid
  logo_id: uuid
  logo_light_id: uuid
  meta_description_id: uuid
  meta_title_id: uuid
}

"""
update columns of table "organization_branding"
"""
enum organization_branding_update_column {
  """column name"""
  favicon_id

  """column name"""
  id

  """column name"""
  logo_id

  """column name"""
  logo_light_id

  """column name"""
  meta_description_id

  """column name"""
  meta_title_id
}

input organization_branding_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: organization_branding_set_input

  """filter the rows which have to be updated"""
  where: organization_branding_bool_exp!
}

"""
columns and relationships of "organization_business_model"
"""
type organization_business_model {
  id: uuid!
  rate_type: rate_type_enum!
  unit_management: unit_management_enum!
}

"""
aggregated selection of "organization_business_model"
"""
type organization_business_model_aggregate {
  aggregate: organization_business_model_aggregate_fields
  nodes: [organization_business_model!]!
}

"""
aggregate fields of "organization_business_model"
"""
type organization_business_model_aggregate_fields {
  count(columns: [organization_business_model_select_column!], distinct: Boolean): Int!
  max: organization_business_model_max_fields
  min: organization_business_model_min_fields
}

"""
Boolean expression to filter rows from the table "organization_business_model". All fields are combined with a logical 'AND'.
"""
input organization_business_model_bool_exp {
  _and: [organization_business_model_bool_exp!]
  _not: organization_business_model_bool_exp
  _or: [organization_business_model_bool_exp!]
  id: uuid_comparison_exp
  rate_type: rate_type_enum_comparison_exp
  unit_management: unit_management_enum_comparison_exp
}

"""
unique or primary key constraints on table "organization_business_model"
"""
enum organization_business_model_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  organization_business_model_pkey
}

"""
input type for inserting data into table "organization_business_model"
"""
input organization_business_model_insert_input {
  id: uuid
  rate_type: rate_type_enum
  unit_management: unit_management_enum
}

"""aggregate max on columns"""
type organization_business_model_max_fields {
  id: uuid
}

"""aggregate min on columns"""
type organization_business_model_min_fields {
  id: uuid
}

"""
response of any mutation on the table "organization_business_model"
"""
type organization_business_model_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [organization_business_model!]!
}

"""
input type for inserting object relation for remote table "organization_business_model"
"""
input organization_business_model_obj_rel_insert_input {
  data: organization_business_model_insert_input!

  """upsert condition"""
  on_conflict: organization_business_model_on_conflict
}

"""
on_conflict condition type for table "organization_business_model"
"""
input organization_business_model_on_conflict {
  constraint: organization_business_model_constraint!
  update_columns: [organization_business_model_update_column!]! = []
  where: organization_business_model_bool_exp
}

"""
Ordering options when selecting data from "organization_business_model".
"""
input organization_business_model_order_by {
  id: order_by
  rate_type: order_by
  unit_management: order_by
}

"""primary key columns input for table: organization_business_model"""
input organization_business_model_pk_columns_input {
  id: uuid!
}

"""
select columns of table "organization_business_model"
"""
enum organization_business_model_select_column {
  """column name"""
  id

  """column name"""
  rate_type

  """column name"""
  unit_management
}

"""
input type for updating data in table "organization_business_model"
"""
input organization_business_model_set_input {
  id: uuid
  rate_type: rate_type_enum
  unit_management: unit_management_enum
}

"""
Streaming cursor of the table "organization_business_model"
"""
input organization_business_model_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: organization_business_model_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input organization_business_model_stream_cursor_value_input {
  id: uuid
  rate_type: rate_type_enum
  unit_management: unit_management_enum
}

"""
update columns of table "organization_business_model"
"""
enum organization_business_model_update_column {
  """column name"""
  id

  """column name"""
  rate_type

  """column name"""
  unit_management
}

input organization_business_model_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: organization_business_model_set_input

  """filter the rows which have to be updated"""
  where: organization_business_model_bool_exp!
}

"""
unique or primary key constraints on table "organization"
"""
enum organization_constraint {
  """
  unique or primary key constraint on columns "branding_id"
  """
  organization_branding_id_key

  """
  unique or primary key constraint on columns "name"
  """
  organization_name_key

  """
  unique or primary key constraint on columns "id"
  """
  organization_pkey
}

input organization_create_input {
  name: String!
  owner_email: String!
}

"""
columns and relationships of "organization_headline"
"""
type organization_headline {
  de: String
  en: String
  es: String
  fr: String
  id: uuid!
}

"""
aggregated selection of "organization_headline"
"""
type organization_headline_aggregate {
  aggregate: organization_headline_aggregate_fields
  nodes: [organization_headline!]!
}

"""
aggregate fields of "organization_headline"
"""
type organization_headline_aggregate_fields {
  count(columns: [organization_headline_select_column!], distinct: Boolean): Int!
  max: organization_headline_max_fields
  min: organization_headline_min_fields
}

"""
Boolean expression to filter rows from the table "organization_headline". All fields are combined with a logical 'AND'.
"""
input organization_headline_bool_exp {
  _and: [organization_headline_bool_exp!]
  _not: organization_headline_bool_exp
  _or: [organization_headline_bool_exp!]
  de: String_comparison_exp
  en: String_comparison_exp
  es: String_comparison_exp
  fr: String_comparison_exp
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "organization_headline"
"""
enum organization_headline_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  organization_headline_pkey
}

"""
input type for inserting data into table "organization_headline"
"""
input organization_headline_insert_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate max on columns"""
type organization_headline_max_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate min on columns"""
type organization_headline_min_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
response of any mutation on the table "organization_headline"
"""
type organization_headline_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [organization_headline!]!
}

"""
input type for inserting object relation for remote table "organization_headline"
"""
input organization_headline_obj_rel_insert_input {
  data: organization_headline_insert_input!

  """upsert condition"""
  on_conflict: organization_headline_on_conflict
}

"""
on_conflict condition type for table "organization_headline"
"""
input organization_headline_on_conflict {
  constraint: organization_headline_constraint!
  update_columns: [organization_headline_update_column!]! = []
  where: organization_headline_bool_exp
}

"""Ordering options when selecting data from "organization_headline"."""
input organization_headline_order_by {
  de: order_by
  en: order_by
  es: order_by
  fr: order_by
  id: order_by
}

"""primary key columns input for table: organization_headline"""
input organization_headline_pk_columns_input {
  id: uuid!
}

"""
select columns of table "organization_headline"
"""
enum organization_headline_select_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

"""
input type for updating data in table "organization_headline"
"""
input organization_headline_set_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
Streaming cursor of the table "organization_headline"
"""
input organization_headline_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: organization_headline_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input organization_headline_stream_cursor_value_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
update columns of table "organization_headline"
"""
enum organization_headline_update_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

input organization_headline_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: organization_headline_set_input

  """filter the rows which have to be updated"""
  where: organization_headline_bool_exp!
}

"""
input type for inserting data into table "organization"
"""
input organization_insert_input {
  booking_questions: organization_booking_question_arr_rel_insert_input
  bookings: booking_arr_rel_insert_input
  branding: organization_branding_obj_rel_insert_input
  branding_id: uuid
  business_model: organization_business_model_obj_rel_insert_input
  business_model_id: uuid
  contacts: contact_arr_rel_insert_input
  currency: String
  email: String
  features: feature_arr_rel_insert_input
  headline: organization_headline_obj_rel_insert_input
  headline_id: uuid
  id: uuid
  language: String
  members: organization_member_arr_rel_insert_input
  name: String
  phone_number: String
  product_groups: product_group_arr_rel_insert_input
  products: product_arr_rel_insert_input
  sections: my_web_section_arr_rel_insert_input
  sites: site_arr_rel_insert_input
  socials: organization_socials_obj_rel_insert_input
  socials_id: uuid
  supplements: supplement_arr_rel_insert_input
  venues: venue_arr_rel_insert_input
}

"""aggregate max on columns"""
type organization_max_fields {
  branding_id: uuid
  business_model_id: uuid
  currency: String
  email: String
  headline_id: uuid
  id: uuid
  language: String
  name: String
  phone_number: String
  socials_id: uuid
}

"""
columns and relationships of "organization_member"
"""
type organization_member {
  """An object relationship"""
  organization: organization!
  organization_id: uuid!
  role: role_enum!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "organization_member"
"""
type organization_member_aggregate {
  aggregate: organization_member_aggregate_fields
  nodes: [organization_member!]!
}

input organization_member_aggregate_bool_exp {
  count: organization_member_aggregate_bool_exp_count
}

input organization_member_aggregate_bool_exp_count {
  arguments: [organization_member_select_column!]
  distinct: Boolean
  filter: organization_member_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "organization_member"
"""
type organization_member_aggregate_fields {
  count(columns: [organization_member_select_column!], distinct: Boolean): Int!
  max: organization_member_max_fields
  min: organization_member_min_fields
}

"""
order by aggregate values of table "organization_member"
"""
input organization_member_aggregate_order_by {
  count: order_by
  max: organization_member_max_order_by
  min: organization_member_min_order_by
}

"""
input type for inserting array relation for remote table "organization_member"
"""
input organization_member_arr_rel_insert_input {
  data: [organization_member_insert_input!]!

  """upsert condition"""
  on_conflict: organization_member_on_conflict
}

"""
Boolean expression to filter rows from the table "organization_member". All fields are combined with a logical 'AND'.
"""
input organization_member_bool_exp {
  _and: [organization_member_bool_exp!]
  _not: organization_member_bool_exp
  _or: [organization_member_bool_exp!]
  organization: organization_bool_exp
  organization_id: uuid_comparison_exp
  role: role_enum_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "organization_member"
"""
enum organization_member_constraint {
  """
  unique or primary key constraint on columns "user_id", "organization_id"
  """
  organization_member_pkey
}

"""
input type for inserting data into table "organization_member"
"""
input organization_member_insert_input {
  organization: organization_obj_rel_insert_input
  organization_id: uuid
  role: role_enum
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type organization_member_max_fields {
  organization_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "organization_member"
"""
input organization_member_max_order_by {
  organization_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type organization_member_min_fields {
  organization_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "organization_member"
"""
input organization_member_min_order_by {
  organization_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "organization_member"
"""
type organization_member_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [organization_member!]!
}

"""
on_conflict condition type for table "organization_member"
"""
input organization_member_on_conflict {
  constraint: organization_member_constraint!
  update_columns: [organization_member_update_column!]! = []
  where: organization_member_bool_exp
}

"""Ordering options when selecting data from "organization_member"."""
input organization_member_order_by {
  organization: organization_order_by
  organization_id: order_by
  role: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: organization_member"""
input organization_member_pk_columns_input {
  organization_id: uuid!
  user_id: uuid!
}

"""
select columns of table "organization_member"
"""
enum organization_member_select_column {
  """column name"""
  organization_id

  """column name"""
  role

  """column name"""
  user_id
}

"""
input type for updating data in table "organization_member"
"""
input organization_member_set_input {
  organization_id: uuid
  role: role_enum
  user_id: uuid
}

"""
Streaming cursor of the table "organization_member"
"""
input organization_member_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: organization_member_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input organization_member_stream_cursor_value_input {
  organization_id: uuid
  role: role_enum
  user_id: uuid
}

"""
update columns of table "organization_member"
"""
enum organization_member_update_column {
  """column name"""
  organization_id

  """column name"""
  role

  """column name"""
  user_id
}

input organization_member_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: organization_member_set_input

  """filter the rows which have to be updated"""
  where: organization_member_bool_exp!
}

"""aggregate min on columns"""
type organization_min_fields {
  branding_id: uuid
  business_model_id: uuid
  currency: String
  email: String
  headline_id: uuid
  id: uuid
  language: String
  name: String
  phone_number: String
  socials_id: uuid
}

"""
response of any mutation on the table "organization"
"""
type organization_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [organization!]!
}

"""
input type for inserting object relation for remote table "organization"
"""
input organization_obj_rel_insert_input {
  data: organization_insert_input!

  """upsert condition"""
  on_conflict: organization_on_conflict
}

"""
on_conflict condition type for table "organization"
"""
input organization_on_conflict {
  constraint: organization_constraint!
  update_columns: [organization_update_column!]! = []
  where: organization_bool_exp
}

"""Ordering options when selecting data from "organization"."""
input organization_order_by {
  booking_questions_aggregate: organization_booking_question_aggregate_order_by
  bookings_aggregate: booking_aggregate_order_by
  branding: organization_branding_order_by
  branding_id: order_by
  business_model: organization_business_model_order_by
  business_model_id: order_by
  contacts_aggregate: contact_aggregate_order_by
  currency: order_by
  email: order_by
  features_aggregate: feature_aggregate_order_by
  headline: organization_headline_order_by
  headline_id: order_by
  id: order_by
  language: order_by
  members_aggregate: organization_member_aggregate_order_by
  name: order_by
  phone_number: order_by
  product_groups_aggregate: product_group_aggregate_order_by
  products_aggregate: product_aggregate_order_by
  sections_aggregate: my_web_section_aggregate_order_by
  sites_aggregate: site_aggregate_order_by
  socials: organization_socials_order_by
  socials_id: order_by
  supplements_aggregate: supplement_aggregate_order_by
  venues_aggregate: venue_aggregate_order_by
}

"""primary key columns input for table: organization"""
input organization_pk_columns_input {
  id: uuid!
}

"""
select columns of table "organization"
"""
enum organization_select_column {
  """column name"""
  branding_id

  """column name"""
  business_model_id

  """column name"""
  currency

  """column name"""
  email

  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  language

  """column name"""
  name

  """column name"""
  phone_number

  """column name"""
  socials_id
}

"""
input type for updating data in table "organization"
"""
input organization_set_input {
  branding_id: uuid
  business_model_id: uuid
  currency: String
  email: String
  headline_id: uuid
  id: uuid
  language: String
  name: String
  phone_number: String
  socials_id: uuid
}

input organization_settings_save_input {
  email: String
  headline: multilanguage_field_input!
  id: uuid!
  name: String!
  phone_number: String
  sites: [organization_site_input!]
  socials: organization_socials_input!
}

input organization_site_input {
  id: uuid
  url: String!
}

"""
columns and relationships of "organization_socials"
"""
type organization_socials {
  facebook: String
  id: uuid!
  instagram: String
  twitter: String
  youtube: String
}

"""
aggregated selection of "organization_socials"
"""
type organization_socials_aggregate {
  aggregate: organization_socials_aggregate_fields
  nodes: [organization_socials!]!
}

"""
aggregate fields of "organization_socials"
"""
type organization_socials_aggregate_fields {
  count(columns: [organization_socials_select_column!], distinct: Boolean): Int!
  max: organization_socials_max_fields
  min: organization_socials_min_fields
}

"""
Boolean expression to filter rows from the table "organization_socials". All fields are combined with a logical 'AND'.
"""
input organization_socials_bool_exp {
  _and: [organization_socials_bool_exp!]
  _not: organization_socials_bool_exp
  _or: [organization_socials_bool_exp!]
  facebook: String_comparison_exp
  id: uuid_comparison_exp
  instagram: String_comparison_exp
  twitter: String_comparison_exp
  youtube: String_comparison_exp
}

"""
unique or primary key constraints on table "organization_socials"
"""
enum organization_socials_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  organization_socials_pkey
}

input organization_socials_input {
  facebook: String
  id: uuid
  instagram: String
  twitter: String
  youtube: String
}

"""
input type for inserting data into table "organization_socials"
"""
input organization_socials_insert_input {
  facebook: String
  id: uuid
  instagram: String
  twitter: String
  youtube: String
}

"""aggregate max on columns"""
type organization_socials_max_fields {
  facebook: String
  id: uuid
  instagram: String
  twitter: String
  youtube: String
}

"""aggregate min on columns"""
type organization_socials_min_fields {
  facebook: String
  id: uuid
  instagram: String
  twitter: String
  youtube: String
}

"""
response of any mutation on the table "organization_socials"
"""
type organization_socials_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [organization_socials!]!
}

"""
input type for inserting object relation for remote table "organization_socials"
"""
input organization_socials_obj_rel_insert_input {
  data: organization_socials_insert_input!

  """upsert condition"""
  on_conflict: organization_socials_on_conflict
}

"""
on_conflict condition type for table "organization_socials"
"""
input organization_socials_on_conflict {
  constraint: organization_socials_constraint!
  update_columns: [organization_socials_update_column!]! = []
  where: organization_socials_bool_exp
}

"""Ordering options when selecting data from "organization_socials"."""
input organization_socials_order_by {
  facebook: order_by
  id: order_by
  instagram: order_by
  twitter: order_by
  youtube: order_by
}

"""primary key columns input for table: organization_socials"""
input organization_socials_pk_columns_input {
  id: uuid!
}

"""
select columns of table "organization_socials"
"""
enum organization_socials_select_column {
  """column name"""
  facebook

  """column name"""
  id

  """column name"""
  instagram

  """column name"""
  twitter

  """column name"""
  youtube
}

"""
input type for updating data in table "organization_socials"
"""
input organization_socials_set_input {
  facebook: String
  id: uuid
  instagram: String
  twitter: String
  youtube: String
}

"""
Streaming cursor of the table "organization_socials"
"""
input organization_socials_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: organization_socials_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input organization_socials_stream_cursor_value_input {
  facebook: String
  id: uuid
  instagram: String
  twitter: String
  youtube: String
}

"""
update columns of table "organization_socials"
"""
enum organization_socials_update_column {
  """column name"""
  facebook

  """column name"""
  id

  """column name"""
  instagram

  """column name"""
  twitter

  """column name"""
  youtube
}

input organization_socials_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: organization_socials_set_input

  """filter the rows which have to be updated"""
  where: organization_socials_bool_exp!
}

"""
Streaming cursor of the table "organization"
"""
input organization_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: organization_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input organization_stream_cursor_value_input {
  branding_id: uuid
  business_model_id: uuid
  currency: String
  email: String
  headline_id: uuid
  id: uuid
  language: String
  name: String
  phone_number: String
  socials_id: uuid
}

"""
update columns of table "organization"
"""
enum organization_update_column {
  """column name"""
  branding_id

  """column name"""
  business_model_id

  """column name"""
  currency

  """column name"""
  email

  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  language

  """column name"""
  name

  """column name"""
  phone_number

  """column name"""
  socials_id
}

input organization_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: organization_set_input

  """filter the rows which have to be updated"""
  where: organization_bool_exp!
}

input person_input {
  age: numeric
}

"""
columns and relationships of "place"
"""
type place {
  id: uuid!
  latitude: numeric!
  longitude: numeric!
  name: String!
}

"""
aggregated selection of "place"
"""
type place_aggregate {
  aggregate: place_aggregate_fields
  nodes: [place!]!
}

"""
aggregate fields of "place"
"""
type place_aggregate_fields {
  avg: place_avg_fields
  count(columns: [place_select_column!], distinct: Boolean): Int!
  max: place_max_fields
  min: place_min_fields
  stddev: place_stddev_fields
  stddev_pop: place_stddev_pop_fields
  stddev_samp: place_stddev_samp_fields
  sum: place_sum_fields
  var_pop: place_var_pop_fields
  var_samp: place_var_samp_fields
  variance: place_variance_fields
}

"""aggregate avg on columns"""
type place_avg_fields {
  latitude: Float
  longitude: Float
}

"""
Boolean expression to filter rows from the table "place". All fields are combined with a logical 'AND'.
"""
input place_bool_exp {
  _and: [place_bool_exp!]
  _not: place_bool_exp
  _or: [place_bool_exp!]
  id: uuid_comparison_exp
  latitude: numeric_comparison_exp
  longitude: numeric_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "place"
"""
enum place_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  place_pkey
}

"""
input type for incrementing numeric columns in table "place"
"""
input place_inc_input {
  latitude: numeric
  longitude: numeric
}

input place_input {
  latitude: numeric
  longitude: numeric
  name: String
}

"""
input type for inserting data into table "place"
"""
input place_insert_input {
  id: uuid
  latitude: numeric
  longitude: numeric
  name: String
}

"""aggregate max on columns"""
type place_max_fields {
  id: uuid
  latitude: numeric
  longitude: numeric
  name: String
}

"""aggregate min on columns"""
type place_min_fields {
  id: uuid
  latitude: numeric
  longitude: numeric
  name: String
}

"""
response of any mutation on the table "place"
"""
type place_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [place!]!
}

"""
input type for inserting object relation for remote table "place"
"""
input place_obj_rel_insert_input {
  data: place_insert_input!

  """upsert condition"""
  on_conflict: place_on_conflict
}

"""
on_conflict condition type for table "place"
"""
input place_on_conflict {
  constraint: place_constraint!
  update_columns: [place_update_column!]! = []
  where: place_bool_exp
}

"""Ordering options when selecting data from "place"."""
input place_order_by {
  id: order_by
  latitude: order_by
  longitude: order_by
  name: order_by
}

"""primary key columns input for table: place"""
input place_pk_columns_input {
  id: uuid!
}

"""
select columns of table "place"
"""
enum place_select_column {
  """column name"""
  id

  """column name"""
  latitude

  """column name"""
  longitude

  """column name"""
  name
}

"""
input type for updating data in table "place"
"""
input place_set_input {
  id: uuid
  latitude: numeric
  longitude: numeric
  name: String
}

"""aggregate stddev on columns"""
type place_stddev_fields {
  latitude: Float
  longitude: Float
}

"""aggregate stddev_pop on columns"""
type place_stddev_pop_fields {
  latitude: Float
  longitude: Float
}

"""aggregate stddev_samp on columns"""
type place_stddev_samp_fields {
  latitude: Float
  longitude: Float
}

"""
Streaming cursor of the table "place"
"""
input place_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: place_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input place_stream_cursor_value_input {
  id: uuid
  latitude: numeric
  longitude: numeric
  name: String
}

"""aggregate sum on columns"""
type place_sum_fields {
  latitude: numeric
  longitude: numeric
}

"""
update columns of table "place"
"""
enum place_update_column {
  """column name"""
  id

  """column name"""
  latitude

  """column name"""
  longitude

  """column name"""
  name
}

input place_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: place_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: place_set_input

  """filter the rows which have to be updated"""
  where: place_bool_exp!
}

"""aggregate var_pop on columns"""
type place_var_pop_fields {
  latitude: Float
  longitude: Float
}

"""aggregate var_samp on columns"""
type place_var_samp_fields {
  latitude: Float
  longitude: Float
}

"""aggregate variance on columns"""
type place_variance_fields {
  latitude: Float
  longitude: Float
}

"""
columns and relationships of "product"
"""
type product {
  """An array relationship"""
  allotment_calendar(
    """distinct select on columns"""
    distinct_on: [product_allotment_range_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_allotment_range_order_by!]

    """filter the rows returned"""
    where: product_allotment_range_bool_exp
  ): [product_allotment_range!]!

  """An aggregate relationship"""
  allotment_calendar_aggregate(
    """distinct select on columns"""
    distinct_on: [product_allotment_range_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_allotment_range_order_by!]

    """filter the rows returned"""
    where: product_allotment_range_bool_exp
  ): product_allotment_range_aggregate!

  """An object relationship"""
  business_model: product_business_model
  business_model_id: uuid

  """An object relationship"""
  description: product_description!
  description_id: uuid!

  """An array relationship"""
  features(
    """distinct select on columns"""
    distinct_on: [product_feature_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_feature_order_by!]

    """filter the rows returned"""
    where: product_feature_bool_exp
  ): [product_feature!]!

  """An aggregate relationship"""
  features_aggregate(
    """distinct select on columns"""
    distinct_on: [product_feature_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_feature_order_by!]

    """filter the rows returned"""
    where: product_feature_bool_exp
  ): product_feature_aggregate!

  """An object relationship"""
  gallery: media_gallery!
  gallery_id: uuid!

  """An object relationship"""
  headline: product_headline!
  headline_id: uuid!
  id: uuid!

  """An object relationship"""
  name: product_name!
  name_id: uuid!

  """An object relationship"""
  organization: organization!
  organization_id: uuid!

  """An object relationship"""
  place: place
  place_id: uuid
  price_from: numeric!
  published: Boolean!

  """An array relationship"""
  rates(
    """distinct select on columns"""
    distinct_on: [rate_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_order_by!]

    """filter the rows returned"""
    where: rate_bool_exp
  ): [rate!]!

  """An aggregate relationship"""
  rates_aggregate(
    """distinct select on columns"""
    distinct_on: [rate_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_order_by!]

    """filter the rows returned"""
    where: rate_bool_exp
  ): rate_aggregate!

  """An object relationship"""
  slug: slug!
  slug_id: uuid!

  """An array relationship"""
  supplements(
    """distinct select on columns"""
    distinct_on: [product_supplement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_supplement_order_by!]

    """filter the rows returned"""
    where: product_supplement_bool_exp
  ): [product_supplement!]!

  """An aggregate relationship"""
  supplements_aggregate(
    """distinct select on columns"""
    distinct_on: [product_supplement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_supplement_order_by!]

    """filter the rows returned"""
    where: product_supplement_bool_exp
  ): product_supplement_aggregate!
}

"""
aggregated selection of "product"
"""
type product_aggregate {
  aggregate: product_aggregate_fields
  nodes: [product!]!
}

input product_aggregate_bool_exp {
  bool_and: product_aggregate_bool_exp_bool_and
  bool_or: product_aggregate_bool_exp_bool_or
  count: product_aggregate_bool_exp_count
}

input product_aggregate_bool_exp_bool_and {
  arguments: product_select_column_product_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: product_bool_exp
  predicate: Boolean_comparison_exp!
}

input product_aggregate_bool_exp_bool_or {
  arguments: product_select_column_product_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: product_bool_exp
  predicate: Boolean_comparison_exp!
}

input product_aggregate_bool_exp_count {
  arguments: [product_select_column!]
  distinct: Boolean
  filter: product_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "product"
"""
type product_aggregate_fields {
  avg: product_avg_fields
  count(columns: [product_select_column!], distinct: Boolean): Int!
  max: product_max_fields
  min: product_min_fields
  stddev: product_stddev_fields
  stddev_pop: product_stddev_pop_fields
  stddev_samp: product_stddev_samp_fields
  sum: product_sum_fields
  var_pop: product_var_pop_fields
  var_samp: product_var_samp_fields
  variance: product_variance_fields
}

"""
order by aggregate values of table "product"
"""
input product_aggregate_order_by {
  avg: product_avg_order_by
  count: order_by
  max: product_max_order_by
  min: product_min_order_by
  stddev: product_stddev_order_by
  stddev_pop: product_stddev_pop_order_by
  stddev_samp: product_stddev_samp_order_by
  sum: product_sum_order_by
  var_pop: product_var_pop_order_by
  var_samp: product_var_samp_order_by
  variance: product_variance_order_by
}

"""
columns and relationships of "product_allotment_range"
"""
type product_allotment_range {
  from: timestamp!
  id: uuid!

  """An object relationship"""
  product: product!
  product_id: uuid!
  to: timestamp!
  value: Int!
}

"""
aggregated selection of "product_allotment_range"
"""
type product_allotment_range_aggregate {
  aggregate: product_allotment_range_aggregate_fields
  nodes: [product_allotment_range!]!
}

input product_allotment_range_aggregate_bool_exp {
  count: product_allotment_range_aggregate_bool_exp_count
}

input product_allotment_range_aggregate_bool_exp_count {
  arguments: [product_allotment_range_select_column!]
  distinct: Boolean
  filter: product_allotment_range_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "product_allotment_range"
"""
type product_allotment_range_aggregate_fields {
  avg: product_allotment_range_avg_fields
  count(columns: [product_allotment_range_select_column!], distinct: Boolean): Int!
  max: product_allotment_range_max_fields
  min: product_allotment_range_min_fields
  stddev: product_allotment_range_stddev_fields
  stddev_pop: product_allotment_range_stddev_pop_fields
  stddev_samp: product_allotment_range_stddev_samp_fields
  sum: product_allotment_range_sum_fields
  var_pop: product_allotment_range_var_pop_fields
  var_samp: product_allotment_range_var_samp_fields
  variance: product_allotment_range_variance_fields
}

"""
order by aggregate values of table "product_allotment_range"
"""
input product_allotment_range_aggregate_order_by {
  avg: product_allotment_range_avg_order_by
  count: order_by
  max: product_allotment_range_max_order_by
  min: product_allotment_range_min_order_by
  stddev: product_allotment_range_stddev_order_by
  stddev_pop: product_allotment_range_stddev_pop_order_by
  stddev_samp: product_allotment_range_stddev_samp_order_by
  sum: product_allotment_range_sum_order_by
  var_pop: product_allotment_range_var_pop_order_by
  var_samp: product_allotment_range_var_samp_order_by
  variance: product_allotment_range_variance_order_by
}

"""
input type for inserting array relation for remote table "product_allotment_range"
"""
input product_allotment_range_arr_rel_insert_input {
  data: [product_allotment_range_insert_input!]!

  """upsert condition"""
  on_conflict: product_allotment_range_on_conflict
}

"""aggregate avg on columns"""
type product_allotment_range_avg_fields {
  value: Float
}

"""
order by avg() on columns of table "product_allotment_range"
"""
input product_allotment_range_avg_order_by {
  value: order_by
}

"""
Boolean expression to filter rows from the table "product_allotment_range". All fields are combined with a logical 'AND'.
"""
input product_allotment_range_bool_exp {
  _and: [product_allotment_range_bool_exp!]
  _not: product_allotment_range_bool_exp
  _or: [product_allotment_range_bool_exp!]
  from: timestamp_comparison_exp
  id: uuid_comparison_exp
  product: product_bool_exp
  product_id: uuid_comparison_exp
  to: timestamp_comparison_exp
  value: Int_comparison_exp
}

"""
unique or primary key constraints on table "product_allotment_range"
"""
enum product_allotment_range_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  product_allotment_range_pkey
}

"""
input type for incrementing numeric columns in table "product_allotment_range"
"""
input product_allotment_range_inc_input {
  value: Int
}

"""
input type for inserting data into table "product_allotment_range"
"""
input product_allotment_range_insert_input {
  from: timestamp
  id: uuid
  product: product_obj_rel_insert_input
  product_id: uuid
  to: timestamp
  value: Int
}

"""aggregate max on columns"""
type product_allotment_range_max_fields {
  from: timestamp
  id: uuid
  product_id: uuid
  to: timestamp
  value: Int
}

"""
order by max() on columns of table "product_allotment_range"
"""
input product_allotment_range_max_order_by {
  from: order_by
  id: order_by
  product_id: order_by
  to: order_by
  value: order_by
}

"""aggregate min on columns"""
type product_allotment_range_min_fields {
  from: timestamp
  id: uuid
  product_id: uuid
  to: timestamp
  value: Int
}

"""
order by min() on columns of table "product_allotment_range"
"""
input product_allotment_range_min_order_by {
  from: order_by
  id: order_by
  product_id: order_by
  to: order_by
  value: order_by
}

"""
response of any mutation on the table "product_allotment_range"
"""
type product_allotment_range_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_allotment_range!]!
}

"""
on_conflict condition type for table "product_allotment_range"
"""
input product_allotment_range_on_conflict {
  constraint: product_allotment_range_constraint!
  update_columns: [product_allotment_range_update_column!]! = []
  where: product_allotment_range_bool_exp
}

"""Ordering options when selecting data from "product_allotment_range"."""
input product_allotment_range_order_by {
  from: order_by
  id: order_by
  product: product_order_by
  product_id: order_by
  to: order_by
  value: order_by
}

"""primary key columns input for table: product_allotment_range"""
input product_allotment_range_pk_columns_input {
  id: uuid!
}

"""
select columns of table "product_allotment_range"
"""
enum product_allotment_range_select_column {
  """column name"""
  from

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  to

  """column name"""
  value
}

"""
input type for updating data in table "product_allotment_range"
"""
input product_allotment_range_set_input {
  from: timestamp
  id: uuid
  product_id: uuid
  to: timestamp
  value: Int
}

"""aggregate stddev on columns"""
type product_allotment_range_stddev_fields {
  value: Float
}

"""
order by stddev() on columns of table "product_allotment_range"
"""
input product_allotment_range_stddev_order_by {
  value: order_by
}

"""aggregate stddev_pop on columns"""
type product_allotment_range_stddev_pop_fields {
  value: Float
}

"""
order by stddev_pop() on columns of table "product_allotment_range"
"""
input product_allotment_range_stddev_pop_order_by {
  value: order_by
}

"""aggregate stddev_samp on columns"""
type product_allotment_range_stddev_samp_fields {
  value: Float
}

"""
order by stddev_samp() on columns of table "product_allotment_range"
"""
input product_allotment_range_stddev_samp_order_by {
  value: order_by
}

"""
Streaming cursor of the table "product_allotment_range"
"""
input product_allotment_range_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_allotment_range_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_allotment_range_stream_cursor_value_input {
  from: timestamp
  id: uuid
  product_id: uuid
  to: timestamp
  value: Int
}

"""aggregate sum on columns"""
type product_allotment_range_sum_fields {
  value: Int
}

"""
order by sum() on columns of table "product_allotment_range"
"""
input product_allotment_range_sum_order_by {
  value: order_by
}

"""
update columns of table "product_allotment_range"
"""
enum product_allotment_range_update_column {
  """column name"""
  from

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  to

  """column name"""
  value
}

input product_allotment_range_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: product_allotment_range_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: product_allotment_range_set_input

  """filter the rows which have to be updated"""
  where: product_allotment_range_bool_exp!
}

"""aggregate var_pop on columns"""
type product_allotment_range_var_pop_fields {
  value: Float
}

"""
order by var_pop() on columns of table "product_allotment_range"
"""
input product_allotment_range_var_pop_order_by {
  value: order_by
}

"""aggregate var_samp on columns"""
type product_allotment_range_var_samp_fields {
  value: Float
}

"""
order by var_samp() on columns of table "product_allotment_range"
"""
input product_allotment_range_var_samp_order_by {
  value: order_by
}

"""aggregate variance on columns"""
type product_allotment_range_variance_fields {
  value: Float
}

"""
order by variance() on columns of table "product_allotment_range"
"""
input product_allotment_range_variance_order_by {
  value: order_by
}

input product_and_pax_questions_answers {
  adults: [[booking_question_answer!]!]!
  children: [[booking_question_answer!]!]!
  product_anwers: [booking_question_answer!]!
}

"""
input type for inserting array relation for remote table "product"
"""
input product_arr_rel_insert_input {
  data: [product_insert_input!]!

  """upsert condition"""
  on_conflict: product_on_conflict
}

"""aggregate avg on columns"""
type product_avg_fields {
  price_from: Float
}

"""
order by avg() on columns of table "product"
"""
input product_avg_order_by {
  price_from: order_by
}

"""
Boolean expression to filter rows from the table "product". All fields are combined with a logical 'AND'.
"""
input product_bool_exp {
  _and: [product_bool_exp!]
  _not: product_bool_exp
  _or: [product_bool_exp!]
  allotment_calendar: product_allotment_range_bool_exp
  allotment_calendar_aggregate: product_allotment_range_aggregate_bool_exp
  business_model: product_business_model_bool_exp
  business_model_id: uuid_comparison_exp
  description: product_description_bool_exp
  description_id: uuid_comparison_exp
  features: product_feature_bool_exp
  features_aggregate: product_feature_aggregate_bool_exp
  gallery: media_gallery_bool_exp
  gallery_id: uuid_comparison_exp
  headline: product_headline_bool_exp
  headline_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: product_name_bool_exp
  name_id: uuid_comparison_exp
  organization: organization_bool_exp
  organization_id: uuid_comparison_exp
  place: place_bool_exp
  place_id: uuid_comparison_exp
  price_from: numeric_comparison_exp
  published: Boolean_comparison_exp
  rates: rate_bool_exp
  rates_aggregate: rate_aggregate_bool_exp
  slug: slug_bool_exp
  slug_id: uuid_comparison_exp
  supplements: product_supplement_bool_exp
  supplements_aggregate: product_supplement_aggregate_bool_exp
}

"""
columns and relationships of "product_business_model"
"""
type product_business_model {
  id: uuid!
  time_management: rate_type_enum!
  unit_management: unit_management_enum!
}

"""
aggregated selection of "product_business_model"
"""
type product_business_model_aggregate {
  aggregate: product_business_model_aggregate_fields
  nodes: [product_business_model!]!
}

"""
aggregate fields of "product_business_model"
"""
type product_business_model_aggregate_fields {
  count(columns: [product_business_model_select_column!], distinct: Boolean): Int!
  max: product_business_model_max_fields
  min: product_business_model_min_fields
}

"""
Boolean expression to filter rows from the table "product_business_model". All fields are combined with a logical 'AND'.
"""
input product_business_model_bool_exp {
  _and: [product_business_model_bool_exp!]
  _not: product_business_model_bool_exp
  _or: [product_business_model_bool_exp!]
  id: uuid_comparison_exp
  time_management: rate_type_enum_comparison_exp
  unit_management: unit_management_enum_comparison_exp
}

"""
unique or primary key constraints on table "product_business_model"
"""
enum product_business_model_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  product_business_model_pkey
}

"""
input type for inserting data into table "product_business_model"
"""
input product_business_model_insert_input {
  id: uuid
  time_management: rate_type_enum
  unit_management: unit_management_enum
}

"""aggregate max on columns"""
type product_business_model_max_fields {
  id: uuid
}

"""aggregate min on columns"""
type product_business_model_min_fields {
  id: uuid
}

"""
response of any mutation on the table "product_business_model"
"""
type product_business_model_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_business_model!]!
}

"""
input type for inserting object relation for remote table "product_business_model"
"""
input product_business_model_obj_rel_insert_input {
  data: product_business_model_insert_input!

  """upsert condition"""
  on_conflict: product_business_model_on_conflict
}

"""
on_conflict condition type for table "product_business_model"
"""
input product_business_model_on_conflict {
  constraint: product_business_model_constraint!
  update_columns: [product_business_model_update_column!]! = []
  where: product_business_model_bool_exp
}

"""Ordering options when selecting data from "product_business_model"."""
input product_business_model_order_by {
  id: order_by
  time_management: order_by
  unit_management: order_by
}

"""primary key columns input for table: product_business_model"""
input product_business_model_pk_columns_input {
  id: uuid!
}

"""
select columns of table "product_business_model"
"""
enum product_business_model_select_column {
  """column name"""
  id

  """column name"""
  time_management

  """column name"""
  unit_management
}

"""
input type for updating data in table "product_business_model"
"""
input product_business_model_set_input {
  id: uuid
  time_management: rate_type_enum
  unit_management: unit_management_enum
}

"""
Streaming cursor of the table "product_business_model"
"""
input product_business_model_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_business_model_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_business_model_stream_cursor_value_input {
  id: uuid
  time_management: rate_type_enum
  unit_management: unit_management_enum
}

"""
update columns of table "product_business_model"
"""
enum product_business_model_update_column {
  """column name"""
  id

  """column name"""
  time_management

  """column name"""
  unit_management
}

input product_business_model_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: product_business_model_set_input

  """filter the rows which have to be updated"""
  where: product_business_model_bool_exp!
}

"""
unique or primary key constraints on table "product"
"""
enum product_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  product_content_pkey
}

input product_create_input {
  id: uuid!
  organization_id: uuid!
}

"""
columns and relationships of "product_description"
"""
type product_description {
  de: String
  en: String
  es: String
  fr: String
  id: uuid!
}

"""
aggregated selection of "product_description"
"""
type product_description_aggregate {
  aggregate: product_description_aggregate_fields
  nodes: [product_description!]!
}

"""
aggregate fields of "product_description"
"""
type product_description_aggregate_fields {
  count(columns: [product_description_select_column!], distinct: Boolean): Int!
  max: product_description_max_fields
  min: product_description_min_fields
}

"""
Boolean expression to filter rows from the table "product_description". All fields are combined with a logical 'AND'.
"""
input product_description_bool_exp {
  _and: [product_description_bool_exp!]
  _not: product_description_bool_exp
  _or: [product_description_bool_exp!]
  de: String_comparison_exp
  en: String_comparison_exp
  es: String_comparison_exp
  fr: String_comparison_exp
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "product_description"
"""
enum product_description_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  product_description_pkey
}

"""
input type for inserting data into table "product_description"
"""
input product_description_insert_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate max on columns"""
type product_description_max_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate min on columns"""
type product_description_min_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
response of any mutation on the table "product_description"
"""
type product_description_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_description!]!
}

"""
input type for inserting object relation for remote table "product_description"
"""
input product_description_obj_rel_insert_input {
  data: product_description_insert_input!

  """upsert condition"""
  on_conflict: product_description_on_conflict
}

"""
on_conflict condition type for table "product_description"
"""
input product_description_on_conflict {
  constraint: product_description_constraint!
  update_columns: [product_description_update_column!]! = []
  where: product_description_bool_exp
}

"""Ordering options when selecting data from "product_description"."""
input product_description_order_by {
  de: order_by
  en: order_by
  es: order_by
  fr: order_by
  id: order_by
}

"""primary key columns input for table: product_description"""
input product_description_pk_columns_input {
  id: uuid!
}

"""
select columns of table "product_description"
"""
enum product_description_select_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

"""
input type for updating data in table "product_description"
"""
input product_description_set_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
Streaming cursor of the table "product_description"
"""
input product_description_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_description_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_description_stream_cursor_value_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
update columns of table "product_description"
"""
enum product_description_update_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

input product_description_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: product_description_set_input

  """filter the rows which have to be updated"""
  where: product_description_bool_exp!
}

"""
columns and relationships of "product_feature"
"""
type product_feature {
  """An object relationship"""
  feature: feature!
  feature_id: uuid!
  position: numeric!

  """An object relationship"""
  product: product!
  product_id: uuid!
  value(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "product_feature"
"""
type product_feature_aggregate {
  aggregate: product_feature_aggregate_fields
  nodes: [product_feature!]!
}

input product_feature_aggregate_bool_exp {
  count: product_feature_aggregate_bool_exp_count
}

input product_feature_aggregate_bool_exp_count {
  arguments: [product_feature_select_column!]
  distinct: Boolean
  filter: product_feature_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "product_feature"
"""
type product_feature_aggregate_fields {
  avg: product_feature_avg_fields
  count(columns: [product_feature_select_column!], distinct: Boolean): Int!
  max: product_feature_max_fields
  min: product_feature_min_fields
  stddev: product_feature_stddev_fields
  stddev_pop: product_feature_stddev_pop_fields
  stddev_samp: product_feature_stddev_samp_fields
  sum: product_feature_sum_fields
  var_pop: product_feature_var_pop_fields
  var_samp: product_feature_var_samp_fields
  variance: product_feature_variance_fields
}

"""
order by aggregate values of table "product_feature"
"""
input product_feature_aggregate_order_by {
  avg: product_feature_avg_order_by
  count: order_by
  max: product_feature_max_order_by
  min: product_feature_min_order_by
  stddev: product_feature_stddev_order_by
  stddev_pop: product_feature_stddev_pop_order_by
  stddev_samp: product_feature_stddev_samp_order_by
  sum: product_feature_sum_order_by
  var_pop: product_feature_var_pop_order_by
  var_samp: product_feature_var_samp_order_by
  variance: product_feature_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input product_feature_append_input {
  value: jsonb
}

"""
input type for inserting array relation for remote table "product_feature"
"""
input product_feature_arr_rel_insert_input {
  data: [product_feature_insert_input!]!

  """upsert condition"""
  on_conflict: product_feature_on_conflict
}

"""aggregate avg on columns"""
type product_feature_avg_fields {
  position: Float
}

"""
order by avg() on columns of table "product_feature"
"""
input product_feature_avg_order_by {
  position: order_by
}

"""
Boolean expression to filter rows from the table "product_feature". All fields are combined with a logical 'AND'.
"""
input product_feature_bool_exp {
  _and: [product_feature_bool_exp!]
  _not: product_feature_bool_exp
  _or: [product_feature_bool_exp!]
  feature: feature_bool_exp
  feature_id: uuid_comparison_exp
  position: numeric_comparison_exp
  product: product_bool_exp
  product_id: uuid_comparison_exp
  value: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "product_feature"
"""
enum product_feature_constraint {
  """
  unique or primary key constraint on columns "product_id", "feature_id"
  """
  product_feature_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input product_feature_delete_at_path_input {
  value: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input product_feature_delete_elem_input {
  value: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input product_feature_delete_key_input {
  value: String
}

"""
input type for incrementing numeric columns in table "product_feature"
"""
input product_feature_inc_input {
  position: numeric
}

"""
input type for inserting data into table "product_feature"
"""
input product_feature_insert_input {
  feature: feature_obj_rel_insert_input
  feature_id: uuid
  position: numeric
  product: product_obj_rel_insert_input
  product_id: uuid
  value: jsonb
}

"""aggregate max on columns"""
type product_feature_max_fields {
  feature_id: uuid
  position: numeric
  product_id: uuid
}

"""
order by max() on columns of table "product_feature"
"""
input product_feature_max_order_by {
  feature_id: order_by
  position: order_by
  product_id: order_by
}

"""aggregate min on columns"""
type product_feature_min_fields {
  feature_id: uuid
  position: numeric
  product_id: uuid
}

"""
order by min() on columns of table "product_feature"
"""
input product_feature_min_order_by {
  feature_id: order_by
  position: order_by
  product_id: order_by
}

"""
response of any mutation on the table "product_feature"
"""
type product_feature_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_feature!]!
}

"""
on_conflict condition type for table "product_feature"
"""
input product_feature_on_conflict {
  constraint: product_feature_constraint!
  update_columns: [product_feature_update_column!]! = []
  where: product_feature_bool_exp
}

"""Ordering options when selecting data from "product_feature"."""
input product_feature_order_by {
  feature: feature_order_by
  feature_id: order_by
  position: order_by
  product: product_order_by
  product_id: order_by
  value: order_by
}

"""primary key columns input for table: product_feature"""
input product_feature_pk_columns_input {
  feature_id: uuid!
  product_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input product_feature_prepend_input {
  value: jsonb
}

"""
select columns of table "product_feature"
"""
enum product_feature_select_column {
  """column name"""
  feature_id

  """column name"""
  position

  """column name"""
  product_id

  """column name"""
  value
}

"""
input type for updating data in table "product_feature"
"""
input product_feature_set_input {
  feature_id: uuid
  position: numeric
  product_id: uuid
  value: jsonb
}

"""aggregate stddev on columns"""
type product_feature_stddev_fields {
  position: Float
}

"""
order by stddev() on columns of table "product_feature"
"""
input product_feature_stddev_order_by {
  position: order_by
}

"""aggregate stddev_pop on columns"""
type product_feature_stddev_pop_fields {
  position: Float
}

"""
order by stddev_pop() on columns of table "product_feature"
"""
input product_feature_stddev_pop_order_by {
  position: order_by
}

"""aggregate stddev_samp on columns"""
type product_feature_stddev_samp_fields {
  position: Float
}

"""
order by stddev_samp() on columns of table "product_feature"
"""
input product_feature_stddev_samp_order_by {
  position: order_by
}

"""
Streaming cursor of the table "product_feature"
"""
input product_feature_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_feature_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_feature_stream_cursor_value_input {
  feature_id: uuid
  position: numeric
  product_id: uuid
  value: jsonb
}

"""aggregate sum on columns"""
type product_feature_sum_fields {
  position: numeric
}

"""
order by sum() on columns of table "product_feature"
"""
input product_feature_sum_order_by {
  position: order_by
}

"""
update columns of table "product_feature"
"""
enum product_feature_update_column {
  """column name"""
  feature_id

  """column name"""
  position

  """column name"""
  product_id

  """column name"""
  value
}

input product_feature_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: product_feature_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: product_feature_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: product_feature_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: product_feature_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: product_feature_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: product_feature_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: product_feature_set_input

  """filter the rows which have to be updated"""
  where: product_feature_bool_exp!
}

"""aggregate var_pop on columns"""
type product_feature_var_pop_fields {
  position: Float
}

"""
order by var_pop() on columns of table "product_feature"
"""
input product_feature_var_pop_order_by {
  position: order_by
}

"""aggregate var_samp on columns"""
type product_feature_var_samp_fields {
  position: Float
}

"""
order by var_samp() on columns of table "product_feature"
"""
input product_feature_var_samp_order_by {
  position: order_by
}

"""aggregate variance on columns"""
type product_feature_variance_fields {
  position: Float
}

"""
order by variance() on columns of table "product_feature"
"""
input product_feature_variance_order_by {
  position: order_by
}

"""
columns and relationships of "product_group"
"""
type product_group {
  """An object relationship"""
  description: translated_text
  description_id: uuid!

  """An object relationship"""
  headline: translated_text
  headline_id: uuid!
  id: uuid!

  """An object relationship"""
  image: files
  image_id: uuid

  """An object relationship"""
  name: translated_text!
  name_id: uuid!

  """An object relationship"""
  organization: organization!
  organization_id: uuid!

  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [product_group_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_group_product_order_by!]

    """filter the rows returned"""
    where: product_group_product_bool_exp
  ): [product_group_product!]!

  """An aggregate relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [product_group_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_group_product_order_by!]

    """filter the rows returned"""
    where: product_group_product_bool_exp
  ): product_group_product_aggregate!

  """An object relationship"""
  slug: slug!
  slug_id: uuid!
}

"""
aggregated selection of "product_group"
"""
type product_group_aggregate {
  aggregate: product_group_aggregate_fields
  nodes: [product_group!]!
}

input product_group_aggregate_bool_exp {
  count: product_group_aggregate_bool_exp_count
}

input product_group_aggregate_bool_exp_count {
  arguments: [product_group_select_column!]
  distinct: Boolean
  filter: product_group_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "product_group"
"""
type product_group_aggregate_fields {
  count(columns: [product_group_select_column!], distinct: Boolean): Int!
  max: product_group_max_fields
  min: product_group_min_fields
}

"""
order by aggregate values of table "product_group"
"""
input product_group_aggregate_order_by {
  count: order_by
  max: product_group_max_order_by
  min: product_group_min_order_by
}

"""
input type for inserting array relation for remote table "product_group"
"""
input product_group_arr_rel_insert_input {
  data: [product_group_insert_input!]!

  """upsert condition"""
  on_conflict: product_group_on_conflict
}

"""
Boolean expression to filter rows from the table "product_group". All fields are combined with a logical 'AND'.
"""
input product_group_bool_exp {
  _and: [product_group_bool_exp!]
  _not: product_group_bool_exp
  _or: [product_group_bool_exp!]
  description: translated_text_bool_exp
  description_id: uuid_comparison_exp
  headline: translated_text_bool_exp
  headline_id: uuid_comparison_exp
  id: uuid_comparison_exp
  image: files_bool_exp
  image_id: uuid_comparison_exp
  name: translated_text_bool_exp
  name_id: uuid_comparison_exp
  organization: organization_bool_exp
  organization_id: uuid_comparison_exp
  products: product_group_product_bool_exp
  products_aggregate: product_group_product_aggregate_bool_exp
  slug: slug_bool_exp
  slug_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "product_group"
"""
enum product_group_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  product_group_pkey
}

"""
input type for inserting data into table "product_group"
"""
input product_group_insert_input {
  description: translated_text_obj_rel_insert_input
  description_id: uuid
  headline: translated_text_obj_rel_insert_input
  headline_id: uuid
  id: uuid
  image: files_obj_rel_insert_input
  image_id: uuid
  name: translated_text_obj_rel_insert_input
  name_id: uuid
  organization: organization_obj_rel_insert_input
  organization_id: uuid
  products: product_group_product_arr_rel_insert_input
  slug: slug_obj_rel_insert_input
  slug_id: uuid
}

"""aggregate max on columns"""
type product_group_max_fields {
  description_id: uuid
  headline_id: uuid
  id: uuid
  image_id: uuid
  name_id: uuid
  organization_id: uuid
  slug_id: uuid
}

"""
order by max() on columns of table "product_group"
"""
input product_group_max_order_by {
  description_id: order_by
  headline_id: order_by
  id: order_by
  image_id: order_by
  name_id: order_by
  organization_id: order_by
  slug_id: order_by
}

"""aggregate min on columns"""
type product_group_min_fields {
  description_id: uuid
  headline_id: uuid
  id: uuid
  image_id: uuid
  name_id: uuid
  organization_id: uuid
  slug_id: uuid
}

"""
order by min() on columns of table "product_group"
"""
input product_group_min_order_by {
  description_id: order_by
  headline_id: order_by
  id: order_by
  image_id: order_by
  name_id: order_by
  organization_id: order_by
  slug_id: order_by
}

"""
response of any mutation on the table "product_group"
"""
type product_group_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_group!]!
}

"""
input type for inserting object relation for remote table "product_group"
"""
input product_group_obj_rel_insert_input {
  data: product_group_insert_input!

  """upsert condition"""
  on_conflict: product_group_on_conflict
}

"""
on_conflict condition type for table "product_group"
"""
input product_group_on_conflict {
  constraint: product_group_constraint!
  update_columns: [product_group_update_column!]! = []
  where: product_group_bool_exp
}

"""Ordering options when selecting data from "product_group"."""
input product_group_order_by {
  description: translated_text_order_by
  description_id: order_by
  headline: translated_text_order_by
  headline_id: order_by
  id: order_by
  image: files_order_by
  image_id: order_by
  name: translated_text_order_by
  name_id: order_by
  organization: organization_order_by
  organization_id: order_by
  products_aggregate: product_group_product_aggregate_order_by
  slug: slug_order_by
  slug_id: order_by
}

"""primary key columns input for table: product_group"""
input product_group_pk_columns_input {
  id: uuid!
}

"""
columns and relationships of "product_group_product"
"""
type product_group_product {
  """An object relationship"""
  group: product_group!
  group_id: uuid!
  position: Int!

  """An object relationship"""
  product: product!
  product_id: uuid!
}

"""
aggregated selection of "product_group_product"
"""
type product_group_product_aggregate {
  aggregate: product_group_product_aggregate_fields
  nodes: [product_group_product!]!
}

input product_group_product_aggregate_bool_exp {
  count: product_group_product_aggregate_bool_exp_count
}

input product_group_product_aggregate_bool_exp_count {
  arguments: [product_group_product_select_column!]
  distinct: Boolean
  filter: product_group_product_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "product_group_product"
"""
type product_group_product_aggregate_fields {
  avg: product_group_product_avg_fields
  count(columns: [product_group_product_select_column!], distinct: Boolean): Int!
  max: product_group_product_max_fields
  min: product_group_product_min_fields
  stddev: product_group_product_stddev_fields
  stddev_pop: product_group_product_stddev_pop_fields
  stddev_samp: product_group_product_stddev_samp_fields
  sum: product_group_product_sum_fields
  var_pop: product_group_product_var_pop_fields
  var_samp: product_group_product_var_samp_fields
  variance: product_group_product_variance_fields
}

"""
order by aggregate values of table "product_group_product"
"""
input product_group_product_aggregate_order_by {
  avg: product_group_product_avg_order_by
  count: order_by
  max: product_group_product_max_order_by
  min: product_group_product_min_order_by
  stddev: product_group_product_stddev_order_by
  stddev_pop: product_group_product_stddev_pop_order_by
  stddev_samp: product_group_product_stddev_samp_order_by
  sum: product_group_product_sum_order_by
  var_pop: product_group_product_var_pop_order_by
  var_samp: product_group_product_var_samp_order_by
  variance: product_group_product_variance_order_by
}

"""
input type for inserting array relation for remote table "product_group_product"
"""
input product_group_product_arr_rel_insert_input {
  data: [product_group_product_insert_input!]!

  """upsert condition"""
  on_conflict: product_group_product_on_conflict
}

"""aggregate avg on columns"""
type product_group_product_avg_fields {
  position: Float
}

"""
order by avg() on columns of table "product_group_product"
"""
input product_group_product_avg_order_by {
  position: order_by
}

"""
Boolean expression to filter rows from the table "product_group_product". All fields are combined with a logical 'AND'.
"""
input product_group_product_bool_exp {
  _and: [product_group_product_bool_exp!]
  _not: product_group_product_bool_exp
  _or: [product_group_product_bool_exp!]
  group: product_group_bool_exp
  group_id: uuid_comparison_exp
  position: Int_comparison_exp
  product: product_bool_exp
  product_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "product_group_product"
"""
enum product_group_product_constraint {
  """
  unique or primary key constraint on columns "product_id", "group_id"
  """
  product_group_product_pkey
}

"""
input type for incrementing numeric columns in table "product_group_product"
"""
input product_group_product_inc_input {
  position: Int
}

"""
input type for inserting data into table "product_group_product"
"""
input product_group_product_insert_input {
  group: product_group_obj_rel_insert_input
  group_id: uuid
  position: Int
  product: product_obj_rel_insert_input
  product_id: uuid
}

"""aggregate max on columns"""
type product_group_product_max_fields {
  group_id: uuid
  position: Int
  product_id: uuid
}

"""
order by max() on columns of table "product_group_product"
"""
input product_group_product_max_order_by {
  group_id: order_by
  position: order_by
  product_id: order_by
}

"""aggregate min on columns"""
type product_group_product_min_fields {
  group_id: uuid
  position: Int
  product_id: uuid
}

"""
order by min() on columns of table "product_group_product"
"""
input product_group_product_min_order_by {
  group_id: order_by
  position: order_by
  product_id: order_by
}

"""
response of any mutation on the table "product_group_product"
"""
type product_group_product_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_group_product!]!
}

"""
on_conflict condition type for table "product_group_product"
"""
input product_group_product_on_conflict {
  constraint: product_group_product_constraint!
  update_columns: [product_group_product_update_column!]! = []
  where: product_group_product_bool_exp
}

"""Ordering options when selecting data from "product_group_product"."""
input product_group_product_order_by {
  group: product_group_order_by
  group_id: order_by
  position: order_by
  product: product_order_by
  product_id: order_by
}

"""primary key columns input for table: product_group_product"""
input product_group_product_pk_columns_input {
  group_id: uuid!
  product_id: uuid!
}

"""
select columns of table "product_group_product"
"""
enum product_group_product_select_column {
  """column name"""
  group_id

  """column name"""
  position

  """column name"""
  product_id
}

"""
input type for updating data in table "product_group_product"
"""
input product_group_product_set_input {
  group_id: uuid
  position: Int
  product_id: uuid
}

"""aggregate stddev on columns"""
type product_group_product_stddev_fields {
  position: Float
}

"""
order by stddev() on columns of table "product_group_product"
"""
input product_group_product_stddev_order_by {
  position: order_by
}

"""aggregate stddev_pop on columns"""
type product_group_product_stddev_pop_fields {
  position: Float
}

"""
order by stddev_pop() on columns of table "product_group_product"
"""
input product_group_product_stddev_pop_order_by {
  position: order_by
}

"""aggregate stddev_samp on columns"""
type product_group_product_stddev_samp_fields {
  position: Float
}

"""
order by stddev_samp() on columns of table "product_group_product"
"""
input product_group_product_stddev_samp_order_by {
  position: order_by
}

"""
Streaming cursor of the table "product_group_product"
"""
input product_group_product_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_group_product_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_group_product_stream_cursor_value_input {
  group_id: uuid
  position: Int
  product_id: uuid
}

"""aggregate sum on columns"""
type product_group_product_sum_fields {
  position: Int
}

"""
order by sum() on columns of table "product_group_product"
"""
input product_group_product_sum_order_by {
  position: order_by
}

"""
update columns of table "product_group_product"
"""
enum product_group_product_update_column {
  """column name"""
  group_id

  """column name"""
  position

  """column name"""
  product_id
}

input product_group_product_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: product_group_product_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: product_group_product_set_input

  """filter the rows which have to be updated"""
  where: product_group_product_bool_exp!
}

"""aggregate var_pop on columns"""
type product_group_product_var_pop_fields {
  position: Float
}

"""
order by var_pop() on columns of table "product_group_product"
"""
input product_group_product_var_pop_order_by {
  position: order_by
}

"""aggregate var_samp on columns"""
type product_group_product_var_samp_fields {
  position: Float
}

"""
order by var_samp() on columns of table "product_group_product"
"""
input product_group_product_var_samp_order_by {
  position: order_by
}

"""aggregate variance on columns"""
type product_group_product_variance_fields {
  position: Float
}

"""
order by variance() on columns of table "product_group_product"
"""
input product_group_product_variance_order_by {
  position: order_by
}

input product_group_save_input {
  description: multilanguage_field_input!
  headline: multilanguage_field_input!
  id: uuid!
  image_id: uuid!
  name: multilanguage_field_input!
  organization_id: uuid!
  products: [selected_item!]!
}

"""
select columns of table "product_group"
"""
enum product_group_select_column {
  """column name"""
  description_id

  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  image_id

  """column name"""
  name_id

  """column name"""
  organization_id

  """column name"""
  slug_id
}

"""
input type for updating data in table "product_group"
"""
input product_group_set_input {
  description_id: uuid
  headline_id: uuid
  id: uuid
  image_id: uuid
  name_id: uuid
  organization_id: uuid
  slug_id: uuid
}

"""
Streaming cursor of the table "product_group"
"""
input product_group_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_group_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_group_stream_cursor_value_input {
  description_id: uuid
  headline_id: uuid
  id: uuid
  image_id: uuid
  name_id: uuid
  organization_id: uuid
  slug_id: uuid
}

"""
update columns of table "product_group"
"""
enum product_group_update_column {
  """column name"""
  description_id

  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  image_id

  """column name"""
  name_id

  """column name"""
  organization_id

  """column name"""
  slug_id
}

input product_group_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: product_group_set_input

  """filter the rows which have to be updated"""
  where: product_group_bool_exp!
}

"""
columns and relationships of "product_headline"
"""
type product_headline {
  de: String
  en: String
  es: String
  fr: String
  id: uuid!
}

"""
aggregated selection of "product_headline"
"""
type product_headline_aggregate {
  aggregate: product_headline_aggregate_fields
  nodes: [product_headline!]!
}

"""
aggregate fields of "product_headline"
"""
type product_headline_aggregate_fields {
  count(columns: [product_headline_select_column!], distinct: Boolean): Int!
  max: product_headline_max_fields
  min: product_headline_min_fields
}

"""
Boolean expression to filter rows from the table "product_headline". All fields are combined with a logical 'AND'.
"""
input product_headline_bool_exp {
  _and: [product_headline_bool_exp!]
  _not: product_headline_bool_exp
  _or: [product_headline_bool_exp!]
  de: String_comparison_exp
  en: String_comparison_exp
  es: String_comparison_exp
  fr: String_comparison_exp
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "product_headline"
"""
enum product_headline_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  product_headline_pkey
}

"""
input type for inserting data into table "product_headline"
"""
input product_headline_insert_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate max on columns"""
type product_headline_max_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate min on columns"""
type product_headline_min_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
response of any mutation on the table "product_headline"
"""
type product_headline_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_headline!]!
}

"""
input type for inserting object relation for remote table "product_headline"
"""
input product_headline_obj_rel_insert_input {
  data: product_headline_insert_input!

  """upsert condition"""
  on_conflict: product_headline_on_conflict
}

"""
on_conflict condition type for table "product_headline"
"""
input product_headline_on_conflict {
  constraint: product_headline_constraint!
  update_columns: [product_headline_update_column!]! = []
  where: product_headline_bool_exp
}

"""Ordering options when selecting data from "product_headline"."""
input product_headline_order_by {
  de: order_by
  en: order_by
  es: order_by
  fr: order_by
  id: order_by
}

"""primary key columns input for table: product_headline"""
input product_headline_pk_columns_input {
  id: uuid!
}

"""
select columns of table "product_headline"
"""
enum product_headline_select_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

"""
input type for updating data in table "product_headline"
"""
input product_headline_set_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
Streaming cursor of the table "product_headline"
"""
input product_headline_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_headline_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_headline_stream_cursor_value_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
update columns of table "product_headline"
"""
enum product_headline_update_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

input product_headline_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: product_headline_set_input

  """filter the rows which have to be updated"""
  where: product_headline_bool_exp!
}

"""
input type for incrementing numeric columns in table "product"
"""
input product_inc_input {
  price_from: numeric
}

"""
input type for inserting data into table "product"
"""
input product_insert_input {
  allotment_calendar: product_allotment_range_arr_rel_insert_input
  business_model: product_business_model_obj_rel_insert_input
  business_model_id: uuid
  description: product_description_obj_rel_insert_input
  description_id: uuid
  features: product_feature_arr_rel_insert_input
  gallery: media_gallery_obj_rel_insert_input
  gallery_id: uuid
  headline: product_headline_obj_rel_insert_input
  headline_id: uuid
  id: uuid
  name: product_name_obj_rel_insert_input
  name_id: uuid
  organization: organization_obj_rel_insert_input
  organization_id: uuid
  place: place_obj_rel_insert_input
  place_id: uuid
  price_from: numeric
  published: Boolean
  rates: rate_arr_rel_insert_input
  slug: slug_obj_rel_insert_input
  slug_id: uuid
  supplements: product_supplement_arr_rel_insert_input
}

"""aggregate max on columns"""
type product_max_fields {
  business_model_id: uuid
  description_id: uuid
  gallery_id: uuid
  headline_id: uuid
  id: uuid
  name_id: uuid
  organization_id: uuid
  place_id: uuid
  price_from: numeric
  slug_id: uuid
}

"""
order by max() on columns of table "product"
"""
input product_max_order_by {
  business_model_id: order_by
  description_id: order_by
  gallery_id: order_by
  headline_id: order_by
  id: order_by
  name_id: order_by
  organization_id: order_by
  place_id: order_by
  price_from: order_by
  slug_id: order_by
}

"""aggregate min on columns"""
type product_min_fields {
  business_model_id: uuid
  description_id: uuid
  gallery_id: uuid
  headline_id: uuid
  id: uuid
  name_id: uuid
  organization_id: uuid
  place_id: uuid
  price_from: numeric
  slug_id: uuid
}

"""
order by min() on columns of table "product"
"""
input product_min_order_by {
  business_model_id: order_by
  description_id: order_by
  gallery_id: order_by
  headline_id: order_by
  id: order_by
  name_id: order_by
  organization_id: order_by
  place_id: order_by
  price_from: order_by
  slug_id: order_by
}

"""
response of any mutation on the table "product"
"""
type product_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product!]!
}

"""
columns and relationships of "product_name"
"""
type product_name {
  de: String
  en: String
  es: String
  fr: String
  id: uuid!
}

"""
aggregated selection of "product_name"
"""
type product_name_aggregate {
  aggregate: product_name_aggregate_fields
  nodes: [product_name!]!
}

"""
aggregate fields of "product_name"
"""
type product_name_aggregate_fields {
  count(columns: [product_name_select_column!], distinct: Boolean): Int!
  max: product_name_max_fields
  min: product_name_min_fields
}

"""
Boolean expression to filter rows from the table "product_name". All fields are combined with a logical 'AND'.
"""
input product_name_bool_exp {
  _and: [product_name_bool_exp!]
  _not: product_name_bool_exp
  _or: [product_name_bool_exp!]
  de: String_comparison_exp
  en: String_comparison_exp
  es: String_comparison_exp
  fr: String_comparison_exp
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "product_name"
"""
enum product_name_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  product_name_pkey
}

"""
input type for inserting data into table "product_name"
"""
input product_name_insert_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate max on columns"""
type product_name_max_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate min on columns"""
type product_name_min_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
response of any mutation on the table "product_name"
"""
type product_name_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_name!]!
}

"""
input type for inserting object relation for remote table "product_name"
"""
input product_name_obj_rel_insert_input {
  data: product_name_insert_input!

  """upsert condition"""
  on_conflict: product_name_on_conflict
}

"""
on_conflict condition type for table "product_name"
"""
input product_name_on_conflict {
  constraint: product_name_constraint!
  update_columns: [product_name_update_column!]! = []
  where: product_name_bool_exp
}

"""Ordering options when selecting data from "product_name"."""
input product_name_order_by {
  de: order_by
  en: order_by
  es: order_by
  fr: order_by
  id: order_by
}

"""primary key columns input for table: product_name"""
input product_name_pk_columns_input {
  id: uuid!
}

"""
select columns of table "product_name"
"""
enum product_name_select_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

"""
input type for updating data in table "product_name"
"""
input product_name_set_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
Streaming cursor of the table "product_name"
"""
input product_name_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_name_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_name_stream_cursor_value_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
update columns of table "product_name"
"""
enum product_name_update_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

input product_name_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: product_name_set_input

  """filter the rows which have to be updated"""
  where: product_name_bool_exp!
}

"""
input type for inserting object relation for remote table "product"
"""
input product_obj_rel_insert_input {
  data: product_insert_input!

  """upsert condition"""
  on_conflict: product_on_conflict
}

"""
on_conflict condition type for table "product"
"""
input product_on_conflict {
  constraint: product_constraint!
  update_columns: [product_update_column!]! = []
  where: product_bool_exp
}

"""Ordering options when selecting data from "product"."""
input product_order_by {
  allotment_calendar_aggregate: product_allotment_range_aggregate_order_by
  business_model: product_business_model_order_by
  business_model_id: order_by
  description: product_description_order_by
  description_id: order_by
  features_aggregate: product_feature_aggregate_order_by
  gallery: media_gallery_order_by
  gallery_id: order_by
  headline: product_headline_order_by
  headline_id: order_by
  id: order_by
  name: product_name_order_by
  name_id: order_by
  organization: organization_order_by
  organization_id: order_by
  place: place_order_by
  place_id: order_by
  price_from: order_by
  published: order_by
  rates_aggregate: rate_aggregate_order_by
  slug: slug_order_by
  slug_id: order_by
  supplements_aggregate: product_supplement_aggregate_order_by
}

"""primary key columns input for table: product"""
input product_pk_columns_input {
  id: uuid!
}

input product_save_input {
  business_model: business_model_input!
  description: multilanguage_field_input!
  gallery: media_gallery_input!
  headline: multilanguage_field_input!
  id: String!
  name: multilanguage_field_input!
  place: place_input
  price_from: numeric!
  published: Boolean!
}

"""
select columns of table "product"
"""
enum product_select_column {
  """column name"""
  business_model_id

  """column name"""
  description_id

  """column name"""
  gallery_id

  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  organization_id

  """column name"""
  place_id

  """column name"""
  price_from

  """column name"""
  published

  """column name"""
  slug_id
}

"""
select "product_aggregate_bool_exp_bool_and_arguments_columns" columns of table "product"
"""
enum product_select_column_product_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  published
}

"""
select "product_aggregate_bool_exp_bool_or_arguments_columns" columns of table "product"
"""
enum product_select_column_product_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  published
}

"""
input type for updating data in table "product"
"""
input product_set_input {
  business_model_id: uuid
  description_id: uuid
  gallery_id: uuid
  headline_id: uuid
  id: uuid
  name_id: uuid
  organization_id: uuid
  place_id: uuid
  price_from: numeric
  published: Boolean
  slug_id: uuid
}

"""aggregate stddev on columns"""
type product_stddev_fields {
  price_from: Float
}

"""
order by stddev() on columns of table "product"
"""
input product_stddev_order_by {
  price_from: order_by
}

"""aggregate stddev_pop on columns"""
type product_stddev_pop_fields {
  price_from: Float
}

"""
order by stddev_pop() on columns of table "product"
"""
input product_stddev_pop_order_by {
  price_from: order_by
}

"""aggregate stddev_samp on columns"""
type product_stddev_samp_fields {
  price_from: Float
}

"""
order by stddev_samp() on columns of table "product"
"""
input product_stddev_samp_order_by {
  price_from: order_by
}

"""
Streaming cursor of the table "product"
"""
input product_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_stream_cursor_value_input {
  business_model_id: uuid
  description_id: uuid
  gallery_id: uuid
  headline_id: uuid
  id: uuid
  name_id: uuid
  organization_id: uuid
  place_id: uuid
  price_from: numeric
  published: Boolean
  slug_id: uuid
}

"""aggregate sum on columns"""
type product_sum_fields {
  price_from: numeric
}

"""
order by sum() on columns of table "product"
"""
input product_sum_order_by {
  price_from: order_by
}

"""
columns and relationships of "product_supplement"
"""
type product_supplement {
  """An object relationship"""
  product: product!
  product_id: uuid!

  """An object relationship"""
  supplement: supplement!
  supplement_id: uuid!
}

"""
aggregated selection of "product_supplement"
"""
type product_supplement_aggregate {
  aggregate: product_supplement_aggregate_fields
  nodes: [product_supplement!]!
}

input product_supplement_aggregate_bool_exp {
  count: product_supplement_aggregate_bool_exp_count
}

input product_supplement_aggregate_bool_exp_count {
  arguments: [product_supplement_select_column!]
  distinct: Boolean
  filter: product_supplement_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "product_supplement"
"""
type product_supplement_aggregate_fields {
  count(columns: [product_supplement_select_column!], distinct: Boolean): Int!
  max: product_supplement_max_fields
  min: product_supplement_min_fields
}

"""
order by aggregate values of table "product_supplement"
"""
input product_supplement_aggregate_order_by {
  count: order_by
  max: product_supplement_max_order_by
  min: product_supplement_min_order_by
}

"""
input type for inserting array relation for remote table "product_supplement"
"""
input product_supplement_arr_rel_insert_input {
  data: [product_supplement_insert_input!]!

  """upsert condition"""
  on_conflict: product_supplement_on_conflict
}

"""
Boolean expression to filter rows from the table "product_supplement". All fields are combined with a logical 'AND'.
"""
input product_supplement_bool_exp {
  _and: [product_supplement_bool_exp!]
  _not: product_supplement_bool_exp
  _or: [product_supplement_bool_exp!]
  product: product_bool_exp
  product_id: uuid_comparison_exp
  supplement: supplement_bool_exp
  supplement_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "product_supplement"
"""
enum product_supplement_constraint {
  """
  unique or primary key constraint on columns "supplement_id", "product_id"
  """
  product_supplement_pkey
}

"""
input type for inserting data into table "product_supplement"
"""
input product_supplement_insert_input {
  product: product_obj_rel_insert_input
  product_id: uuid
  supplement: supplement_obj_rel_insert_input
  supplement_id: uuid
}

"""aggregate max on columns"""
type product_supplement_max_fields {
  product_id: uuid
  supplement_id: uuid
}

"""
order by max() on columns of table "product_supplement"
"""
input product_supplement_max_order_by {
  product_id: order_by
  supplement_id: order_by
}

"""aggregate min on columns"""
type product_supplement_min_fields {
  product_id: uuid
  supplement_id: uuid
}

"""
order by min() on columns of table "product_supplement"
"""
input product_supplement_min_order_by {
  product_id: order_by
  supplement_id: order_by
}

"""
response of any mutation on the table "product_supplement"
"""
type product_supplement_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_supplement!]!
}

"""
on_conflict condition type for table "product_supplement"
"""
input product_supplement_on_conflict {
  constraint: product_supplement_constraint!
  update_columns: [product_supplement_update_column!]! = []
  where: product_supplement_bool_exp
}

"""Ordering options when selecting data from "product_supplement"."""
input product_supplement_order_by {
  product: product_order_by
  product_id: order_by
  supplement: supplement_order_by
  supplement_id: order_by
}

"""primary key columns input for table: product_supplement"""
input product_supplement_pk_columns_input {
  product_id: uuid!
  supplement_id: uuid!
}

"""
select columns of table "product_supplement"
"""
enum product_supplement_select_column {
  """column name"""
  product_id

  """column name"""
  supplement_id
}

"""
input type for updating data in table "product_supplement"
"""
input product_supplement_set_input {
  product_id: uuid
  supplement_id: uuid
}

"""
Streaming cursor of the table "product_supplement"
"""
input product_supplement_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_supplement_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_supplement_stream_cursor_value_input {
  product_id: uuid
  supplement_id: uuid
}

"""
update columns of table "product_supplement"
"""
enum product_supplement_update_column {
  """column name"""
  product_id

  """column name"""
  supplement_id
}

input product_supplement_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: product_supplement_set_input

  """filter the rows which have to be updated"""
  where: product_supplement_bool_exp!
}

"""
update columns of table "product"
"""
enum product_update_column {
  """column name"""
  business_model_id

  """column name"""
  description_id

  """column name"""
  gallery_id

  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  organization_id

  """column name"""
  place_id

  """column name"""
  price_from

  """column name"""
  published

  """column name"""
  slug_id
}

input product_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: product_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: product_set_input

  """filter the rows which have to be updated"""
  where: product_bool_exp!
}

"""aggregate var_pop on columns"""
type product_var_pop_fields {
  price_from: Float
}

"""
order by var_pop() on columns of table "product"
"""
input product_var_pop_order_by {
  price_from: order_by
}

"""aggregate var_samp on columns"""
type product_var_samp_fields {
  price_from: Float
}

"""
order by var_samp() on columns of table "product"
"""
input product_var_samp_order_by {
  price_from: order_by
}

"""aggregate variance on columns"""
type product_variance_fields {
  price_from: Float
}

"""
order by variance() on columns of table "product"
"""
input product_variance_order_by {
  price_from: order_by
}

type query_root {
  """fetch data from the table: "auth.providers" using primary key columns"""
  authProvider(id: String!): authProviders

  """
  fetch data from the table: "auth.provider_requests" using primary key columns
  """
  authProviderRequest(id: uuid!): authProviderRequests

  """
  fetch data from the table: "auth.provider_requests"
  """
  authProviderRequests(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch aggregated fields from the table: "auth.provider_requests"
  """
  authProviderRequestsAggregate(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): authProviderRequests_aggregate!

  """
  fetch data from the table: "auth.providers"
  """
  authProviders(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  authProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): authProviders_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  authRefreshToken(id: uuid!): authRefreshTokens

  """
  fetch data from the table: "auth.refresh_token_types" using primary key columns
  """
  authRefreshTokenType(value: String!): authRefreshTokenTypes

  """
  fetch data from the table: "auth.refresh_token_types"
  """
  authRefreshTokenTypes(
    """distinct select on columns"""
    distinct_on: [authRefreshTokenTypes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokenTypes_order_by!]

    """filter the rows returned"""
    where: authRefreshTokenTypes_bool_exp
  ): [authRefreshTokenTypes!]!

  """
  fetch aggregated fields from the table: "auth.refresh_token_types"
  """
  authRefreshTokenTypesAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokenTypes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokenTypes_order_by!]

    """filter the rows returned"""
    where: authRefreshTokenTypes_bool_exp
  ): authRefreshTokenTypes_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  authRefreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  authRefreshTokensAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """fetch data from the table: "auth.roles" using primary key columns"""
  authRole(role: String!): authRoles

  """
  fetch data from the table: "auth.roles"
  """
  authRoles(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  authRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): authRoles_aggregate!

  """
  fetch data from the table: "auth.user_providers" using primary key columns
  """
  authUserProvider(id: uuid!): authUserProviders

  """
  fetch data from the table: "auth.user_providers"
  """
  authUserProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """
  fetch aggregated fields from the table: "auth.user_providers"
  """
  authUserProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!

  """fetch data from the table: "auth.user_roles" using primary key columns"""
  authUserRole(id: uuid!): authUserRoles

  """
  fetch data from the table: "auth.user_roles"
  """
  authUserRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch aggregated fields from the table: "auth.user_roles"
  """
  authUserRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """
  fetch data from the table: "auth.user_security_keys" using primary key columns
  """
  authUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  fetch data from the table: "auth.user_security_keys"
  """
  authUserSecurityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """
  fetch aggregated fields from the table: "auth.user_security_keys"
  """
  authUserSecurityKeysAggregate(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): authUserSecurityKeys_aggregate!

  """
  fetch data from the table: "booking"
  """
  booking(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): [booking!]!

  """
  fetch aggregated fields from the table: "booking"
  """
  booking_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): booking_aggregate!

  """fetch data from the table: "booking" using primary key columns"""
  booking_by_pk(id: uuid!): booking

  """
  fetch data from the table: "booking_events.event_type"
  """
  booking_events_event_type(
    """distinct select on columns"""
    distinct_on: [booking_events_event_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_events_event_type_order_by!]

    """filter the rows returned"""
    where: booking_events_event_type_bool_exp
  ): [booking_events_event_type!]!

  """
  fetch aggregated fields from the table: "booking_events.event_type"
  """
  booking_events_event_type_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_events_event_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_events_event_type_order_by!]

    """filter the rows returned"""
    where: booking_events_event_type_bool_exp
  ): booking_events_event_type_aggregate!

  """
  fetch data from the table: "booking_events.event_type" using primary key columns
  """
  booking_events_event_type_by_pk(id: String!): booking_events_event_type

  """
  fetch data from the table: "booking_events.main"
  """
  booking_events_main(
    """distinct select on columns"""
    distinct_on: [booking_events_main_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_events_main_order_by!]

    """filter the rows returned"""
    where: booking_events_main_bool_exp
  ): [booking_events_main!]!

  """
  fetch aggregated fields from the table: "booking_events.main"
  """
  booking_events_main_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_events_main_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_events_main_order_by!]

    """filter the rows returned"""
    where: booking_events_main_bool_exp
  ): booking_events_main_aggregate!

  """
  fetch data from the table: "booking_events.main" using primary key columns
  """
  booking_events_main_by_pk(id: uuid!): booking_events_main

  """
  fetch data from the table: "booking_events.version"
  """
  booking_events_version(
    """distinct select on columns"""
    distinct_on: [booking_events_version_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_events_version_order_by!]

    """filter the rows returned"""
    where: booking_events_version_bool_exp
  ): [booking_events_version!]!

  """
  fetch aggregated fields from the table: "booking_events.version"
  """
  booking_events_version_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_events_version_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_events_version_order_by!]

    """filter the rows returned"""
    where: booking_events_version_bool_exp
  ): booking_events_version_aggregate!

  """
  fetch data from the table: "booking_events.version" using primary key columns
  """
  booking_events_version_by_pk(id: uuid!): booking_events_version

  """
  fetch data from the table: "booking_history_entry"
  """
  booking_history_entry(
    """distinct select on columns"""
    distinct_on: [booking_history_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_history_entry_order_by!]

    """filter the rows returned"""
    where: booking_history_entry_bool_exp
  ): [booking_history_entry!]!

  """
  fetch aggregated fields from the table: "booking_history_entry"
  """
  booking_history_entry_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_history_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_history_entry_order_by!]

    """filter the rows returned"""
    where: booking_history_entry_bool_exp
  ): booking_history_entry_aggregate!

  """
  fetch data from the table: "booking_history_entry" using primary key columns
  """
  booking_history_entry_by_pk(id: uuid!): booking_history_entry

  """
  fetch data from the table: "booking_product"
  """
  booking_product(
    """distinct select on columns"""
    distinct_on: [booking_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_product_order_by!]

    """filter the rows returned"""
    where: booking_product_bool_exp
  ): [booking_product!]!

  """
  fetch aggregated fields from the table: "booking_product"
  """
  booking_product_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_product_order_by!]

    """filter the rows returned"""
    where: booking_product_bool_exp
  ): booking_product_aggregate!

  """fetch data from the table: "booking_product" using primary key columns"""
  booking_product_by_pk(id: uuid!): booking_product

  """
  fetch data from the table: "booking_question_scope"
  """
  booking_question_scope(
    """distinct select on columns"""
    distinct_on: [booking_question_scope_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_question_scope_order_by!]

    """filter the rows returned"""
    where: booking_question_scope_bool_exp
  ): [booking_question_scope!]!

  """
  fetch aggregated fields from the table: "booking_question_scope"
  """
  booking_question_scope_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_question_scope_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_question_scope_order_by!]

    """filter the rows returned"""
    where: booking_question_scope_bool_exp
  ): booking_question_scope_aggregate!

  """
  fetch data from the table: "booking_question_scope" using primary key columns
  """
  booking_question_scope_by_pk(id: String!): booking_question_scope

  """
  fetch data from the table: "booking_question_type"
  """
  booking_question_type(
    """distinct select on columns"""
    distinct_on: [booking_question_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_question_type_order_by!]

    """filter the rows returned"""
    where: booking_question_type_bool_exp
  ): [booking_question_type!]!

  """
  fetch aggregated fields from the table: "booking_question_type"
  """
  booking_question_type_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_question_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_question_type_order_by!]

    """filter the rows returned"""
    where: booking_question_type_bool_exp
  ): booking_question_type_aggregate!

  """
  fetch data from the table: "booking_question_type" using primary key columns
  """
  booking_question_type_by_pk(id: String!): booking_question_type

  """
  fetch data from the table: "booking_state"
  """
  booking_state(
    """distinct select on columns"""
    distinct_on: [booking_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_state_order_by!]

    """filter the rows returned"""
    where: booking_state_bool_exp
  ): [booking_state!]!

  """
  fetch aggregated fields from the table: "booking_state"
  """
  booking_state_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_state_order_by!]

    """filter the rows returned"""
    where: booking_state_bool_exp
  ): booking_state_aggregate!

  """fetch data from the table: "booking_state" using primary key columns"""
  booking_state_by_pk(id: String!): booking_state

  """fetch data from the table: "storage.buckets" using primary key columns"""
  bucket(id: String!): buckets

  """
  fetch data from the table: "storage.buckets"
  """
  buckets(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  fetch aggregated fields from the table: "storage.buckets"
  """
  bucketsAggregate(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): buckets_aggregate!

  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): [category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  category_aggregate(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): category_aggregate!

  """fetch data from the table: "category" using primary key columns"""
  category_by_pk(id: String!): category

  """
  fetch data from the table: "contact"
  """
  contact(
    """distinct select on columns"""
    distinct_on: [contact_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contact_order_by!]

    """filter the rows returned"""
    where: contact_bool_exp
  ): [contact!]!

  """
  fetch aggregated fields from the table: "contact"
  """
  contact_aggregate(
    """distinct select on columns"""
    distinct_on: [contact_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contact_order_by!]

    """filter the rows returned"""
    where: contact_bool_exp
  ): contact_aggregate!

  """fetch data from the table: "contact" using primary key columns"""
  contact_by_pk(id: uuid!): contact

  """
  fetch data from the table: "feature"
  """
  feature(
    """distinct select on columns"""
    distinct_on: [feature_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_order_by!]

    """filter the rows returned"""
    where: feature_bool_exp
  ): [feature!]!

  """
  fetch aggregated fields from the table: "feature"
  """
  feature_aggregate(
    """distinct select on columns"""
    distinct_on: [feature_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_order_by!]

    """filter the rows returned"""
    where: feature_bool_exp
  ): feature_aggregate!

  """fetch data from the table: "feature" using primary key columns"""
  feature_by_pk(id: uuid!): feature

  """
  fetch data from the table: "feature_category"
  """
  feature_category(
    """distinct select on columns"""
    distinct_on: [feature_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_category_order_by!]

    """filter the rows returned"""
    where: feature_category_bool_exp
  ): [feature_category!]!

  """
  fetch aggregated fields from the table: "feature_category"
  """
  feature_category_aggregate(
    """distinct select on columns"""
    distinct_on: [feature_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_category_order_by!]

    """filter the rows returned"""
    where: feature_category_bool_exp
  ): feature_category_aggregate!

  """
  fetch data from the table: "feature_category" using primary key columns
  """
  feature_category_by_pk(category_id: String!, feature_id: uuid!): feature_category

  """
  fetch data from the table: "feature_symbol"
  """
  feature_symbol(
    """distinct select on columns"""
    distinct_on: [feature_symbol_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_symbol_order_by!]

    """filter the rows returned"""
    where: feature_symbol_bool_exp
  ): [feature_symbol!]!

  """
  fetch aggregated fields from the table: "feature_symbol"
  """
  feature_symbol_aggregate(
    """distinct select on columns"""
    distinct_on: [feature_symbol_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_symbol_order_by!]

    """filter the rows returned"""
    where: feature_symbol_bool_exp
  ): feature_symbol_aggregate!

  """fetch data from the table: "feature_symbol" using primary key columns"""
  feature_symbol_by_pk(id: String!): feature_symbol

  """
  fetch data from the table: "feature_type"
  """
  feature_type(
    """distinct select on columns"""
    distinct_on: [feature_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_type_order_by!]

    """filter the rows returned"""
    where: feature_type_bool_exp
  ): [feature_type!]!

  """
  fetch aggregated fields from the table: "feature_type"
  """
  feature_type_aggregate(
    """distinct select on columns"""
    distinct_on: [feature_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_type_order_by!]

    """filter the rows returned"""
    where: feature_type_bool_exp
  ): feature_type_aggregate!

  """fetch data from the table: "feature_type" using primary key columns"""
  feature_type_by_pk(id: String!): feature_type

  """fetch data from the table: "storage.files" using primary key columns"""
  file(id: uuid!): files

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "storage.files"
  """
  filesAggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!
  get_booking(arg: get_booking_input!): json!

  """
  fetch data from the table: "media_gallery"
  """
  media_gallery(
    """distinct select on columns"""
    distinct_on: [media_gallery_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_gallery_order_by!]

    """filter the rows returned"""
    where: media_gallery_bool_exp
  ): [media_gallery!]!

  """
  fetch aggregated fields from the table: "media_gallery"
  """
  media_gallery_aggregate(
    """distinct select on columns"""
    distinct_on: [media_gallery_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_gallery_order_by!]

    """filter the rows returned"""
    where: media_gallery_bool_exp
  ): media_gallery_aggregate!

  """fetch data from the table: "media_gallery" using primary key columns"""
  media_gallery_by_pk(id: uuid!): media_gallery

  """
  fetch data from the table: "media_gallery_item"
  """
  media_gallery_item(
    """distinct select on columns"""
    distinct_on: [media_gallery_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_gallery_item_order_by!]

    """filter the rows returned"""
    where: media_gallery_item_bool_exp
  ): [media_gallery_item!]!

  """
  fetch aggregated fields from the table: "media_gallery_item"
  """
  media_gallery_item_aggregate(
    """distinct select on columns"""
    distinct_on: [media_gallery_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_gallery_item_order_by!]

    """filter the rows returned"""
    where: media_gallery_item_bool_exp
  ): media_gallery_item_aggregate!

  """
  fetch data from the table: "media_gallery_item" using primary key columns
  """
  media_gallery_item_by_pk(id: uuid!): media_gallery_item

  """
  fetch data from the table: "my_web_section"
  """
  my_web_section(
    """distinct select on columns"""
    distinct_on: [my_web_section_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [my_web_section_order_by!]

    """filter the rows returned"""
    where: my_web_section_bool_exp
  ): [my_web_section!]!

  """
  fetch aggregated fields from the table: "my_web_section"
  """
  my_web_section_aggregate(
    """distinct select on columns"""
    distinct_on: [my_web_section_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [my_web_section_order_by!]

    """filter the rows returned"""
    where: my_web_section_bool_exp
  ): my_web_section_aggregate!

  """fetch data from the table: "my_web_section" using primary key columns"""
  my_web_section_by_pk(organization_id: uuid!, section_id: String!): my_web_section

  """
  fetch data from the table: "organization"
  """
  organization(
    """distinct select on columns"""
    distinct_on: [organization_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_order_by!]

    """filter the rows returned"""
    where: organization_bool_exp
  ): [organization!]!

  """
  fetch aggregated fields from the table: "organization"
  """
  organization_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_order_by!]

    """filter the rows returned"""
    where: organization_bool_exp
  ): organization_aggregate!

  """
  fetch data from the table: "organization_booking_question"
  """
  organization_booking_question(
    """distinct select on columns"""
    distinct_on: [organization_booking_question_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_booking_question_order_by!]

    """filter the rows returned"""
    where: organization_booking_question_bool_exp
  ): [organization_booking_question!]!

  """
  fetch aggregated fields from the table: "organization_booking_question"
  """
  organization_booking_question_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_booking_question_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_booking_question_order_by!]

    """filter the rows returned"""
    where: organization_booking_question_bool_exp
  ): organization_booking_question_aggregate!

  """
  fetch data from the table: "organization_booking_question" using primary key columns
  """
  organization_booking_question_by_pk(id: uuid!): organization_booking_question

  """
  fetch data from the table: "organization_branding"
  """
  organization_branding(
    """distinct select on columns"""
    distinct_on: [organization_branding_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_branding_order_by!]

    """filter the rows returned"""
    where: organization_branding_bool_exp
  ): [organization_branding!]!

  """
  fetch aggregated fields from the table: "organization_branding"
  """
  organization_branding_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_branding_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_branding_order_by!]

    """filter the rows returned"""
    where: organization_branding_bool_exp
  ): organization_branding_aggregate!

  """
  fetch data from the table: "organization_branding" using primary key columns
  """
  organization_branding_by_pk(id: uuid!): organization_branding

  """
  fetch data from the table: "organization_branding_meta_description"
  """
  organization_branding_meta_description(
    """distinct select on columns"""
    distinct_on: [organization_branding_meta_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_branding_meta_description_order_by!]

    """filter the rows returned"""
    where: organization_branding_meta_description_bool_exp
  ): [organization_branding_meta_description!]!

  """
  fetch aggregated fields from the table: "organization_branding_meta_description"
  """
  organization_branding_meta_description_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_branding_meta_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_branding_meta_description_order_by!]

    """filter the rows returned"""
    where: organization_branding_meta_description_bool_exp
  ): organization_branding_meta_description_aggregate!

  """
  fetch data from the table: "organization_branding_meta_description" using primary key columns
  """
  organization_branding_meta_description_by_pk(id: uuid!): organization_branding_meta_description

  """
  fetch data from the table: "organization_branding_meta_title"
  """
  organization_branding_meta_title(
    """distinct select on columns"""
    distinct_on: [organization_branding_meta_title_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_branding_meta_title_order_by!]

    """filter the rows returned"""
    where: organization_branding_meta_title_bool_exp
  ): [organization_branding_meta_title!]!

  """
  fetch aggregated fields from the table: "organization_branding_meta_title"
  """
  organization_branding_meta_title_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_branding_meta_title_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_branding_meta_title_order_by!]

    """filter the rows returned"""
    where: organization_branding_meta_title_bool_exp
  ): organization_branding_meta_title_aggregate!

  """
  fetch data from the table: "organization_branding_meta_title" using primary key columns
  """
  organization_branding_meta_title_by_pk(id: uuid!): organization_branding_meta_title

  """
  fetch data from the table: "organization_business_model"
  """
  organization_business_model(
    """distinct select on columns"""
    distinct_on: [organization_business_model_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_business_model_order_by!]

    """filter the rows returned"""
    where: organization_business_model_bool_exp
  ): [organization_business_model!]!

  """
  fetch aggregated fields from the table: "organization_business_model"
  """
  organization_business_model_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_business_model_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_business_model_order_by!]

    """filter the rows returned"""
    where: organization_business_model_bool_exp
  ): organization_business_model_aggregate!

  """
  fetch data from the table: "organization_business_model" using primary key columns
  """
  organization_business_model_by_pk(id: uuid!): organization_business_model

  """fetch data from the table: "organization" using primary key columns"""
  organization_by_pk(id: uuid!): organization

  """
  fetch data from the table: "organization_headline"
  """
  organization_headline(
    """distinct select on columns"""
    distinct_on: [organization_headline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_headline_order_by!]

    """filter the rows returned"""
    where: organization_headline_bool_exp
  ): [organization_headline!]!

  """
  fetch aggregated fields from the table: "organization_headline"
  """
  organization_headline_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_headline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_headline_order_by!]

    """filter the rows returned"""
    where: organization_headline_bool_exp
  ): organization_headline_aggregate!

  """
  fetch data from the table: "organization_headline" using primary key columns
  """
  organization_headline_by_pk(id: uuid!): organization_headline

  """
  fetch data from the table: "organization_member"
  """
  organization_member(
    """distinct select on columns"""
    distinct_on: [organization_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_member_order_by!]

    """filter the rows returned"""
    where: organization_member_bool_exp
  ): [organization_member!]!

  """
  fetch aggregated fields from the table: "organization_member"
  """
  organization_member_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_member_order_by!]

    """filter the rows returned"""
    where: organization_member_bool_exp
  ): organization_member_aggregate!

  """
  fetch data from the table: "organization_member" using primary key columns
  """
  organization_member_by_pk(organization_id: uuid!, user_id: uuid!): organization_member

  """
  fetch data from the table: "organization_socials"
  """
  organization_socials(
    """distinct select on columns"""
    distinct_on: [organization_socials_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_socials_order_by!]

    """filter the rows returned"""
    where: organization_socials_bool_exp
  ): [organization_socials!]!

  """
  fetch aggregated fields from the table: "organization_socials"
  """
  organization_socials_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_socials_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_socials_order_by!]

    """filter the rows returned"""
    where: organization_socials_bool_exp
  ): organization_socials_aggregate!

  """
  fetch data from the table: "organization_socials" using primary key columns
  """
  organization_socials_by_pk(id: uuid!): organization_socials

  """
  fetch data from the table: "place"
  """
  place(
    """distinct select on columns"""
    distinct_on: [place_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [place_order_by!]

    """filter the rows returned"""
    where: place_bool_exp
  ): [place!]!

  """
  fetch aggregated fields from the table: "place"
  """
  place_aggregate(
    """distinct select on columns"""
    distinct_on: [place_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [place_order_by!]

    """filter the rows returned"""
    where: place_bool_exp
  ): place_aggregate!

  """fetch data from the table: "place" using primary key columns"""
  place_by_pk(id: uuid!): place

  """
  fetch data from the table: "product"
  """
  product(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """
  fetch aggregated fields from the table: "product"
  """
  product_aggregate(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!

  """
  fetch data from the table: "product_allotment_range"
  """
  product_allotment_range(
    """distinct select on columns"""
    distinct_on: [product_allotment_range_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_allotment_range_order_by!]

    """filter the rows returned"""
    where: product_allotment_range_bool_exp
  ): [product_allotment_range!]!

  """
  fetch aggregated fields from the table: "product_allotment_range"
  """
  product_allotment_range_aggregate(
    """distinct select on columns"""
    distinct_on: [product_allotment_range_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_allotment_range_order_by!]

    """filter the rows returned"""
    where: product_allotment_range_bool_exp
  ): product_allotment_range_aggregate!

  """
  fetch data from the table: "product_allotment_range" using primary key columns
  """
  product_allotment_range_by_pk(id: uuid!): product_allotment_range

  """
  fetch data from the table: "product_business_model"
  """
  product_business_model(
    """distinct select on columns"""
    distinct_on: [product_business_model_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_business_model_order_by!]

    """filter the rows returned"""
    where: product_business_model_bool_exp
  ): [product_business_model!]!

  """
  fetch aggregated fields from the table: "product_business_model"
  """
  product_business_model_aggregate(
    """distinct select on columns"""
    distinct_on: [product_business_model_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_business_model_order_by!]

    """filter the rows returned"""
    where: product_business_model_bool_exp
  ): product_business_model_aggregate!

  """
  fetch data from the table: "product_business_model" using primary key columns
  """
  product_business_model_by_pk(id: uuid!): product_business_model

  """fetch data from the table: "product" using primary key columns"""
  product_by_pk(id: uuid!): product

  """
  fetch data from the table: "product_description"
  """
  product_description(
    """distinct select on columns"""
    distinct_on: [product_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_description_order_by!]

    """filter the rows returned"""
    where: product_description_bool_exp
  ): [product_description!]!

  """
  fetch aggregated fields from the table: "product_description"
  """
  product_description_aggregate(
    """distinct select on columns"""
    distinct_on: [product_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_description_order_by!]

    """filter the rows returned"""
    where: product_description_bool_exp
  ): product_description_aggregate!

  """
  fetch data from the table: "product_description" using primary key columns
  """
  product_description_by_pk(id: uuid!): product_description

  """
  fetch data from the table: "product_feature"
  """
  product_feature(
    """distinct select on columns"""
    distinct_on: [product_feature_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_feature_order_by!]

    """filter the rows returned"""
    where: product_feature_bool_exp
  ): [product_feature!]!

  """
  fetch aggregated fields from the table: "product_feature"
  """
  product_feature_aggregate(
    """distinct select on columns"""
    distinct_on: [product_feature_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_feature_order_by!]

    """filter the rows returned"""
    where: product_feature_bool_exp
  ): product_feature_aggregate!

  """fetch data from the table: "product_feature" using primary key columns"""
  product_feature_by_pk(feature_id: uuid!, product_id: uuid!): product_feature

  """
  fetch data from the table: "product_group"
  """
  product_group(
    """distinct select on columns"""
    distinct_on: [product_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_group_order_by!]

    """filter the rows returned"""
    where: product_group_bool_exp
  ): [product_group!]!

  """
  fetch aggregated fields from the table: "product_group"
  """
  product_group_aggregate(
    """distinct select on columns"""
    distinct_on: [product_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_group_order_by!]

    """filter the rows returned"""
    where: product_group_bool_exp
  ): product_group_aggregate!

  """fetch data from the table: "product_group" using primary key columns"""
  product_group_by_pk(id: uuid!): product_group

  """
  fetch data from the table: "product_group_product"
  """
  product_group_product(
    """distinct select on columns"""
    distinct_on: [product_group_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_group_product_order_by!]

    """filter the rows returned"""
    where: product_group_product_bool_exp
  ): [product_group_product!]!

  """
  fetch aggregated fields from the table: "product_group_product"
  """
  product_group_product_aggregate(
    """distinct select on columns"""
    distinct_on: [product_group_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_group_product_order_by!]

    """filter the rows returned"""
    where: product_group_product_bool_exp
  ): product_group_product_aggregate!

  """
  fetch data from the table: "product_group_product" using primary key columns
  """
  product_group_product_by_pk(group_id: uuid!, product_id: uuid!): product_group_product

  """
  fetch data from the table: "product_headline"
  """
  product_headline(
    """distinct select on columns"""
    distinct_on: [product_headline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_headline_order_by!]

    """filter the rows returned"""
    where: product_headline_bool_exp
  ): [product_headline!]!

  """
  fetch aggregated fields from the table: "product_headline"
  """
  product_headline_aggregate(
    """distinct select on columns"""
    distinct_on: [product_headline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_headline_order_by!]

    """filter the rows returned"""
    where: product_headline_bool_exp
  ): product_headline_aggregate!

  """
  fetch data from the table: "product_headline" using primary key columns
  """
  product_headline_by_pk(id: uuid!): product_headline

  """
  fetch data from the table: "product_name"
  """
  product_name(
    """distinct select on columns"""
    distinct_on: [product_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_name_order_by!]

    """filter the rows returned"""
    where: product_name_bool_exp
  ): [product_name!]!

  """
  fetch aggregated fields from the table: "product_name"
  """
  product_name_aggregate(
    """distinct select on columns"""
    distinct_on: [product_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_name_order_by!]

    """filter the rows returned"""
    where: product_name_bool_exp
  ): product_name_aggregate!

  """fetch data from the table: "product_name" using primary key columns"""
  product_name_by_pk(id: uuid!): product_name

  """
  fetch data from the table: "product_supplement"
  """
  product_supplement(
    """distinct select on columns"""
    distinct_on: [product_supplement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_supplement_order_by!]

    """filter the rows returned"""
    where: product_supplement_bool_exp
  ): [product_supplement!]!

  """
  fetch aggregated fields from the table: "product_supplement"
  """
  product_supplement_aggregate(
    """distinct select on columns"""
    distinct_on: [product_supplement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_supplement_order_by!]

    """filter the rows returned"""
    where: product_supplement_bool_exp
  ): product_supplement_aggregate!

  """
  fetch data from the table: "product_supplement" using primary key columns
  """
  product_supplement_by_pk(product_id: uuid!, supplement_id: uuid!): product_supplement

  """
  fetch data from the table: "rate"
  """
  rate(
    """distinct select on columns"""
    distinct_on: [rate_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_order_by!]

    """filter the rows returned"""
    where: rate_bool_exp
  ): [rate!]!

  """
  fetch aggregated fields from the table: "rate"
  """
  rate_aggregate(
    """distinct select on columns"""
    distinct_on: [rate_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_order_by!]

    """filter the rows returned"""
    where: rate_bool_exp
  ): rate_aggregate!

  """fetch data from the table: "rate" using primary key columns"""
  rate_by_pk(id: uuid!): rate

  """
  fetch data from the table: "rate_headline"
  """
  rate_headline(
    """distinct select on columns"""
    distinct_on: [rate_headline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_headline_order_by!]

    """filter the rows returned"""
    where: rate_headline_bool_exp
  ): [rate_headline!]!

  """
  fetch aggregated fields from the table: "rate_headline"
  """
  rate_headline_aggregate(
    """distinct select on columns"""
    distinct_on: [rate_headline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_headline_order_by!]

    """filter the rows returned"""
    where: rate_headline_bool_exp
  ): rate_headline_aggregate!

  """fetch data from the table: "rate_headline" using primary key columns"""
  rate_headline_by_pk(id: uuid!): rate_headline

  """
  fetch data from the table: "rate_name"
  """
  rate_name(
    """distinct select on columns"""
    distinct_on: [rate_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_name_order_by!]

    """filter the rows returned"""
    where: rate_name_bool_exp
  ): [rate_name!]!

  """
  fetch aggregated fields from the table: "rate_name"
  """
  rate_name_aggregate(
    """distinct select on columns"""
    distinct_on: [rate_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_name_order_by!]

    """filter the rows returned"""
    where: rate_name_bool_exp
  ): rate_name_aggregate!

  """fetch data from the table: "rate_name" using primary key columns"""
  rate_name_by_pk(id: uuid!): rate_name

  """
  fetch data from the table: "rate_price_range"
  """
  rate_price_range(
    """distinct select on columns"""
    distinct_on: [rate_price_range_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_price_range_order_by!]

    """filter the rows returned"""
    where: rate_price_range_bool_exp
  ): [rate_price_range!]!

  """
  fetch aggregated fields from the table: "rate_price_range"
  """
  rate_price_range_aggregate(
    """distinct select on columns"""
    distinct_on: [rate_price_range_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_price_range_order_by!]

    """filter the rows returned"""
    where: rate_price_range_bool_exp
  ): rate_price_range_aggregate!

  """
  fetch data from the table: "rate_price_range" using primary key columns
  """
  rate_price_range_by_pk(id: uuid!): rate_price_range

  """
  fetch data from the table: "rate_type"
  """
  rate_type(
    """distinct select on columns"""
    distinct_on: [rate_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_type_order_by!]

    """filter the rows returned"""
    where: rate_type_bool_exp
  ): [rate_type!]!

  """
  fetch aggregated fields from the table: "rate_type"
  """
  rate_type_aggregate(
    """distinct select on columns"""
    distinct_on: [rate_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_type_order_by!]

    """filter the rows returned"""
    where: rate_type_bool_exp
  ): rate_type_aggregate!

  """fetch data from the table: "rate_type" using primary key columns"""
  rate_type_by_pk(id: String!): rate_type

  """
  fetch data from the table: "role"
  """
  role(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): [role!]!

  """
  fetch aggregated fields from the table: "role"
  """
  role_aggregate(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): role_aggregate!

  """fetch data from the table: "role" using primary key columns"""
  role_by_pk(id: String!): role

  """
  fetch data from the table: "site"
  """
  site(
    """distinct select on columns"""
    distinct_on: [site_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [site_order_by!]

    """filter the rows returned"""
    where: site_bool_exp
  ): [site!]!

  """
  fetch aggregated fields from the table: "site"
  """
  site_aggregate(
    """distinct select on columns"""
    distinct_on: [site_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [site_order_by!]

    """filter the rows returned"""
    where: site_bool_exp
  ): site_aggregate!

  """fetch data from the table: "site" using primary key columns"""
  site_by_pk(id: uuid!): site

  """
  fetch data from the table: "slug"
  """
  slug(
    """distinct select on columns"""
    distinct_on: [slug_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [slug_order_by!]

    """filter the rows returned"""
    where: slug_bool_exp
  ): [slug!]!

  """
  fetch aggregated fields from the table: "slug"
  """
  slug_aggregate(
    """distinct select on columns"""
    distinct_on: [slug_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [slug_order_by!]

    """filter the rows returned"""
    where: slug_bool_exp
  ): slug_aggregate!

  """fetch data from the table: "slug" using primary key columns"""
  slug_by_pk(id: uuid!): slug

  """
  fetch data from the table: "supplement"
  """
  supplement(
    """distinct select on columns"""
    distinct_on: [supplement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supplement_order_by!]

    """filter the rows returned"""
    where: supplement_bool_exp
  ): [supplement!]!

  """
  fetch aggregated fields from the table: "supplement"
  """
  supplement_aggregate(
    """distinct select on columns"""
    distinct_on: [supplement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supplement_order_by!]

    """filter the rows returned"""
    where: supplement_bool_exp
  ): supplement_aggregate!

  """fetch data from the table: "supplement" using primary key columns"""
  supplement_by_pk(id: uuid!): supplement

  """
  fetch data from the table: "supplement_prices"
  """
  supplement_prices(
    """distinct select on columns"""
    distinct_on: [supplement_prices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supplement_prices_order_by!]

    """filter the rows returned"""
    where: supplement_prices_bool_exp
  ): [supplement_prices!]!

  """
  fetch aggregated fields from the table: "supplement_prices"
  """
  supplement_prices_aggregate(
    """distinct select on columns"""
    distinct_on: [supplement_prices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supplement_prices_order_by!]

    """filter the rows returned"""
    where: supplement_prices_bool_exp
  ): supplement_prices_aggregate!

  """
  fetch data from the table: "supplement_type"
  """
  supplement_type(
    """distinct select on columns"""
    distinct_on: [supplement_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supplement_type_order_by!]

    """filter the rows returned"""
    where: supplement_type_bool_exp
  ): [supplement_type!]!

  """
  fetch aggregated fields from the table: "supplement_type"
  """
  supplement_type_aggregate(
    """distinct select on columns"""
    distinct_on: [supplement_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supplement_type_order_by!]

    """filter the rows returned"""
    where: supplement_type_bool_exp
  ): supplement_type_aggregate!

  """fetch data from the table: "supplement_type" using primary key columns"""
  supplement_type_by_pk(id: String!): supplement_type

  """
  fetch data from the table: "translated_text"
  """
  translated_text(
    """distinct select on columns"""
    distinct_on: [translated_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translated_text_order_by!]

    """filter the rows returned"""
    where: translated_text_bool_exp
  ): [translated_text!]!

  """
  fetch aggregated fields from the table: "translated_text"
  """
  translated_text_aggregate(
    """distinct select on columns"""
    distinct_on: [translated_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translated_text_order_by!]

    """filter the rows returned"""
    where: translated_text_bool_exp
  ): translated_text_aggregate!

  """fetch data from the table: "translated_text" using primary key columns"""
  translated_text_by_pk(id: uuid!): translated_text

  """
  fetch data from the table: "unit_management"
  """
  unit_management(
    """distinct select on columns"""
    distinct_on: [unit_management_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unit_management_order_by!]

    """filter the rows returned"""
    where: unit_management_bool_exp
  ): [unit_management!]!

  """
  fetch aggregated fields from the table: "unit_management"
  """
  unit_management_aggregate(
    """distinct select on columns"""
    distinct_on: [unit_management_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unit_management_order_by!]

    """filter the rows returned"""
    where: unit_management_bool_exp
  ): unit_management_aggregate!

  """fetch data from the table: "unit_management" using primary key columns"""
  unit_management_by_pk(id: String!): unit_management

  """fetch data from the table: "auth.users" using primary key columns"""
  user(id: uuid!): users

  """
  fetch data from the table: "auth.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "auth.users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """
  fetch data from the table: "venue"
  """
  venue(
    """distinct select on columns"""
    distinct_on: [venue_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_order_by!]

    """filter the rows returned"""
    where: venue_bool_exp
  ): [venue!]!

  """
  fetch aggregated fields from the table: "venue"
  """
  venue_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_order_by!]

    """filter the rows returned"""
    where: venue_bool_exp
  ): venue_aggregate!

  """fetch data from the table: "venue" using primary key columns"""
  venue_by_pk(id: uuid!): venue

  """
  fetch data from the table: "venue_description"
  """
  venue_description(
    """distinct select on columns"""
    distinct_on: [venue_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_description_order_by!]

    """filter the rows returned"""
    where: venue_description_bool_exp
  ): [venue_description!]!

  """
  fetch aggregated fields from the table: "venue_description"
  """
  venue_description_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_description_order_by!]

    """filter the rows returned"""
    where: venue_description_bool_exp
  ): venue_description_aggregate!

  """
  fetch data from the table: "venue_description" using primary key columns
  """
  venue_description_by_pk(id: uuid!): venue_description

  """
  fetch data from the table: "venue_facility"
  """
  venue_facility(
    """distinct select on columns"""
    distinct_on: [venue_facility_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_facility_order_by!]

    """filter the rows returned"""
    where: venue_facility_bool_exp
  ): [venue_facility!]!

  """
  fetch aggregated fields from the table: "venue_facility"
  """
  venue_facility_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_facility_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_facility_order_by!]

    """filter the rows returned"""
    where: venue_facility_bool_exp
  ): venue_facility_aggregate!

  """fetch data from the table: "venue_facility" using primary key columns"""
  venue_facility_by_pk(id: uuid!): venue_facility

  """
  fetch data from the table: "venue_facility_headline"
  """
  venue_facility_headline(
    """distinct select on columns"""
    distinct_on: [venue_facility_headline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_facility_headline_order_by!]

    """filter the rows returned"""
    where: venue_facility_headline_bool_exp
  ): [venue_facility_headline!]!

  """
  fetch aggregated fields from the table: "venue_facility_headline"
  """
  venue_facility_headline_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_facility_headline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_facility_headline_order_by!]

    """filter the rows returned"""
    where: venue_facility_headline_bool_exp
  ): venue_facility_headline_aggregate!

  """
  fetch data from the table: "venue_facility_headline" using primary key columns
  """
  venue_facility_headline_by_pk(id: uuid!): venue_facility_headline

  """
  fetch data from the table: "venue_facility_name"
  """
  venue_facility_name(
    """distinct select on columns"""
    distinct_on: [venue_facility_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_facility_name_order_by!]

    """filter the rows returned"""
    where: venue_facility_name_bool_exp
  ): [venue_facility_name!]!

  """
  fetch aggregated fields from the table: "venue_facility_name"
  """
  venue_facility_name_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_facility_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_facility_name_order_by!]

    """filter the rows returned"""
    where: venue_facility_name_bool_exp
  ): venue_facility_name_aggregate!

  """
  fetch data from the table: "venue_facility_name" using primary key columns
  """
  venue_facility_name_by_pk(id: uuid!): venue_facility_name

  """
  fetch data from the table: "venue_good_to_know"
  """
  venue_good_to_know(
    """distinct select on columns"""
    distinct_on: [venue_good_to_know_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_good_to_know_order_by!]

    """filter the rows returned"""
    where: venue_good_to_know_bool_exp
  ): [venue_good_to_know!]!

  """
  fetch aggregated fields from the table: "venue_good_to_know"
  """
  venue_good_to_know_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_good_to_know_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_good_to_know_order_by!]

    """filter the rows returned"""
    where: venue_good_to_know_bool_exp
  ): venue_good_to_know_aggregate!

  """
  fetch data from the table: "venue_good_to_know" using primary key columns
  """
  venue_good_to_know_by_pk(id: uuid!): venue_good_to_know

  """
  fetch data from the table: "venue_usps"
  """
  venue_usps(
    """distinct select on columns"""
    distinct_on: [venue_usps_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_usps_order_by!]

    """filter the rows returned"""
    where: venue_usps_bool_exp
  ): [venue_usps!]!

  """
  fetch aggregated fields from the table: "venue_usps"
  """
  venue_usps_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_usps_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_usps_order_by!]

    """filter the rows returned"""
    where: venue_usps_bool_exp
  ): venue_usps_aggregate!

  """fetch data from the table: "venue_usps" using primary key columns"""
  venue_usps_by_pk(id: uuid!): venue_usps

  """
  fetch data from the table: "venue_usps_line"
  """
  venue_usps_line(
    """distinct select on columns"""
    distinct_on: [venue_usps_line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_usps_line_order_by!]

    """filter the rows returned"""
    where: venue_usps_line_bool_exp
  ): [venue_usps_line!]!

  """
  fetch aggregated fields from the table: "venue_usps_line"
  """
  venue_usps_line_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_usps_line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_usps_line_order_by!]

    """filter the rows returned"""
    where: venue_usps_line_bool_exp
  ): venue_usps_line_aggregate!

  """fetch data from the table: "venue_usps_line" using primary key columns"""
  venue_usps_line_by_pk(id: uuid!): venue_usps_line

  """fetch data from the table: "storage.virus" using primary key columns"""
  virus(id: uuid!): virus

  """
  fetch data from the table: "storage.virus"
  """
  viruses(
    """distinct select on columns"""
    distinct_on: [virus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [virus_order_by!]

    """filter the rows returned"""
    where: virus_bool_exp
  ): [virus!]!

  """
  fetch aggregated fields from the table: "storage.virus"
  """
  virusesAggregate(
    """distinct select on columns"""
    distinct_on: [virus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [virus_order_by!]

    """filter the rows returned"""
    where: virus_bool_exp
  ): virus_aggregate!
}

"""
columns and relationships of "rate"
"""
type rate {
  availability_rules(
    """JSON select path"""
    path: String
  ): jsonb
  configuration(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  headline: rate_headline
  headline_id: uuid
  id: uuid!

  """An object relationship"""
  name: rate_name!
  name_id: uuid!

  """An array relationship"""
  price_calendar(
    """distinct select on columns"""
    distinct_on: [rate_price_range_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_price_range_order_by!]

    """filter the rows returned"""
    where: rate_price_range_bool_exp
  ): [rate_price_range!]!

  """An aggregate relationship"""
  price_calendar_aggregate(
    """distinct select on columns"""
    distinct_on: [rate_price_range_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_price_range_order_by!]

    """filter the rows returned"""
    where: rate_price_range_bool_exp
  ): rate_price_range_aggregate!
  price_rules(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  product: product!
  product_id: uuid!
}

"""
aggregated selection of "rate"
"""
type rate_aggregate {
  aggregate: rate_aggregate_fields
  nodes: [rate!]!
}

input rate_aggregate_bool_exp {
  count: rate_aggregate_bool_exp_count
}

input rate_aggregate_bool_exp_count {
  arguments: [rate_select_column!]
  distinct: Boolean
  filter: rate_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "rate"
"""
type rate_aggregate_fields {
  count(columns: [rate_select_column!], distinct: Boolean): Int!
  max: rate_max_fields
  min: rate_min_fields
}

"""
order by aggregate values of table "rate"
"""
input rate_aggregate_order_by {
  count: order_by
  max: rate_max_order_by
  min: rate_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input rate_append_input {
  availability_rules: jsonb
  configuration: jsonb
  price_rules: jsonb
}

"""
input type for inserting array relation for remote table "rate"
"""
input rate_arr_rel_insert_input {
  data: [rate_insert_input!]!

  """upsert condition"""
  on_conflict: rate_on_conflict
}

"""
Boolean expression to filter rows from the table "rate". All fields are combined with a logical 'AND'.
"""
input rate_bool_exp {
  _and: [rate_bool_exp!]
  _not: rate_bool_exp
  _or: [rate_bool_exp!]
  availability_rules: jsonb_comparison_exp
  configuration: jsonb_comparison_exp
  headline: rate_headline_bool_exp
  headline_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: rate_name_bool_exp
  name_id: uuid_comparison_exp
  price_calendar: rate_price_range_bool_exp
  price_calendar_aggregate: rate_price_range_aggregate_bool_exp
  price_rules: jsonb_comparison_exp
  product: product_bool_exp
  product_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "rate"
"""
enum rate_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  rate_pkey
}

input rate_create_input {
  id: uuid!
  organization_id: uuid!
  product_id: uuid!
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input rate_delete_at_path_input {
  availability_rules: [String!]
  configuration: [String!]
  price_rules: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input rate_delete_elem_input {
  availability_rules: Int
  configuration: Int
  price_rules: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input rate_delete_key_input {
  availability_rules: String
  configuration: String
  price_rules: String
}

"""
columns and relationships of "rate_headline"
"""
type rate_headline {
  de: String
  en: String
  es: String
  fr: String
  id: uuid!
}

"""
aggregated selection of "rate_headline"
"""
type rate_headline_aggregate {
  aggregate: rate_headline_aggregate_fields
  nodes: [rate_headline!]!
}

"""
aggregate fields of "rate_headline"
"""
type rate_headline_aggregate_fields {
  count(columns: [rate_headline_select_column!], distinct: Boolean): Int!
  max: rate_headline_max_fields
  min: rate_headline_min_fields
}

"""
Boolean expression to filter rows from the table "rate_headline". All fields are combined with a logical 'AND'.
"""
input rate_headline_bool_exp {
  _and: [rate_headline_bool_exp!]
  _not: rate_headline_bool_exp
  _or: [rate_headline_bool_exp!]
  de: String_comparison_exp
  en: String_comparison_exp
  es: String_comparison_exp
  fr: String_comparison_exp
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "rate_headline"
"""
enum rate_headline_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  rate_headline_pkey
}

"""
input type for inserting data into table "rate_headline"
"""
input rate_headline_insert_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate max on columns"""
type rate_headline_max_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate min on columns"""
type rate_headline_min_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
response of any mutation on the table "rate_headline"
"""
type rate_headline_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rate_headline!]!
}

"""
input type for inserting object relation for remote table "rate_headline"
"""
input rate_headline_obj_rel_insert_input {
  data: rate_headline_insert_input!

  """upsert condition"""
  on_conflict: rate_headline_on_conflict
}

"""
on_conflict condition type for table "rate_headline"
"""
input rate_headline_on_conflict {
  constraint: rate_headline_constraint!
  update_columns: [rate_headline_update_column!]! = []
  where: rate_headline_bool_exp
}

"""Ordering options when selecting data from "rate_headline"."""
input rate_headline_order_by {
  de: order_by
  en: order_by
  es: order_by
  fr: order_by
  id: order_by
}

"""primary key columns input for table: rate_headline"""
input rate_headline_pk_columns_input {
  id: uuid!
}

"""
select columns of table "rate_headline"
"""
enum rate_headline_select_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

"""
input type for updating data in table "rate_headline"
"""
input rate_headline_set_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
Streaming cursor of the table "rate_headline"
"""
input rate_headline_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rate_headline_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rate_headline_stream_cursor_value_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
update columns of table "rate_headline"
"""
enum rate_headline_update_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

input rate_headline_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rate_headline_set_input

  """filter the rows which have to be updated"""
  where: rate_headline_bool_exp!
}

"""
input type for inserting data into table "rate"
"""
input rate_insert_input {
  availability_rules: jsonb
  configuration: jsonb
  headline: rate_headline_obj_rel_insert_input
  headline_id: uuid
  id: uuid
  name: rate_name_obj_rel_insert_input
  name_id: uuid
  price_calendar: rate_price_range_arr_rel_insert_input
  price_rules: jsonb
  product: product_obj_rel_insert_input
  product_id: uuid
}

"""aggregate max on columns"""
type rate_max_fields {
  headline_id: uuid
  id: uuid
  name_id: uuid
  product_id: uuid
}

"""
order by max() on columns of table "rate"
"""
input rate_max_order_by {
  headline_id: order_by
  id: order_by
  name_id: order_by
  product_id: order_by
}

"""aggregate min on columns"""
type rate_min_fields {
  headline_id: uuid
  id: uuid
  name_id: uuid
  product_id: uuid
}

"""
order by min() on columns of table "rate"
"""
input rate_min_order_by {
  headline_id: order_by
  id: order_by
  name_id: order_by
  product_id: order_by
}

"""
response of any mutation on the table "rate"
"""
type rate_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rate!]!
}

"""
columns and relationships of "rate_name"
"""
type rate_name {
  de: String
  en: String
  es: String
  fr: String
  id: uuid!
}

"""
aggregated selection of "rate_name"
"""
type rate_name_aggregate {
  aggregate: rate_name_aggregate_fields
  nodes: [rate_name!]!
}

"""
aggregate fields of "rate_name"
"""
type rate_name_aggregate_fields {
  count(columns: [rate_name_select_column!], distinct: Boolean): Int!
  max: rate_name_max_fields
  min: rate_name_min_fields
}

"""
Boolean expression to filter rows from the table "rate_name". All fields are combined with a logical 'AND'.
"""
input rate_name_bool_exp {
  _and: [rate_name_bool_exp!]
  _not: rate_name_bool_exp
  _or: [rate_name_bool_exp!]
  de: String_comparison_exp
  en: String_comparison_exp
  es: String_comparison_exp
  fr: String_comparison_exp
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "rate_name"
"""
enum rate_name_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  rate_name_pkey
}

"""
input type for inserting data into table "rate_name"
"""
input rate_name_insert_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate max on columns"""
type rate_name_max_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate min on columns"""
type rate_name_min_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
response of any mutation on the table "rate_name"
"""
type rate_name_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rate_name!]!
}

"""
input type for inserting object relation for remote table "rate_name"
"""
input rate_name_obj_rel_insert_input {
  data: rate_name_insert_input!

  """upsert condition"""
  on_conflict: rate_name_on_conflict
}

"""
on_conflict condition type for table "rate_name"
"""
input rate_name_on_conflict {
  constraint: rate_name_constraint!
  update_columns: [rate_name_update_column!]! = []
  where: rate_name_bool_exp
}

"""Ordering options when selecting data from "rate_name"."""
input rate_name_order_by {
  de: order_by
  en: order_by
  es: order_by
  fr: order_by
  id: order_by
}

"""primary key columns input for table: rate_name"""
input rate_name_pk_columns_input {
  id: uuid!
}

"""
select columns of table "rate_name"
"""
enum rate_name_select_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

"""
input type for updating data in table "rate_name"
"""
input rate_name_set_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
Streaming cursor of the table "rate_name"
"""
input rate_name_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rate_name_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rate_name_stream_cursor_value_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
update columns of table "rate_name"
"""
enum rate_name_update_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

input rate_name_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rate_name_set_input

  """filter the rows which have to be updated"""
  where: rate_name_bool_exp!
}

"""
input type for inserting object relation for remote table "rate"
"""
input rate_obj_rel_insert_input {
  data: rate_insert_input!

  """upsert condition"""
  on_conflict: rate_on_conflict
}

"""
on_conflict condition type for table "rate"
"""
input rate_on_conflict {
  constraint: rate_constraint!
  update_columns: [rate_update_column!]! = []
  where: rate_bool_exp
}

"""Ordering options when selecting data from "rate"."""
input rate_order_by {
  availability_rules: order_by
  configuration: order_by
  headline: rate_headline_order_by
  headline_id: order_by
  id: order_by
  name: rate_name_order_by
  name_id: order_by
  price_calendar_aggregate: rate_price_range_aggregate_order_by
  price_rules: order_by
  product: product_order_by
  product_id: order_by
}

"""primary key columns input for table: rate"""
input rate_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input rate_prepend_input {
  availability_rules: jsonb
  configuration: jsonb
  price_rules: jsonb
}

"""
columns and relationships of "rate_price_range"
"""
type rate_price_range {
  daily: numeric!
  from: timestamp!
  hourly: numeric!
  id: uuid!

  """An object relationship"""
  rate: rate!
  rate_id: uuid!
  to: timestamp!
}

"""
aggregated selection of "rate_price_range"
"""
type rate_price_range_aggregate {
  aggregate: rate_price_range_aggregate_fields
  nodes: [rate_price_range!]!
}

input rate_price_range_aggregate_bool_exp {
  count: rate_price_range_aggregate_bool_exp_count
}

input rate_price_range_aggregate_bool_exp_count {
  arguments: [rate_price_range_select_column!]
  distinct: Boolean
  filter: rate_price_range_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "rate_price_range"
"""
type rate_price_range_aggregate_fields {
  avg: rate_price_range_avg_fields
  count(columns: [rate_price_range_select_column!], distinct: Boolean): Int!
  max: rate_price_range_max_fields
  min: rate_price_range_min_fields
  stddev: rate_price_range_stddev_fields
  stddev_pop: rate_price_range_stddev_pop_fields
  stddev_samp: rate_price_range_stddev_samp_fields
  sum: rate_price_range_sum_fields
  var_pop: rate_price_range_var_pop_fields
  var_samp: rate_price_range_var_samp_fields
  variance: rate_price_range_variance_fields
}

"""
order by aggregate values of table "rate_price_range"
"""
input rate_price_range_aggregate_order_by {
  avg: rate_price_range_avg_order_by
  count: order_by
  max: rate_price_range_max_order_by
  min: rate_price_range_min_order_by
  stddev: rate_price_range_stddev_order_by
  stddev_pop: rate_price_range_stddev_pop_order_by
  stddev_samp: rate_price_range_stddev_samp_order_by
  sum: rate_price_range_sum_order_by
  var_pop: rate_price_range_var_pop_order_by
  var_samp: rate_price_range_var_samp_order_by
  variance: rate_price_range_variance_order_by
}

"""
input type for inserting array relation for remote table "rate_price_range"
"""
input rate_price_range_arr_rel_insert_input {
  data: [rate_price_range_insert_input!]!

  """upsert condition"""
  on_conflict: rate_price_range_on_conflict
}

"""aggregate avg on columns"""
type rate_price_range_avg_fields {
  daily: Float
  hourly: Float
}

"""
order by avg() on columns of table "rate_price_range"
"""
input rate_price_range_avg_order_by {
  daily: order_by
  hourly: order_by
}

"""
Boolean expression to filter rows from the table "rate_price_range". All fields are combined with a logical 'AND'.
"""
input rate_price_range_bool_exp {
  _and: [rate_price_range_bool_exp!]
  _not: rate_price_range_bool_exp
  _or: [rate_price_range_bool_exp!]
  daily: numeric_comparison_exp
  from: timestamp_comparison_exp
  hourly: numeric_comparison_exp
  id: uuid_comparison_exp
  rate: rate_bool_exp
  rate_id: uuid_comparison_exp
  to: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "rate_price_range"
"""
enum rate_price_range_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  rate_price_range_pkey
}

"""
input type for incrementing numeric columns in table "rate_price_range"
"""
input rate_price_range_inc_input {
  daily: numeric
  hourly: numeric
}

"""
input type for inserting data into table "rate_price_range"
"""
input rate_price_range_insert_input {
  daily: numeric
  from: timestamp
  hourly: numeric
  id: uuid
  rate: rate_obj_rel_insert_input
  rate_id: uuid
  to: timestamp
}

"""aggregate max on columns"""
type rate_price_range_max_fields {
  daily: numeric
  from: timestamp
  hourly: numeric
  id: uuid
  rate_id: uuid
  to: timestamp
}

"""
order by max() on columns of table "rate_price_range"
"""
input rate_price_range_max_order_by {
  daily: order_by
  from: order_by
  hourly: order_by
  id: order_by
  rate_id: order_by
  to: order_by
}

"""aggregate min on columns"""
type rate_price_range_min_fields {
  daily: numeric
  from: timestamp
  hourly: numeric
  id: uuid
  rate_id: uuid
  to: timestamp
}

"""
order by min() on columns of table "rate_price_range"
"""
input rate_price_range_min_order_by {
  daily: order_by
  from: order_by
  hourly: order_by
  id: order_by
  rate_id: order_by
  to: order_by
}

"""
response of any mutation on the table "rate_price_range"
"""
type rate_price_range_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rate_price_range!]!
}

"""
on_conflict condition type for table "rate_price_range"
"""
input rate_price_range_on_conflict {
  constraint: rate_price_range_constraint!
  update_columns: [rate_price_range_update_column!]! = []
  where: rate_price_range_bool_exp
}

"""Ordering options when selecting data from "rate_price_range"."""
input rate_price_range_order_by {
  daily: order_by
  from: order_by
  hourly: order_by
  id: order_by
  rate: rate_order_by
  rate_id: order_by
  to: order_by
}

"""primary key columns input for table: rate_price_range"""
input rate_price_range_pk_columns_input {
  id: uuid!
}

"""
select columns of table "rate_price_range"
"""
enum rate_price_range_select_column {
  """column name"""
  daily

  """column name"""
  from

  """column name"""
  hourly

  """column name"""
  id

  """column name"""
  rate_id

  """column name"""
  to
}

"""
input type for updating data in table "rate_price_range"
"""
input rate_price_range_set_input {
  daily: numeric
  from: timestamp
  hourly: numeric
  id: uuid
  rate_id: uuid
  to: timestamp
}

"""aggregate stddev on columns"""
type rate_price_range_stddev_fields {
  daily: Float
  hourly: Float
}

"""
order by stddev() on columns of table "rate_price_range"
"""
input rate_price_range_stddev_order_by {
  daily: order_by
  hourly: order_by
}

"""aggregate stddev_pop on columns"""
type rate_price_range_stddev_pop_fields {
  daily: Float
  hourly: Float
}

"""
order by stddev_pop() on columns of table "rate_price_range"
"""
input rate_price_range_stddev_pop_order_by {
  daily: order_by
  hourly: order_by
}

"""aggregate stddev_samp on columns"""
type rate_price_range_stddev_samp_fields {
  daily: Float
  hourly: Float
}

"""
order by stddev_samp() on columns of table "rate_price_range"
"""
input rate_price_range_stddev_samp_order_by {
  daily: order_by
  hourly: order_by
}

"""
Streaming cursor of the table "rate_price_range"
"""
input rate_price_range_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rate_price_range_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rate_price_range_stream_cursor_value_input {
  daily: numeric
  from: timestamp
  hourly: numeric
  id: uuid
  rate_id: uuid
  to: timestamp
}

"""aggregate sum on columns"""
type rate_price_range_sum_fields {
  daily: numeric
  hourly: numeric
}

"""
order by sum() on columns of table "rate_price_range"
"""
input rate_price_range_sum_order_by {
  daily: order_by
  hourly: order_by
}

"""
update columns of table "rate_price_range"
"""
enum rate_price_range_update_column {
  """column name"""
  daily

  """column name"""
  from

  """column name"""
  hourly

  """column name"""
  id

  """column name"""
  rate_id

  """column name"""
  to
}

input rate_price_range_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: rate_price_range_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: rate_price_range_set_input

  """filter the rows which have to be updated"""
  where: rate_price_range_bool_exp!
}

"""aggregate var_pop on columns"""
type rate_price_range_var_pop_fields {
  daily: Float
  hourly: Float
}

"""
order by var_pop() on columns of table "rate_price_range"
"""
input rate_price_range_var_pop_order_by {
  daily: order_by
  hourly: order_by
}

"""aggregate var_samp on columns"""
type rate_price_range_var_samp_fields {
  daily: Float
  hourly: Float
}

"""
order by var_samp() on columns of table "rate_price_range"
"""
input rate_price_range_var_samp_order_by {
  daily: order_by
  hourly: order_by
}

"""aggregate variance on columns"""
type rate_price_range_variance_fields {
  daily: Float
  hourly: Float
}

"""
order by variance() on columns of table "rate_price_range"
"""
input rate_price_range_variance_order_by {
  daily: order_by
  hourly: order_by
}

input rate_save_input {
  configuration: json
  headline: multilanguage_field_input
  id: String!
  name: multilanguage_field_input
  price_calendar: [date_range_with_value!]!
  product_id: String!
}

"""
select columns of table "rate"
"""
enum rate_select_column {
  """column name"""
  availability_rules

  """column name"""
  configuration

  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  price_rules

  """column name"""
  product_id
}

"""
input type for updating data in table "rate"
"""
input rate_set_input {
  availability_rules: jsonb
  configuration: jsonb
  headline_id: uuid
  id: uuid
  name_id: uuid
  price_rules: jsonb
  product_id: uuid
}

"""
Streaming cursor of the table "rate"
"""
input rate_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rate_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rate_stream_cursor_value_input {
  availability_rules: jsonb
  configuration: jsonb
  headline_id: uuid
  id: uuid
  name_id: uuid
  price_rules: jsonb
  product_id: uuid
}

"""
columns and relationships of "rate_type"
"""
type rate_type {
  description: String!
  id: String!
}

"""
aggregated selection of "rate_type"
"""
type rate_type_aggregate {
  aggregate: rate_type_aggregate_fields
  nodes: [rate_type!]!
}

"""
aggregate fields of "rate_type"
"""
type rate_type_aggregate_fields {
  count(columns: [rate_type_select_column!], distinct: Boolean): Int!
  max: rate_type_max_fields
  min: rate_type_min_fields
}

"""
Boolean expression to filter rows from the table "rate_type". All fields are combined with a logical 'AND'.
"""
input rate_type_bool_exp {
  _and: [rate_type_bool_exp!]
  _not: rate_type_bool_exp
  _or: [rate_type_bool_exp!]
  description: String_comparison_exp
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "rate_type"
"""
enum rate_type_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  rate_type_pkey
}

enum rate_type_enum {
  """Daily"""
  DAILY

  """Taximeter"""
  TAXIMETER

  """Time slots"""
  TIME_SLOTS
}

"""
Boolean expression to compare columns of type "rate_type_enum". All fields are combined with logical 'AND'.
"""
input rate_type_enum_comparison_exp {
  _eq: rate_type_enum
  _in: [rate_type_enum!]
  _is_null: Boolean
  _neq: rate_type_enum
  _nin: [rate_type_enum!]
}

"""
input type for inserting data into table "rate_type"
"""
input rate_type_insert_input {
  description: String
  id: String
}

"""aggregate max on columns"""
type rate_type_max_fields {
  description: String
  id: String
}

"""aggregate min on columns"""
type rate_type_min_fields {
  description: String
  id: String
}

"""
response of any mutation on the table "rate_type"
"""
type rate_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rate_type!]!
}

"""
on_conflict condition type for table "rate_type"
"""
input rate_type_on_conflict {
  constraint: rate_type_constraint!
  update_columns: [rate_type_update_column!]! = []
  where: rate_type_bool_exp
}

"""Ordering options when selecting data from "rate_type"."""
input rate_type_order_by {
  description: order_by
  id: order_by
}

"""primary key columns input for table: rate_type"""
input rate_type_pk_columns_input {
  id: String!
}

"""
select columns of table "rate_type"
"""
enum rate_type_select_column {
  """column name"""
  description

  """column name"""
  id
}

"""
input type for updating data in table "rate_type"
"""
input rate_type_set_input {
  description: String
  id: String
}

"""
Streaming cursor of the table "rate_type"
"""
input rate_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rate_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rate_type_stream_cursor_value_input {
  description: String
  id: String
}

"""
update columns of table "rate_type"
"""
enum rate_type_update_column {
  """column name"""
  description

  """column name"""
  id
}

input rate_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rate_type_set_input

  """filter the rows which have to be updated"""
  where: rate_type_bool_exp!
}

"""
update columns of table "rate"
"""
enum rate_update_column {
  """column name"""
  availability_rules

  """column name"""
  configuration

  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  price_rules

  """column name"""
  product_id
}

input rate_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: rate_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: rate_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: rate_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: rate_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: rate_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: rate_set_input

  """filter the rows which have to be updated"""
  where: rate_bool_exp!
}

"""
columns and relationships of "role"
"""
type role {
  description: String!
  id: String!
}

"""
aggregated selection of "role"
"""
type role_aggregate {
  aggregate: role_aggregate_fields
  nodes: [role!]!
}

"""
aggregate fields of "role"
"""
type role_aggregate_fields {
  count(columns: [role_select_column!], distinct: Boolean): Int!
  max: role_max_fields
  min: role_min_fields
}

"""
Boolean expression to filter rows from the table "role". All fields are combined with a logical 'AND'.
"""
input role_bool_exp {
  _and: [role_bool_exp!]
  _not: role_bool_exp
  _or: [role_bool_exp!]
  description: String_comparison_exp
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "role"
"""
enum role_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  role_pkey
}

enum role_enum {
  """Administrator"""
  ADMIN

  """Editor"""
  EDITOR

  """Viewer"""
  VIEWER
}

"""
Boolean expression to compare columns of type "role_enum". All fields are combined with logical 'AND'.
"""
input role_enum_comparison_exp {
  _eq: role_enum
  _in: [role_enum!]
  _is_null: Boolean
  _neq: role_enum
  _nin: [role_enum!]
}

"""
input type for inserting data into table "role"
"""
input role_insert_input {
  description: String
  id: String
}

"""aggregate max on columns"""
type role_max_fields {
  description: String
  id: String
}

"""aggregate min on columns"""
type role_min_fields {
  description: String
  id: String
}

"""
response of any mutation on the table "role"
"""
type role_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [role!]!
}

"""
on_conflict condition type for table "role"
"""
input role_on_conflict {
  constraint: role_constraint!
  update_columns: [role_update_column!]! = []
  where: role_bool_exp
}

"""Ordering options when selecting data from "role"."""
input role_order_by {
  description: order_by
  id: order_by
}

"""primary key columns input for table: role"""
input role_pk_columns_input {
  id: String!
}

"""
select columns of table "role"
"""
enum role_select_column {
  """column name"""
  description

  """column name"""
  id
}

"""
input type for updating data in table "role"
"""
input role_set_input {
  description: String
  id: String
}

"""
Streaming cursor of the table "role"
"""
input role_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: role_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input role_stream_cursor_value_input {
  description: String
  id: String
}

"""
update columns of table "role"
"""
enum role_update_column {
  """column name"""
  description

  """column name"""
  id
}

input role_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: role_set_input

  """filter the rows which have to be updated"""
  where: role_bool_exp!
}

input save_product_features_input {
  features: [feature_with_value_input!]!
  organization_id: uuid!
  product_id: uuid!
}

input search_params_input {
  date_range: date_range!
  units: [search_unit_input!]!
}

input search_unit_input {
  people: [person_input!]
}

input selected_item {
  value: uuid!
}

"""
columns and relationships of "site"
"""
type site {
  id: uuid!

  """An object relationship"""
  organization: organization!
  organization_id: uuid!
  url: String!
}

"""
aggregated selection of "site"
"""
type site_aggregate {
  aggregate: site_aggregate_fields
  nodes: [site!]!
}

input site_aggregate_bool_exp {
  count: site_aggregate_bool_exp_count
}

input site_aggregate_bool_exp_count {
  arguments: [site_select_column!]
  distinct: Boolean
  filter: site_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "site"
"""
type site_aggregate_fields {
  count(columns: [site_select_column!], distinct: Boolean): Int!
  max: site_max_fields
  min: site_min_fields
}

"""
order by aggregate values of table "site"
"""
input site_aggregate_order_by {
  count: order_by
  max: site_max_order_by
  min: site_min_order_by
}

"""
input type for inserting array relation for remote table "site"
"""
input site_arr_rel_insert_input {
  data: [site_insert_input!]!

  """upsert condition"""
  on_conflict: site_on_conflict
}

"""
Boolean expression to filter rows from the table "site". All fields are combined with a logical 'AND'.
"""
input site_bool_exp {
  _and: [site_bool_exp!]
  _not: site_bool_exp
  _or: [site_bool_exp!]
  id: uuid_comparison_exp
  organization: organization_bool_exp
  organization_id: uuid_comparison_exp
  url: String_comparison_exp
}

"""
unique or primary key constraints on table "site"
"""
enum site_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  site_pkey
}

"""
input type for inserting data into table "site"
"""
input site_insert_input {
  id: uuid
  organization: organization_obj_rel_insert_input
  organization_id: uuid
  url: String
}

"""aggregate max on columns"""
type site_max_fields {
  id: uuid
  organization_id: uuid
  url: String
}

"""
order by max() on columns of table "site"
"""
input site_max_order_by {
  id: order_by
  organization_id: order_by
  url: order_by
}

"""aggregate min on columns"""
type site_min_fields {
  id: uuid
  organization_id: uuid
  url: String
}

"""
order by min() on columns of table "site"
"""
input site_min_order_by {
  id: order_by
  organization_id: order_by
  url: order_by
}

"""
response of any mutation on the table "site"
"""
type site_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [site!]!
}

"""
on_conflict condition type for table "site"
"""
input site_on_conflict {
  constraint: site_constraint!
  update_columns: [site_update_column!]! = []
  where: site_bool_exp
}

"""Ordering options when selecting data from "site"."""
input site_order_by {
  id: order_by
  organization: organization_order_by
  organization_id: order_by
  url: order_by
}

"""primary key columns input for table: site"""
input site_pk_columns_input {
  id: uuid!
}

"""
select columns of table "site"
"""
enum site_select_column {
  """column name"""
  id

  """column name"""
  organization_id

  """column name"""
  url
}

"""
input type for updating data in table "site"
"""
input site_set_input {
  id: uuid
  organization_id: uuid
  url: String
}

"""
Streaming cursor of the table "site"
"""
input site_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: site_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input site_stream_cursor_value_input {
  id: uuid
  organization_id: uuid
  url: String
}

"""
update columns of table "site"
"""
enum site_update_column {
  """column name"""
  id

  """column name"""
  organization_id

  """column name"""
  url
}

input site_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: site_set_input

  """filter the rows which have to be updated"""
  where: site_bool_exp!
}

"""
columns and relationships of "slug"
"""
type slug {
  de: String
  en: String
  es: String
  fr: String
  id: uuid!
}

"""
aggregated selection of "slug"
"""
type slug_aggregate {
  aggregate: slug_aggregate_fields
  nodes: [slug!]!
}

"""
aggregate fields of "slug"
"""
type slug_aggregate_fields {
  count(columns: [slug_select_column!], distinct: Boolean): Int!
  max: slug_max_fields
  min: slug_min_fields
}

"""
Boolean expression to filter rows from the table "slug". All fields are combined with a logical 'AND'.
"""
input slug_bool_exp {
  _and: [slug_bool_exp!]
  _not: slug_bool_exp
  _or: [slug_bool_exp!]
  de: String_comparison_exp
  en: String_comparison_exp
  es: String_comparison_exp
  fr: String_comparison_exp
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "slug"
"""
enum slug_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  slug_pkey
}

"""
input type for inserting data into table "slug"
"""
input slug_insert_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate max on columns"""
type slug_max_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate min on columns"""
type slug_min_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
response of any mutation on the table "slug"
"""
type slug_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [slug!]!
}

"""
input type for inserting object relation for remote table "slug"
"""
input slug_obj_rel_insert_input {
  data: slug_insert_input!

  """upsert condition"""
  on_conflict: slug_on_conflict
}

"""
on_conflict condition type for table "slug"
"""
input slug_on_conflict {
  constraint: slug_constraint!
  update_columns: [slug_update_column!]! = []
  where: slug_bool_exp
}

"""Ordering options when selecting data from "slug"."""
input slug_order_by {
  de: order_by
  en: order_by
  es: order_by
  fr: order_by
  id: order_by
}

"""primary key columns input for table: slug"""
input slug_pk_columns_input {
  id: uuid!
}

"""
select columns of table "slug"
"""
enum slug_select_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

"""
input type for updating data in table "slug"
"""
input slug_set_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
Streaming cursor of the table "slug"
"""
input slug_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: slug_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input slug_stream_cursor_value_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
update columns of table "slug"
"""
enum slug_update_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

input slug_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: slug_set_input

  """filter the rows which have to be updated"""
  where: slug_bool_exp!
}

scalar smallint

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

type subscription_root {
  """fetch data from the table: "auth.providers" using primary key columns"""
  authProvider(id: String!): authProviders

  """
  fetch data from the table: "auth.provider_requests" using primary key columns
  """
  authProviderRequest(id: uuid!): authProviderRequests

  """
  fetch data from the table: "auth.provider_requests"
  """
  authProviderRequests(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch aggregated fields from the table: "auth.provider_requests"
  """
  authProviderRequestsAggregate(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): authProviderRequests_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.provider_requests"
  """
  authProviderRequests_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authProviderRequests_stream_cursor_input]!

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch data from the table: "auth.providers"
  """
  authProviders(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  authProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): authProviders_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.providers"
  """
  authProviders_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authProviders_stream_cursor_input]!

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  authRefreshToken(id: uuid!): authRefreshTokens

  """
  fetch data from the table: "auth.refresh_token_types" using primary key columns
  """
  authRefreshTokenType(value: String!): authRefreshTokenTypes

  """
  fetch data from the table: "auth.refresh_token_types"
  """
  authRefreshTokenTypes(
    """distinct select on columns"""
    distinct_on: [authRefreshTokenTypes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokenTypes_order_by!]

    """filter the rows returned"""
    where: authRefreshTokenTypes_bool_exp
  ): [authRefreshTokenTypes!]!

  """
  fetch aggregated fields from the table: "auth.refresh_token_types"
  """
  authRefreshTokenTypesAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokenTypes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokenTypes_order_by!]

    """filter the rows returned"""
    where: authRefreshTokenTypes_bool_exp
  ): authRefreshTokenTypes_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.refresh_token_types"
  """
  authRefreshTokenTypes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authRefreshTokenTypes_stream_cursor_input]!

    """filter the rows returned"""
    where: authRefreshTokenTypes_bool_exp
  ): [authRefreshTokenTypes!]!

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  authRefreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  authRefreshTokensAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.refresh_tokens"
  """
  authRefreshTokens_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authRefreshTokens_stream_cursor_input]!

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """fetch data from the table: "auth.roles" using primary key columns"""
  authRole(role: String!): authRoles

  """
  fetch data from the table: "auth.roles"
  """
  authRoles(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  authRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): authRoles_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.roles"
  """
  authRoles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authRoles_stream_cursor_input]!

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch data from the table: "auth.user_providers" using primary key columns
  """
  authUserProvider(id: uuid!): authUserProviders

  """
  fetch data from the table: "auth.user_providers"
  """
  authUserProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """
  fetch aggregated fields from the table: "auth.user_providers"
  """
  authUserProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.user_providers"
  """
  authUserProviders_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserProviders_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """fetch data from the table: "auth.user_roles" using primary key columns"""
  authUserRole(id: uuid!): authUserRoles

  """
  fetch data from the table: "auth.user_roles"
  """
  authUserRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch aggregated fields from the table: "auth.user_roles"
  """
  authUserRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.user_roles"
  """
  authUserRoles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserRoles_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch data from the table: "auth.user_security_keys" using primary key columns
  """
  authUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  fetch data from the table: "auth.user_security_keys"
  """
  authUserSecurityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """
  fetch aggregated fields from the table: "auth.user_security_keys"
  """
  authUserSecurityKeysAggregate(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): authUserSecurityKeys_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.user_security_keys"
  """
  authUserSecurityKeys_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserSecurityKeys_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """
  fetch data from the table: "booking"
  """
  booking(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): [booking!]!

  """
  fetch aggregated fields from the table: "booking"
  """
  booking_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): booking_aggregate!

  """fetch data from the table: "booking" using primary key columns"""
  booking_by_pk(id: uuid!): booking

  """
  fetch data from the table: "booking_events.event_type"
  """
  booking_events_event_type(
    """distinct select on columns"""
    distinct_on: [booking_events_event_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_events_event_type_order_by!]

    """filter the rows returned"""
    where: booking_events_event_type_bool_exp
  ): [booking_events_event_type!]!

  """
  fetch aggregated fields from the table: "booking_events.event_type"
  """
  booking_events_event_type_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_events_event_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_events_event_type_order_by!]

    """filter the rows returned"""
    where: booking_events_event_type_bool_exp
  ): booking_events_event_type_aggregate!

  """
  fetch data from the table: "booking_events.event_type" using primary key columns
  """
  booking_events_event_type_by_pk(id: String!): booking_events_event_type

  """
  fetch data from the table in a streaming manner: "booking_events.event_type"
  """
  booking_events_event_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [booking_events_event_type_stream_cursor_input]!

    """filter the rows returned"""
    where: booking_events_event_type_bool_exp
  ): [booking_events_event_type!]!

  """
  fetch data from the table: "booking_events.main"
  """
  booking_events_main(
    """distinct select on columns"""
    distinct_on: [booking_events_main_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_events_main_order_by!]

    """filter the rows returned"""
    where: booking_events_main_bool_exp
  ): [booking_events_main!]!

  """
  fetch aggregated fields from the table: "booking_events.main"
  """
  booking_events_main_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_events_main_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_events_main_order_by!]

    """filter the rows returned"""
    where: booking_events_main_bool_exp
  ): booking_events_main_aggregate!

  """
  fetch data from the table: "booking_events.main" using primary key columns
  """
  booking_events_main_by_pk(id: uuid!): booking_events_main

  """
  fetch data from the table in a streaming manner: "booking_events.main"
  """
  booking_events_main_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [booking_events_main_stream_cursor_input]!

    """filter the rows returned"""
    where: booking_events_main_bool_exp
  ): [booking_events_main!]!

  """
  fetch data from the table: "booking_events.version"
  """
  booking_events_version(
    """distinct select on columns"""
    distinct_on: [booking_events_version_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_events_version_order_by!]

    """filter the rows returned"""
    where: booking_events_version_bool_exp
  ): [booking_events_version!]!

  """
  fetch aggregated fields from the table: "booking_events.version"
  """
  booking_events_version_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_events_version_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_events_version_order_by!]

    """filter the rows returned"""
    where: booking_events_version_bool_exp
  ): booking_events_version_aggregate!

  """
  fetch data from the table: "booking_events.version" using primary key columns
  """
  booking_events_version_by_pk(id: uuid!): booking_events_version

  """
  fetch data from the table in a streaming manner: "booking_events.version"
  """
  booking_events_version_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [booking_events_version_stream_cursor_input]!

    """filter the rows returned"""
    where: booking_events_version_bool_exp
  ): [booking_events_version!]!

  """
  fetch data from the table: "booking_history_entry"
  """
  booking_history_entry(
    """distinct select on columns"""
    distinct_on: [booking_history_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_history_entry_order_by!]

    """filter the rows returned"""
    where: booking_history_entry_bool_exp
  ): [booking_history_entry!]!

  """
  fetch aggregated fields from the table: "booking_history_entry"
  """
  booking_history_entry_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_history_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_history_entry_order_by!]

    """filter the rows returned"""
    where: booking_history_entry_bool_exp
  ): booking_history_entry_aggregate!

  """
  fetch data from the table: "booking_history_entry" using primary key columns
  """
  booking_history_entry_by_pk(id: uuid!): booking_history_entry

  """
  fetch data from the table in a streaming manner: "booking_history_entry"
  """
  booking_history_entry_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [booking_history_entry_stream_cursor_input]!

    """filter the rows returned"""
    where: booking_history_entry_bool_exp
  ): [booking_history_entry!]!

  """
  fetch data from the table: "booking_product"
  """
  booking_product(
    """distinct select on columns"""
    distinct_on: [booking_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_product_order_by!]

    """filter the rows returned"""
    where: booking_product_bool_exp
  ): [booking_product!]!

  """
  fetch aggregated fields from the table: "booking_product"
  """
  booking_product_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_product_order_by!]

    """filter the rows returned"""
    where: booking_product_bool_exp
  ): booking_product_aggregate!

  """fetch data from the table: "booking_product" using primary key columns"""
  booking_product_by_pk(id: uuid!): booking_product

  """
  fetch data from the table in a streaming manner: "booking_product"
  """
  booking_product_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [booking_product_stream_cursor_input]!

    """filter the rows returned"""
    where: booking_product_bool_exp
  ): [booking_product!]!

  """
  fetch data from the table: "booking_question_scope"
  """
  booking_question_scope(
    """distinct select on columns"""
    distinct_on: [booking_question_scope_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_question_scope_order_by!]

    """filter the rows returned"""
    where: booking_question_scope_bool_exp
  ): [booking_question_scope!]!

  """
  fetch aggregated fields from the table: "booking_question_scope"
  """
  booking_question_scope_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_question_scope_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_question_scope_order_by!]

    """filter the rows returned"""
    where: booking_question_scope_bool_exp
  ): booking_question_scope_aggregate!

  """
  fetch data from the table: "booking_question_scope" using primary key columns
  """
  booking_question_scope_by_pk(id: String!): booking_question_scope

  """
  fetch data from the table in a streaming manner: "booking_question_scope"
  """
  booking_question_scope_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [booking_question_scope_stream_cursor_input]!

    """filter the rows returned"""
    where: booking_question_scope_bool_exp
  ): [booking_question_scope!]!

  """
  fetch data from the table: "booking_question_type"
  """
  booking_question_type(
    """distinct select on columns"""
    distinct_on: [booking_question_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_question_type_order_by!]

    """filter the rows returned"""
    where: booking_question_type_bool_exp
  ): [booking_question_type!]!

  """
  fetch aggregated fields from the table: "booking_question_type"
  """
  booking_question_type_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_question_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_question_type_order_by!]

    """filter the rows returned"""
    where: booking_question_type_bool_exp
  ): booking_question_type_aggregate!

  """
  fetch data from the table: "booking_question_type" using primary key columns
  """
  booking_question_type_by_pk(id: String!): booking_question_type

  """
  fetch data from the table in a streaming manner: "booking_question_type"
  """
  booking_question_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [booking_question_type_stream_cursor_input]!

    """filter the rows returned"""
    where: booking_question_type_bool_exp
  ): [booking_question_type!]!

  """
  fetch data from the table: "booking_state"
  """
  booking_state(
    """distinct select on columns"""
    distinct_on: [booking_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_state_order_by!]

    """filter the rows returned"""
    where: booking_state_bool_exp
  ): [booking_state!]!

  """
  fetch aggregated fields from the table: "booking_state"
  """
  booking_state_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_state_order_by!]

    """filter the rows returned"""
    where: booking_state_bool_exp
  ): booking_state_aggregate!

  """fetch data from the table: "booking_state" using primary key columns"""
  booking_state_by_pk(id: String!): booking_state

  """
  fetch data from the table in a streaming manner: "booking_state"
  """
  booking_state_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [booking_state_stream_cursor_input]!

    """filter the rows returned"""
    where: booking_state_bool_exp
  ): [booking_state!]!

  """
  fetch data from the table in a streaming manner: "booking"
  """
  booking_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [booking_stream_cursor_input]!

    """filter the rows returned"""
    where: booking_bool_exp
  ): [booking!]!

  """fetch data from the table: "storage.buckets" using primary key columns"""
  bucket(id: String!): buckets

  """
  fetch data from the table: "storage.buckets"
  """
  buckets(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  fetch aggregated fields from the table: "storage.buckets"
  """
  bucketsAggregate(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): buckets_aggregate!

  """
  fetch data from the table in a streaming manner: "storage.buckets"
  """
  buckets_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [buckets_stream_cursor_input]!

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): [category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  category_aggregate(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): category_aggregate!

  """fetch data from the table: "category" using primary key columns"""
  category_by_pk(id: String!): category

  """
  fetch data from the table in a streaming manner: "category"
  """
  category_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [category_stream_cursor_input]!

    """filter the rows returned"""
    where: category_bool_exp
  ): [category!]!

  """
  fetch data from the table: "contact"
  """
  contact(
    """distinct select on columns"""
    distinct_on: [contact_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contact_order_by!]

    """filter the rows returned"""
    where: contact_bool_exp
  ): [contact!]!

  """
  fetch aggregated fields from the table: "contact"
  """
  contact_aggregate(
    """distinct select on columns"""
    distinct_on: [contact_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contact_order_by!]

    """filter the rows returned"""
    where: contact_bool_exp
  ): contact_aggregate!

  """fetch data from the table: "contact" using primary key columns"""
  contact_by_pk(id: uuid!): contact

  """
  fetch data from the table in a streaming manner: "contact"
  """
  contact_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [contact_stream_cursor_input]!

    """filter the rows returned"""
    where: contact_bool_exp
  ): [contact!]!

  """
  fetch data from the table: "feature"
  """
  feature(
    """distinct select on columns"""
    distinct_on: [feature_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_order_by!]

    """filter the rows returned"""
    where: feature_bool_exp
  ): [feature!]!

  """
  fetch aggregated fields from the table: "feature"
  """
  feature_aggregate(
    """distinct select on columns"""
    distinct_on: [feature_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_order_by!]

    """filter the rows returned"""
    where: feature_bool_exp
  ): feature_aggregate!

  """fetch data from the table: "feature" using primary key columns"""
  feature_by_pk(id: uuid!): feature

  """
  fetch data from the table: "feature_category"
  """
  feature_category(
    """distinct select on columns"""
    distinct_on: [feature_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_category_order_by!]

    """filter the rows returned"""
    where: feature_category_bool_exp
  ): [feature_category!]!

  """
  fetch aggregated fields from the table: "feature_category"
  """
  feature_category_aggregate(
    """distinct select on columns"""
    distinct_on: [feature_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_category_order_by!]

    """filter the rows returned"""
    where: feature_category_bool_exp
  ): feature_category_aggregate!

  """
  fetch data from the table: "feature_category" using primary key columns
  """
  feature_category_by_pk(category_id: String!, feature_id: uuid!): feature_category

  """
  fetch data from the table in a streaming manner: "feature_category"
  """
  feature_category_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [feature_category_stream_cursor_input]!

    """filter the rows returned"""
    where: feature_category_bool_exp
  ): [feature_category!]!

  """
  fetch data from the table in a streaming manner: "feature"
  """
  feature_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [feature_stream_cursor_input]!

    """filter the rows returned"""
    where: feature_bool_exp
  ): [feature!]!

  """
  fetch data from the table: "feature_symbol"
  """
  feature_symbol(
    """distinct select on columns"""
    distinct_on: [feature_symbol_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_symbol_order_by!]

    """filter the rows returned"""
    where: feature_symbol_bool_exp
  ): [feature_symbol!]!

  """
  fetch aggregated fields from the table: "feature_symbol"
  """
  feature_symbol_aggregate(
    """distinct select on columns"""
    distinct_on: [feature_symbol_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_symbol_order_by!]

    """filter the rows returned"""
    where: feature_symbol_bool_exp
  ): feature_symbol_aggregate!

  """fetch data from the table: "feature_symbol" using primary key columns"""
  feature_symbol_by_pk(id: String!): feature_symbol

  """
  fetch data from the table in a streaming manner: "feature_symbol"
  """
  feature_symbol_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [feature_symbol_stream_cursor_input]!

    """filter the rows returned"""
    where: feature_symbol_bool_exp
  ): [feature_symbol!]!

  """
  fetch data from the table: "feature_type"
  """
  feature_type(
    """distinct select on columns"""
    distinct_on: [feature_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_type_order_by!]

    """filter the rows returned"""
    where: feature_type_bool_exp
  ): [feature_type!]!

  """
  fetch aggregated fields from the table: "feature_type"
  """
  feature_type_aggregate(
    """distinct select on columns"""
    distinct_on: [feature_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_type_order_by!]

    """filter the rows returned"""
    where: feature_type_bool_exp
  ): feature_type_aggregate!

  """fetch data from the table: "feature_type" using primary key columns"""
  feature_type_by_pk(id: String!): feature_type

  """
  fetch data from the table in a streaming manner: "feature_type"
  """
  feature_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [feature_type_stream_cursor_input]!

    """filter the rows returned"""
    where: feature_type_bool_exp
  ): [feature_type!]!

  """fetch data from the table: "storage.files" using primary key columns"""
  file(id: uuid!): files

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "storage.files"
  """
  filesAggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """
  fetch data from the table in a streaming manner: "storage.files"
  """
  files_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [files_stream_cursor_input]!

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch data from the table: "media_gallery"
  """
  media_gallery(
    """distinct select on columns"""
    distinct_on: [media_gallery_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_gallery_order_by!]

    """filter the rows returned"""
    where: media_gallery_bool_exp
  ): [media_gallery!]!

  """
  fetch aggregated fields from the table: "media_gallery"
  """
  media_gallery_aggregate(
    """distinct select on columns"""
    distinct_on: [media_gallery_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_gallery_order_by!]

    """filter the rows returned"""
    where: media_gallery_bool_exp
  ): media_gallery_aggregate!

  """fetch data from the table: "media_gallery" using primary key columns"""
  media_gallery_by_pk(id: uuid!): media_gallery

  """
  fetch data from the table: "media_gallery_item"
  """
  media_gallery_item(
    """distinct select on columns"""
    distinct_on: [media_gallery_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_gallery_item_order_by!]

    """filter the rows returned"""
    where: media_gallery_item_bool_exp
  ): [media_gallery_item!]!

  """
  fetch aggregated fields from the table: "media_gallery_item"
  """
  media_gallery_item_aggregate(
    """distinct select on columns"""
    distinct_on: [media_gallery_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_gallery_item_order_by!]

    """filter the rows returned"""
    where: media_gallery_item_bool_exp
  ): media_gallery_item_aggregate!

  """
  fetch data from the table: "media_gallery_item" using primary key columns
  """
  media_gallery_item_by_pk(id: uuid!): media_gallery_item

  """
  fetch data from the table in a streaming manner: "media_gallery_item"
  """
  media_gallery_item_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [media_gallery_item_stream_cursor_input]!

    """filter the rows returned"""
    where: media_gallery_item_bool_exp
  ): [media_gallery_item!]!

  """
  fetch data from the table in a streaming manner: "media_gallery"
  """
  media_gallery_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [media_gallery_stream_cursor_input]!

    """filter the rows returned"""
    where: media_gallery_bool_exp
  ): [media_gallery!]!

  """
  fetch data from the table: "my_web_section"
  """
  my_web_section(
    """distinct select on columns"""
    distinct_on: [my_web_section_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [my_web_section_order_by!]

    """filter the rows returned"""
    where: my_web_section_bool_exp
  ): [my_web_section!]!

  """
  fetch aggregated fields from the table: "my_web_section"
  """
  my_web_section_aggregate(
    """distinct select on columns"""
    distinct_on: [my_web_section_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [my_web_section_order_by!]

    """filter the rows returned"""
    where: my_web_section_bool_exp
  ): my_web_section_aggregate!

  """fetch data from the table: "my_web_section" using primary key columns"""
  my_web_section_by_pk(organization_id: uuid!, section_id: String!): my_web_section

  """
  fetch data from the table in a streaming manner: "my_web_section"
  """
  my_web_section_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [my_web_section_stream_cursor_input]!

    """filter the rows returned"""
    where: my_web_section_bool_exp
  ): [my_web_section!]!

  """
  fetch data from the table: "organization"
  """
  organization(
    """distinct select on columns"""
    distinct_on: [organization_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_order_by!]

    """filter the rows returned"""
    where: organization_bool_exp
  ): [organization!]!

  """
  fetch aggregated fields from the table: "organization"
  """
  organization_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_order_by!]

    """filter the rows returned"""
    where: organization_bool_exp
  ): organization_aggregate!

  """
  fetch data from the table: "organization_booking_question"
  """
  organization_booking_question(
    """distinct select on columns"""
    distinct_on: [organization_booking_question_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_booking_question_order_by!]

    """filter the rows returned"""
    where: organization_booking_question_bool_exp
  ): [organization_booking_question!]!

  """
  fetch aggregated fields from the table: "organization_booking_question"
  """
  organization_booking_question_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_booking_question_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_booking_question_order_by!]

    """filter the rows returned"""
    where: organization_booking_question_bool_exp
  ): organization_booking_question_aggregate!

  """
  fetch data from the table: "organization_booking_question" using primary key columns
  """
  organization_booking_question_by_pk(id: uuid!): organization_booking_question

  """
  fetch data from the table in a streaming manner: "organization_booking_question"
  """
  organization_booking_question_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [organization_booking_question_stream_cursor_input]!

    """filter the rows returned"""
    where: organization_booking_question_bool_exp
  ): [organization_booking_question!]!

  """
  fetch data from the table: "organization_branding"
  """
  organization_branding(
    """distinct select on columns"""
    distinct_on: [organization_branding_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_branding_order_by!]

    """filter the rows returned"""
    where: organization_branding_bool_exp
  ): [organization_branding!]!

  """
  fetch aggregated fields from the table: "organization_branding"
  """
  organization_branding_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_branding_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_branding_order_by!]

    """filter the rows returned"""
    where: organization_branding_bool_exp
  ): organization_branding_aggregate!

  """
  fetch data from the table: "organization_branding" using primary key columns
  """
  organization_branding_by_pk(id: uuid!): organization_branding

  """
  fetch data from the table: "organization_branding_meta_description"
  """
  organization_branding_meta_description(
    """distinct select on columns"""
    distinct_on: [organization_branding_meta_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_branding_meta_description_order_by!]

    """filter the rows returned"""
    where: organization_branding_meta_description_bool_exp
  ): [organization_branding_meta_description!]!

  """
  fetch aggregated fields from the table: "organization_branding_meta_description"
  """
  organization_branding_meta_description_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_branding_meta_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_branding_meta_description_order_by!]

    """filter the rows returned"""
    where: organization_branding_meta_description_bool_exp
  ): organization_branding_meta_description_aggregate!

  """
  fetch data from the table: "organization_branding_meta_description" using primary key columns
  """
  organization_branding_meta_description_by_pk(id: uuid!): organization_branding_meta_description

  """
  fetch data from the table in a streaming manner: "organization_branding_meta_description"
  """
  organization_branding_meta_description_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [organization_branding_meta_description_stream_cursor_input]!

    """filter the rows returned"""
    where: organization_branding_meta_description_bool_exp
  ): [organization_branding_meta_description!]!

  """
  fetch data from the table: "organization_branding_meta_title"
  """
  organization_branding_meta_title(
    """distinct select on columns"""
    distinct_on: [organization_branding_meta_title_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_branding_meta_title_order_by!]

    """filter the rows returned"""
    where: organization_branding_meta_title_bool_exp
  ): [organization_branding_meta_title!]!

  """
  fetch aggregated fields from the table: "organization_branding_meta_title"
  """
  organization_branding_meta_title_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_branding_meta_title_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_branding_meta_title_order_by!]

    """filter the rows returned"""
    where: organization_branding_meta_title_bool_exp
  ): organization_branding_meta_title_aggregate!

  """
  fetch data from the table: "organization_branding_meta_title" using primary key columns
  """
  organization_branding_meta_title_by_pk(id: uuid!): organization_branding_meta_title

  """
  fetch data from the table in a streaming manner: "organization_branding_meta_title"
  """
  organization_branding_meta_title_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [organization_branding_meta_title_stream_cursor_input]!

    """filter the rows returned"""
    where: organization_branding_meta_title_bool_exp
  ): [organization_branding_meta_title!]!

  """
  fetch data from the table in a streaming manner: "organization_branding"
  """
  organization_branding_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [organization_branding_stream_cursor_input]!

    """filter the rows returned"""
    where: organization_branding_bool_exp
  ): [organization_branding!]!

  """
  fetch data from the table: "organization_business_model"
  """
  organization_business_model(
    """distinct select on columns"""
    distinct_on: [organization_business_model_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_business_model_order_by!]

    """filter the rows returned"""
    where: organization_business_model_bool_exp
  ): [organization_business_model!]!

  """
  fetch aggregated fields from the table: "organization_business_model"
  """
  organization_business_model_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_business_model_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_business_model_order_by!]

    """filter the rows returned"""
    where: organization_business_model_bool_exp
  ): organization_business_model_aggregate!

  """
  fetch data from the table: "organization_business_model" using primary key columns
  """
  organization_business_model_by_pk(id: uuid!): organization_business_model

  """
  fetch data from the table in a streaming manner: "organization_business_model"
  """
  organization_business_model_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [organization_business_model_stream_cursor_input]!

    """filter the rows returned"""
    where: organization_business_model_bool_exp
  ): [organization_business_model!]!

  """fetch data from the table: "organization" using primary key columns"""
  organization_by_pk(id: uuid!): organization

  """
  fetch data from the table: "organization_headline"
  """
  organization_headline(
    """distinct select on columns"""
    distinct_on: [organization_headline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_headline_order_by!]

    """filter the rows returned"""
    where: organization_headline_bool_exp
  ): [organization_headline!]!

  """
  fetch aggregated fields from the table: "organization_headline"
  """
  organization_headline_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_headline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_headline_order_by!]

    """filter the rows returned"""
    where: organization_headline_bool_exp
  ): organization_headline_aggregate!

  """
  fetch data from the table: "organization_headline" using primary key columns
  """
  organization_headline_by_pk(id: uuid!): organization_headline

  """
  fetch data from the table in a streaming manner: "organization_headline"
  """
  organization_headline_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [organization_headline_stream_cursor_input]!

    """filter the rows returned"""
    where: organization_headline_bool_exp
  ): [organization_headline!]!

  """
  fetch data from the table: "organization_member"
  """
  organization_member(
    """distinct select on columns"""
    distinct_on: [organization_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_member_order_by!]

    """filter the rows returned"""
    where: organization_member_bool_exp
  ): [organization_member!]!

  """
  fetch aggregated fields from the table: "organization_member"
  """
  organization_member_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_member_order_by!]

    """filter the rows returned"""
    where: organization_member_bool_exp
  ): organization_member_aggregate!

  """
  fetch data from the table: "organization_member" using primary key columns
  """
  organization_member_by_pk(organization_id: uuid!, user_id: uuid!): organization_member

  """
  fetch data from the table in a streaming manner: "organization_member"
  """
  organization_member_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [organization_member_stream_cursor_input]!

    """filter the rows returned"""
    where: organization_member_bool_exp
  ): [organization_member!]!

  """
  fetch data from the table: "organization_socials"
  """
  organization_socials(
    """distinct select on columns"""
    distinct_on: [organization_socials_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_socials_order_by!]

    """filter the rows returned"""
    where: organization_socials_bool_exp
  ): [organization_socials!]!

  """
  fetch aggregated fields from the table: "organization_socials"
  """
  organization_socials_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_socials_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_socials_order_by!]

    """filter the rows returned"""
    where: organization_socials_bool_exp
  ): organization_socials_aggregate!

  """
  fetch data from the table: "organization_socials" using primary key columns
  """
  organization_socials_by_pk(id: uuid!): organization_socials

  """
  fetch data from the table in a streaming manner: "organization_socials"
  """
  organization_socials_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [organization_socials_stream_cursor_input]!

    """filter the rows returned"""
    where: organization_socials_bool_exp
  ): [organization_socials!]!

  """
  fetch data from the table in a streaming manner: "organization"
  """
  organization_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [organization_stream_cursor_input]!

    """filter the rows returned"""
    where: organization_bool_exp
  ): [organization!]!

  """
  fetch data from the table: "place"
  """
  place(
    """distinct select on columns"""
    distinct_on: [place_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [place_order_by!]

    """filter the rows returned"""
    where: place_bool_exp
  ): [place!]!

  """
  fetch aggregated fields from the table: "place"
  """
  place_aggregate(
    """distinct select on columns"""
    distinct_on: [place_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [place_order_by!]

    """filter the rows returned"""
    where: place_bool_exp
  ): place_aggregate!

  """fetch data from the table: "place" using primary key columns"""
  place_by_pk(id: uuid!): place

  """
  fetch data from the table in a streaming manner: "place"
  """
  place_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [place_stream_cursor_input]!

    """filter the rows returned"""
    where: place_bool_exp
  ): [place!]!

  """
  fetch data from the table: "product"
  """
  product(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """
  fetch aggregated fields from the table: "product"
  """
  product_aggregate(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!

  """
  fetch data from the table: "product_allotment_range"
  """
  product_allotment_range(
    """distinct select on columns"""
    distinct_on: [product_allotment_range_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_allotment_range_order_by!]

    """filter the rows returned"""
    where: product_allotment_range_bool_exp
  ): [product_allotment_range!]!

  """
  fetch aggregated fields from the table: "product_allotment_range"
  """
  product_allotment_range_aggregate(
    """distinct select on columns"""
    distinct_on: [product_allotment_range_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_allotment_range_order_by!]

    """filter the rows returned"""
    where: product_allotment_range_bool_exp
  ): product_allotment_range_aggregate!

  """
  fetch data from the table: "product_allotment_range" using primary key columns
  """
  product_allotment_range_by_pk(id: uuid!): product_allotment_range

  """
  fetch data from the table in a streaming manner: "product_allotment_range"
  """
  product_allotment_range_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_allotment_range_stream_cursor_input]!

    """filter the rows returned"""
    where: product_allotment_range_bool_exp
  ): [product_allotment_range!]!

  """
  fetch data from the table: "product_business_model"
  """
  product_business_model(
    """distinct select on columns"""
    distinct_on: [product_business_model_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_business_model_order_by!]

    """filter the rows returned"""
    where: product_business_model_bool_exp
  ): [product_business_model!]!

  """
  fetch aggregated fields from the table: "product_business_model"
  """
  product_business_model_aggregate(
    """distinct select on columns"""
    distinct_on: [product_business_model_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_business_model_order_by!]

    """filter the rows returned"""
    where: product_business_model_bool_exp
  ): product_business_model_aggregate!

  """
  fetch data from the table: "product_business_model" using primary key columns
  """
  product_business_model_by_pk(id: uuid!): product_business_model

  """
  fetch data from the table in a streaming manner: "product_business_model"
  """
  product_business_model_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_business_model_stream_cursor_input]!

    """filter the rows returned"""
    where: product_business_model_bool_exp
  ): [product_business_model!]!

  """fetch data from the table: "product" using primary key columns"""
  product_by_pk(id: uuid!): product

  """
  fetch data from the table: "product_description"
  """
  product_description(
    """distinct select on columns"""
    distinct_on: [product_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_description_order_by!]

    """filter the rows returned"""
    where: product_description_bool_exp
  ): [product_description!]!

  """
  fetch aggregated fields from the table: "product_description"
  """
  product_description_aggregate(
    """distinct select on columns"""
    distinct_on: [product_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_description_order_by!]

    """filter the rows returned"""
    where: product_description_bool_exp
  ): product_description_aggregate!

  """
  fetch data from the table: "product_description" using primary key columns
  """
  product_description_by_pk(id: uuid!): product_description

  """
  fetch data from the table in a streaming manner: "product_description"
  """
  product_description_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_description_stream_cursor_input]!

    """filter the rows returned"""
    where: product_description_bool_exp
  ): [product_description!]!

  """
  fetch data from the table: "product_feature"
  """
  product_feature(
    """distinct select on columns"""
    distinct_on: [product_feature_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_feature_order_by!]

    """filter the rows returned"""
    where: product_feature_bool_exp
  ): [product_feature!]!

  """
  fetch aggregated fields from the table: "product_feature"
  """
  product_feature_aggregate(
    """distinct select on columns"""
    distinct_on: [product_feature_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_feature_order_by!]

    """filter the rows returned"""
    where: product_feature_bool_exp
  ): product_feature_aggregate!

  """fetch data from the table: "product_feature" using primary key columns"""
  product_feature_by_pk(feature_id: uuid!, product_id: uuid!): product_feature

  """
  fetch data from the table in a streaming manner: "product_feature"
  """
  product_feature_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_feature_stream_cursor_input]!

    """filter the rows returned"""
    where: product_feature_bool_exp
  ): [product_feature!]!

  """
  fetch data from the table: "product_group"
  """
  product_group(
    """distinct select on columns"""
    distinct_on: [product_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_group_order_by!]

    """filter the rows returned"""
    where: product_group_bool_exp
  ): [product_group!]!

  """
  fetch aggregated fields from the table: "product_group"
  """
  product_group_aggregate(
    """distinct select on columns"""
    distinct_on: [product_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_group_order_by!]

    """filter the rows returned"""
    where: product_group_bool_exp
  ): product_group_aggregate!

  """fetch data from the table: "product_group" using primary key columns"""
  product_group_by_pk(id: uuid!): product_group

  """
  fetch data from the table: "product_group_product"
  """
  product_group_product(
    """distinct select on columns"""
    distinct_on: [product_group_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_group_product_order_by!]

    """filter the rows returned"""
    where: product_group_product_bool_exp
  ): [product_group_product!]!

  """
  fetch aggregated fields from the table: "product_group_product"
  """
  product_group_product_aggregate(
    """distinct select on columns"""
    distinct_on: [product_group_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_group_product_order_by!]

    """filter the rows returned"""
    where: product_group_product_bool_exp
  ): product_group_product_aggregate!

  """
  fetch data from the table: "product_group_product" using primary key columns
  """
  product_group_product_by_pk(group_id: uuid!, product_id: uuid!): product_group_product

  """
  fetch data from the table in a streaming manner: "product_group_product"
  """
  product_group_product_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_group_product_stream_cursor_input]!

    """filter the rows returned"""
    where: product_group_product_bool_exp
  ): [product_group_product!]!

  """
  fetch data from the table in a streaming manner: "product_group"
  """
  product_group_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_group_stream_cursor_input]!

    """filter the rows returned"""
    where: product_group_bool_exp
  ): [product_group!]!

  """
  fetch data from the table: "product_headline"
  """
  product_headline(
    """distinct select on columns"""
    distinct_on: [product_headline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_headline_order_by!]

    """filter the rows returned"""
    where: product_headline_bool_exp
  ): [product_headline!]!

  """
  fetch aggregated fields from the table: "product_headline"
  """
  product_headline_aggregate(
    """distinct select on columns"""
    distinct_on: [product_headline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_headline_order_by!]

    """filter the rows returned"""
    where: product_headline_bool_exp
  ): product_headline_aggregate!

  """
  fetch data from the table: "product_headline" using primary key columns
  """
  product_headline_by_pk(id: uuid!): product_headline

  """
  fetch data from the table in a streaming manner: "product_headline"
  """
  product_headline_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_headline_stream_cursor_input]!

    """filter the rows returned"""
    where: product_headline_bool_exp
  ): [product_headline!]!

  """
  fetch data from the table: "product_name"
  """
  product_name(
    """distinct select on columns"""
    distinct_on: [product_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_name_order_by!]

    """filter the rows returned"""
    where: product_name_bool_exp
  ): [product_name!]!

  """
  fetch aggregated fields from the table: "product_name"
  """
  product_name_aggregate(
    """distinct select on columns"""
    distinct_on: [product_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_name_order_by!]

    """filter the rows returned"""
    where: product_name_bool_exp
  ): product_name_aggregate!

  """fetch data from the table: "product_name" using primary key columns"""
  product_name_by_pk(id: uuid!): product_name

  """
  fetch data from the table in a streaming manner: "product_name"
  """
  product_name_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_name_stream_cursor_input]!

    """filter the rows returned"""
    where: product_name_bool_exp
  ): [product_name!]!

  """
  fetch data from the table in a streaming manner: "product"
  """
  product_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_stream_cursor_input]!

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """
  fetch data from the table: "product_supplement"
  """
  product_supplement(
    """distinct select on columns"""
    distinct_on: [product_supplement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_supplement_order_by!]

    """filter the rows returned"""
    where: product_supplement_bool_exp
  ): [product_supplement!]!

  """
  fetch aggregated fields from the table: "product_supplement"
  """
  product_supplement_aggregate(
    """distinct select on columns"""
    distinct_on: [product_supplement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_supplement_order_by!]

    """filter the rows returned"""
    where: product_supplement_bool_exp
  ): product_supplement_aggregate!

  """
  fetch data from the table: "product_supplement" using primary key columns
  """
  product_supplement_by_pk(product_id: uuid!, supplement_id: uuid!): product_supplement

  """
  fetch data from the table in a streaming manner: "product_supplement"
  """
  product_supplement_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_supplement_stream_cursor_input]!

    """filter the rows returned"""
    where: product_supplement_bool_exp
  ): [product_supplement!]!

  """
  fetch data from the table: "rate"
  """
  rate(
    """distinct select on columns"""
    distinct_on: [rate_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_order_by!]

    """filter the rows returned"""
    where: rate_bool_exp
  ): [rate!]!

  """
  fetch aggregated fields from the table: "rate"
  """
  rate_aggregate(
    """distinct select on columns"""
    distinct_on: [rate_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_order_by!]

    """filter the rows returned"""
    where: rate_bool_exp
  ): rate_aggregate!

  """fetch data from the table: "rate" using primary key columns"""
  rate_by_pk(id: uuid!): rate

  """
  fetch data from the table: "rate_headline"
  """
  rate_headline(
    """distinct select on columns"""
    distinct_on: [rate_headline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_headline_order_by!]

    """filter the rows returned"""
    where: rate_headline_bool_exp
  ): [rate_headline!]!

  """
  fetch aggregated fields from the table: "rate_headline"
  """
  rate_headline_aggregate(
    """distinct select on columns"""
    distinct_on: [rate_headline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_headline_order_by!]

    """filter the rows returned"""
    where: rate_headline_bool_exp
  ): rate_headline_aggregate!

  """fetch data from the table: "rate_headline" using primary key columns"""
  rate_headline_by_pk(id: uuid!): rate_headline

  """
  fetch data from the table in a streaming manner: "rate_headline"
  """
  rate_headline_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rate_headline_stream_cursor_input]!

    """filter the rows returned"""
    where: rate_headline_bool_exp
  ): [rate_headline!]!

  """
  fetch data from the table: "rate_name"
  """
  rate_name(
    """distinct select on columns"""
    distinct_on: [rate_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_name_order_by!]

    """filter the rows returned"""
    where: rate_name_bool_exp
  ): [rate_name!]!

  """
  fetch aggregated fields from the table: "rate_name"
  """
  rate_name_aggregate(
    """distinct select on columns"""
    distinct_on: [rate_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_name_order_by!]

    """filter the rows returned"""
    where: rate_name_bool_exp
  ): rate_name_aggregate!

  """fetch data from the table: "rate_name" using primary key columns"""
  rate_name_by_pk(id: uuid!): rate_name

  """
  fetch data from the table in a streaming manner: "rate_name"
  """
  rate_name_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rate_name_stream_cursor_input]!

    """filter the rows returned"""
    where: rate_name_bool_exp
  ): [rate_name!]!

  """
  fetch data from the table: "rate_price_range"
  """
  rate_price_range(
    """distinct select on columns"""
    distinct_on: [rate_price_range_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_price_range_order_by!]

    """filter the rows returned"""
    where: rate_price_range_bool_exp
  ): [rate_price_range!]!

  """
  fetch aggregated fields from the table: "rate_price_range"
  """
  rate_price_range_aggregate(
    """distinct select on columns"""
    distinct_on: [rate_price_range_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_price_range_order_by!]

    """filter the rows returned"""
    where: rate_price_range_bool_exp
  ): rate_price_range_aggregate!

  """
  fetch data from the table: "rate_price_range" using primary key columns
  """
  rate_price_range_by_pk(id: uuid!): rate_price_range

  """
  fetch data from the table in a streaming manner: "rate_price_range"
  """
  rate_price_range_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rate_price_range_stream_cursor_input]!

    """filter the rows returned"""
    where: rate_price_range_bool_exp
  ): [rate_price_range!]!

  """
  fetch data from the table in a streaming manner: "rate"
  """
  rate_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rate_stream_cursor_input]!

    """filter the rows returned"""
    where: rate_bool_exp
  ): [rate!]!

  """
  fetch data from the table: "rate_type"
  """
  rate_type(
    """distinct select on columns"""
    distinct_on: [rate_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_type_order_by!]

    """filter the rows returned"""
    where: rate_type_bool_exp
  ): [rate_type!]!

  """
  fetch aggregated fields from the table: "rate_type"
  """
  rate_type_aggregate(
    """distinct select on columns"""
    distinct_on: [rate_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rate_type_order_by!]

    """filter the rows returned"""
    where: rate_type_bool_exp
  ): rate_type_aggregate!

  """fetch data from the table: "rate_type" using primary key columns"""
  rate_type_by_pk(id: String!): rate_type

  """
  fetch data from the table in a streaming manner: "rate_type"
  """
  rate_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rate_type_stream_cursor_input]!

    """filter the rows returned"""
    where: rate_type_bool_exp
  ): [rate_type!]!

  """
  fetch data from the table: "role"
  """
  role(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): [role!]!

  """
  fetch aggregated fields from the table: "role"
  """
  role_aggregate(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): role_aggregate!

  """fetch data from the table: "role" using primary key columns"""
  role_by_pk(id: String!): role

  """
  fetch data from the table in a streaming manner: "role"
  """
  role_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [role_stream_cursor_input]!

    """filter the rows returned"""
    where: role_bool_exp
  ): [role!]!

  """
  fetch data from the table: "site"
  """
  site(
    """distinct select on columns"""
    distinct_on: [site_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [site_order_by!]

    """filter the rows returned"""
    where: site_bool_exp
  ): [site!]!

  """
  fetch aggregated fields from the table: "site"
  """
  site_aggregate(
    """distinct select on columns"""
    distinct_on: [site_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [site_order_by!]

    """filter the rows returned"""
    where: site_bool_exp
  ): site_aggregate!

  """fetch data from the table: "site" using primary key columns"""
  site_by_pk(id: uuid!): site

  """
  fetch data from the table in a streaming manner: "site"
  """
  site_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [site_stream_cursor_input]!

    """filter the rows returned"""
    where: site_bool_exp
  ): [site!]!

  """
  fetch data from the table: "slug"
  """
  slug(
    """distinct select on columns"""
    distinct_on: [slug_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [slug_order_by!]

    """filter the rows returned"""
    where: slug_bool_exp
  ): [slug!]!

  """
  fetch aggregated fields from the table: "slug"
  """
  slug_aggregate(
    """distinct select on columns"""
    distinct_on: [slug_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [slug_order_by!]

    """filter the rows returned"""
    where: slug_bool_exp
  ): slug_aggregate!

  """fetch data from the table: "slug" using primary key columns"""
  slug_by_pk(id: uuid!): slug

  """
  fetch data from the table in a streaming manner: "slug"
  """
  slug_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [slug_stream_cursor_input]!

    """filter the rows returned"""
    where: slug_bool_exp
  ): [slug!]!

  """
  fetch data from the table: "supplement"
  """
  supplement(
    """distinct select on columns"""
    distinct_on: [supplement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supplement_order_by!]

    """filter the rows returned"""
    where: supplement_bool_exp
  ): [supplement!]!

  """
  fetch aggregated fields from the table: "supplement"
  """
  supplement_aggregate(
    """distinct select on columns"""
    distinct_on: [supplement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supplement_order_by!]

    """filter the rows returned"""
    where: supplement_bool_exp
  ): supplement_aggregate!

  """fetch data from the table: "supplement" using primary key columns"""
  supplement_by_pk(id: uuid!): supplement

  """
  fetch data from the table: "supplement_prices"
  """
  supplement_prices(
    """distinct select on columns"""
    distinct_on: [supplement_prices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supplement_prices_order_by!]

    """filter the rows returned"""
    where: supplement_prices_bool_exp
  ): [supplement_prices!]!

  """
  fetch aggregated fields from the table: "supplement_prices"
  """
  supplement_prices_aggregate(
    """distinct select on columns"""
    distinct_on: [supplement_prices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supplement_prices_order_by!]

    """filter the rows returned"""
    where: supplement_prices_bool_exp
  ): supplement_prices_aggregate!

  """
  fetch data from the table in a streaming manner: "supplement_prices"
  """
  supplement_prices_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [supplement_prices_stream_cursor_input]!

    """filter the rows returned"""
    where: supplement_prices_bool_exp
  ): [supplement_prices!]!

  """
  fetch data from the table in a streaming manner: "supplement"
  """
  supplement_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [supplement_stream_cursor_input]!

    """filter the rows returned"""
    where: supplement_bool_exp
  ): [supplement!]!

  """
  fetch data from the table: "supplement_type"
  """
  supplement_type(
    """distinct select on columns"""
    distinct_on: [supplement_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supplement_type_order_by!]

    """filter the rows returned"""
    where: supplement_type_bool_exp
  ): [supplement_type!]!

  """
  fetch aggregated fields from the table: "supplement_type"
  """
  supplement_type_aggregate(
    """distinct select on columns"""
    distinct_on: [supplement_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supplement_type_order_by!]

    """filter the rows returned"""
    where: supplement_type_bool_exp
  ): supplement_type_aggregate!

  """fetch data from the table: "supplement_type" using primary key columns"""
  supplement_type_by_pk(id: String!): supplement_type

  """
  fetch data from the table in a streaming manner: "supplement_type"
  """
  supplement_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [supplement_type_stream_cursor_input]!

    """filter the rows returned"""
    where: supplement_type_bool_exp
  ): [supplement_type!]!

  """
  fetch data from the table: "translated_text"
  """
  translated_text(
    """distinct select on columns"""
    distinct_on: [translated_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translated_text_order_by!]

    """filter the rows returned"""
    where: translated_text_bool_exp
  ): [translated_text!]!

  """
  fetch aggregated fields from the table: "translated_text"
  """
  translated_text_aggregate(
    """distinct select on columns"""
    distinct_on: [translated_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translated_text_order_by!]

    """filter the rows returned"""
    where: translated_text_bool_exp
  ): translated_text_aggregate!

  """fetch data from the table: "translated_text" using primary key columns"""
  translated_text_by_pk(id: uuid!): translated_text

  """
  fetch data from the table in a streaming manner: "translated_text"
  """
  translated_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [translated_text_stream_cursor_input]!

    """filter the rows returned"""
    where: translated_text_bool_exp
  ): [translated_text!]!

  """
  fetch data from the table: "unit_management"
  """
  unit_management(
    """distinct select on columns"""
    distinct_on: [unit_management_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unit_management_order_by!]

    """filter the rows returned"""
    where: unit_management_bool_exp
  ): [unit_management!]!

  """
  fetch aggregated fields from the table: "unit_management"
  """
  unit_management_aggregate(
    """distinct select on columns"""
    distinct_on: [unit_management_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unit_management_order_by!]

    """filter the rows returned"""
    where: unit_management_bool_exp
  ): unit_management_aggregate!

  """fetch data from the table: "unit_management" using primary key columns"""
  unit_management_by_pk(id: String!): unit_management

  """
  fetch data from the table in a streaming manner: "unit_management"
  """
  unit_management_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [unit_management_stream_cursor_input]!

    """filter the rows returned"""
    where: unit_management_bool_exp
  ): [unit_management!]!

  """fetch data from the table: "auth.users" using primary key columns"""
  user(id: uuid!): users

  """
  fetch data from the table: "auth.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "auth.users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.users"
  """
  users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [users_stream_cursor_input]!

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch data from the table: "venue"
  """
  venue(
    """distinct select on columns"""
    distinct_on: [venue_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_order_by!]

    """filter the rows returned"""
    where: venue_bool_exp
  ): [venue!]!

  """
  fetch aggregated fields from the table: "venue"
  """
  venue_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_order_by!]

    """filter the rows returned"""
    where: venue_bool_exp
  ): venue_aggregate!

  """fetch data from the table: "venue" using primary key columns"""
  venue_by_pk(id: uuid!): venue

  """
  fetch data from the table: "venue_description"
  """
  venue_description(
    """distinct select on columns"""
    distinct_on: [venue_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_description_order_by!]

    """filter the rows returned"""
    where: venue_description_bool_exp
  ): [venue_description!]!

  """
  fetch aggregated fields from the table: "venue_description"
  """
  venue_description_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_description_order_by!]

    """filter the rows returned"""
    where: venue_description_bool_exp
  ): venue_description_aggregate!

  """
  fetch data from the table: "venue_description" using primary key columns
  """
  venue_description_by_pk(id: uuid!): venue_description

  """
  fetch data from the table in a streaming manner: "venue_description"
  """
  venue_description_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [venue_description_stream_cursor_input]!

    """filter the rows returned"""
    where: venue_description_bool_exp
  ): [venue_description!]!

  """
  fetch data from the table: "venue_facility"
  """
  venue_facility(
    """distinct select on columns"""
    distinct_on: [venue_facility_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_facility_order_by!]

    """filter the rows returned"""
    where: venue_facility_bool_exp
  ): [venue_facility!]!

  """
  fetch aggregated fields from the table: "venue_facility"
  """
  venue_facility_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_facility_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_facility_order_by!]

    """filter the rows returned"""
    where: venue_facility_bool_exp
  ): venue_facility_aggregate!

  """fetch data from the table: "venue_facility" using primary key columns"""
  venue_facility_by_pk(id: uuid!): venue_facility

  """
  fetch data from the table: "venue_facility_headline"
  """
  venue_facility_headline(
    """distinct select on columns"""
    distinct_on: [venue_facility_headline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_facility_headline_order_by!]

    """filter the rows returned"""
    where: venue_facility_headline_bool_exp
  ): [venue_facility_headline!]!

  """
  fetch aggregated fields from the table: "venue_facility_headline"
  """
  venue_facility_headline_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_facility_headline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_facility_headline_order_by!]

    """filter the rows returned"""
    where: venue_facility_headline_bool_exp
  ): venue_facility_headline_aggregate!

  """
  fetch data from the table: "venue_facility_headline" using primary key columns
  """
  venue_facility_headline_by_pk(id: uuid!): venue_facility_headline

  """
  fetch data from the table in a streaming manner: "venue_facility_headline"
  """
  venue_facility_headline_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [venue_facility_headline_stream_cursor_input]!

    """filter the rows returned"""
    where: venue_facility_headline_bool_exp
  ): [venue_facility_headline!]!

  """
  fetch data from the table: "venue_facility_name"
  """
  venue_facility_name(
    """distinct select on columns"""
    distinct_on: [venue_facility_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_facility_name_order_by!]

    """filter the rows returned"""
    where: venue_facility_name_bool_exp
  ): [venue_facility_name!]!

  """
  fetch aggregated fields from the table: "venue_facility_name"
  """
  venue_facility_name_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_facility_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_facility_name_order_by!]

    """filter the rows returned"""
    where: venue_facility_name_bool_exp
  ): venue_facility_name_aggregate!

  """
  fetch data from the table: "venue_facility_name" using primary key columns
  """
  venue_facility_name_by_pk(id: uuid!): venue_facility_name

  """
  fetch data from the table in a streaming manner: "venue_facility_name"
  """
  venue_facility_name_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [venue_facility_name_stream_cursor_input]!

    """filter the rows returned"""
    where: venue_facility_name_bool_exp
  ): [venue_facility_name!]!

  """
  fetch data from the table in a streaming manner: "venue_facility"
  """
  venue_facility_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [venue_facility_stream_cursor_input]!

    """filter the rows returned"""
    where: venue_facility_bool_exp
  ): [venue_facility!]!

  """
  fetch data from the table: "venue_good_to_know"
  """
  venue_good_to_know(
    """distinct select on columns"""
    distinct_on: [venue_good_to_know_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_good_to_know_order_by!]

    """filter the rows returned"""
    where: venue_good_to_know_bool_exp
  ): [venue_good_to_know!]!

  """
  fetch aggregated fields from the table: "venue_good_to_know"
  """
  venue_good_to_know_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_good_to_know_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_good_to_know_order_by!]

    """filter the rows returned"""
    where: venue_good_to_know_bool_exp
  ): venue_good_to_know_aggregate!

  """
  fetch data from the table: "venue_good_to_know" using primary key columns
  """
  venue_good_to_know_by_pk(id: uuid!): venue_good_to_know

  """
  fetch data from the table in a streaming manner: "venue_good_to_know"
  """
  venue_good_to_know_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [venue_good_to_know_stream_cursor_input]!

    """filter the rows returned"""
    where: venue_good_to_know_bool_exp
  ): [venue_good_to_know!]!

  """
  fetch data from the table in a streaming manner: "venue"
  """
  venue_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [venue_stream_cursor_input]!

    """filter the rows returned"""
    where: venue_bool_exp
  ): [venue!]!

  """
  fetch data from the table: "venue_usps"
  """
  venue_usps(
    """distinct select on columns"""
    distinct_on: [venue_usps_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_usps_order_by!]

    """filter the rows returned"""
    where: venue_usps_bool_exp
  ): [venue_usps!]!

  """
  fetch aggregated fields from the table: "venue_usps"
  """
  venue_usps_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_usps_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_usps_order_by!]

    """filter the rows returned"""
    where: venue_usps_bool_exp
  ): venue_usps_aggregate!

  """fetch data from the table: "venue_usps" using primary key columns"""
  venue_usps_by_pk(id: uuid!): venue_usps

  """
  fetch data from the table: "venue_usps_line"
  """
  venue_usps_line(
    """distinct select on columns"""
    distinct_on: [venue_usps_line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_usps_line_order_by!]

    """filter the rows returned"""
    where: venue_usps_line_bool_exp
  ): [venue_usps_line!]!

  """
  fetch aggregated fields from the table: "venue_usps_line"
  """
  venue_usps_line_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_usps_line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_usps_line_order_by!]

    """filter the rows returned"""
    where: venue_usps_line_bool_exp
  ): venue_usps_line_aggregate!

  """fetch data from the table: "venue_usps_line" using primary key columns"""
  venue_usps_line_by_pk(id: uuid!): venue_usps_line

  """
  fetch data from the table in a streaming manner: "venue_usps_line"
  """
  venue_usps_line_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [venue_usps_line_stream_cursor_input]!

    """filter the rows returned"""
    where: venue_usps_line_bool_exp
  ): [venue_usps_line!]!

  """
  fetch data from the table in a streaming manner: "venue_usps"
  """
  venue_usps_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [venue_usps_stream_cursor_input]!

    """filter the rows returned"""
    where: venue_usps_bool_exp
  ): [venue_usps!]!

  """fetch data from the table: "storage.virus" using primary key columns"""
  virus(id: uuid!): virus

  """
  fetch data from the table in a streaming manner: "storage.virus"
  """
  virus_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [virus_stream_cursor_input]!

    """filter the rows returned"""
    where: virus_bool_exp
  ): [virus!]!

  """
  fetch data from the table: "storage.virus"
  """
  viruses(
    """distinct select on columns"""
    distinct_on: [virus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [virus_order_by!]

    """filter the rows returned"""
    where: virus_bool_exp
  ): [virus!]!

  """
  fetch aggregated fields from the table: "storage.virus"
  """
  virusesAggregate(
    """distinct select on columns"""
    distinct_on: [virus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [virus_order_by!]

    """filter the rows returned"""
    where: virus_bool_exp
  ): virus_aggregate!
}

"""
columns and relationships of "supplement"
"""
type supplement {
  """An object relationship"""
  description: translated_text!
  description_id: uuid!

  """An object relationship"""
  headline: translated_text
  headline_id: uuid!
  id: uuid!

  """An object relationship"""
  image: files
  image_id: uuid
  is_optional: Boolean!

  """An object relationship"""
  name: translated_text
  name_id: uuid!

  """An object relationship"""
  organization: organization!
  organization_id: uuid!
  price: numeric!

  """An array relationship"""
  prices(
    """distinct select on columns"""
    distinct_on: [supplement_prices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supplement_prices_order_by!]

    """filter the rows returned"""
    where: supplement_prices_bool_exp
  ): [supplement_prices!]!

  """An aggregate relationship"""
  prices_aggregate(
    """distinct select on columns"""
    distinct_on: [supplement_prices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supplement_prices_order_by!]

    """filter the rows returned"""
    where: supplement_prices_bool_exp
  ): supplement_prices_aggregate!

  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [product_supplement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_supplement_order_by!]

    """filter the rows returned"""
    where: product_supplement_bool_exp
  ): [product_supplement!]!

  """An aggregate relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [product_supplement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_supplement_order_by!]

    """filter the rows returned"""
    where: product_supplement_bool_exp
  ): product_supplement_aggregate!
  type: supplement_type_enum!
}

"""
aggregated selection of "supplement"
"""
type supplement_aggregate {
  aggregate: supplement_aggregate_fields
  nodes: [supplement!]!
}

input supplement_aggregate_bool_exp {
  bool_and: supplement_aggregate_bool_exp_bool_and
  bool_or: supplement_aggregate_bool_exp_bool_or
  count: supplement_aggregate_bool_exp_count
}

input supplement_aggregate_bool_exp_bool_and {
  arguments: supplement_select_column_supplement_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: supplement_bool_exp
  predicate: Boolean_comparison_exp!
}

input supplement_aggregate_bool_exp_bool_or {
  arguments: supplement_select_column_supplement_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: supplement_bool_exp
  predicate: Boolean_comparison_exp!
}

input supplement_aggregate_bool_exp_count {
  arguments: [supplement_select_column!]
  distinct: Boolean
  filter: supplement_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "supplement"
"""
type supplement_aggregate_fields {
  avg: supplement_avg_fields
  count(columns: [supplement_select_column!], distinct: Boolean): Int!
  max: supplement_max_fields
  min: supplement_min_fields
  stddev: supplement_stddev_fields
  stddev_pop: supplement_stddev_pop_fields
  stddev_samp: supplement_stddev_samp_fields
  sum: supplement_sum_fields
  var_pop: supplement_var_pop_fields
  var_samp: supplement_var_samp_fields
  variance: supplement_variance_fields
}

"""
order by aggregate values of table "supplement"
"""
input supplement_aggregate_order_by {
  avg: supplement_avg_order_by
  count: order_by
  max: supplement_max_order_by
  min: supplement_min_order_by
  stddev: supplement_stddev_order_by
  stddev_pop: supplement_stddev_pop_order_by
  stddev_samp: supplement_stddev_samp_order_by
  sum: supplement_sum_order_by
  var_pop: supplement_var_pop_order_by
  var_samp: supplement_var_samp_order_by
  variance: supplement_variance_order_by
}

"""
input type for inserting array relation for remote table "supplement"
"""
input supplement_arr_rel_insert_input {
  data: [supplement_insert_input!]!

  """upsert condition"""
  on_conflict: supplement_on_conflict
}

"""aggregate avg on columns"""
type supplement_avg_fields {
  price: Float
}

"""
order by avg() on columns of table "supplement"
"""
input supplement_avg_order_by {
  price: order_by
}

"""
Boolean expression to filter rows from the table "supplement". All fields are combined with a logical 'AND'.
"""
input supplement_bool_exp {
  _and: [supplement_bool_exp!]
  _not: supplement_bool_exp
  _or: [supplement_bool_exp!]
  description: translated_text_bool_exp
  description_id: uuid_comparison_exp
  headline: translated_text_bool_exp
  headline_id: uuid_comparison_exp
  id: uuid_comparison_exp
  image: files_bool_exp
  image_id: uuid_comparison_exp
  is_optional: Boolean_comparison_exp
  name: translated_text_bool_exp
  name_id: uuid_comparison_exp
  organization: organization_bool_exp
  organization_id: uuid_comparison_exp
  price: numeric_comparison_exp
  prices: supplement_prices_bool_exp
  prices_aggregate: supplement_prices_aggregate_bool_exp
  products: product_supplement_bool_exp
  products_aggregate: product_supplement_aggregate_bool_exp
  type: supplement_type_enum_comparison_exp
}

"""
unique or primary key constraints on table "supplement"
"""
enum supplement_constraint {
  """
  unique or primary key constraint on columns "image_id"
  """
  supplement_image_id_key

  """
  unique or primary key constraint on columns "id"
  """
  supplement_pkey
}

input supplement_create_input {
  id: uuid!
  organization_id: uuid!
}

"""
input type for incrementing numeric columns in table "supplement"
"""
input supplement_inc_input {
  price: numeric
}

"""
input type for inserting data into table "supplement"
"""
input supplement_insert_input {
  description: translated_text_obj_rel_insert_input
  description_id: uuid
  headline: translated_text_obj_rel_insert_input
  headline_id: uuid
  id: uuid
  image: files_obj_rel_insert_input
  image_id: uuid
  is_optional: Boolean
  name: translated_text_obj_rel_insert_input
  name_id: uuid
  organization: organization_obj_rel_insert_input
  organization_id: uuid
  price: numeric
  prices: supplement_prices_arr_rel_insert_input
  products: product_supplement_arr_rel_insert_input
  type: supplement_type_enum
}

"""aggregate max on columns"""
type supplement_max_fields {
  description_id: uuid
  headline_id: uuid
  id: uuid
  image_id: uuid
  name_id: uuid
  organization_id: uuid
  price: numeric
}

"""
order by max() on columns of table "supplement"
"""
input supplement_max_order_by {
  description_id: order_by
  headline_id: order_by
  id: order_by
  image_id: order_by
  name_id: order_by
  organization_id: order_by
  price: order_by
}

"""aggregate min on columns"""
type supplement_min_fields {
  description_id: uuid
  headline_id: uuid
  id: uuid
  image_id: uuid
  name_id: uuid
  organization_id: uuid
  price: numeric
}

"""
order by min() on columns of table "supplement"
"""
input supplement_min_order_by {
  description_id: order_by
  headline_id: order_by
  id: order_by
  image_id: order_by
  name_id: order_by
  organization_id: order_by
  price: order_by
}

"""
response of any mutation on the table "supplement"
"""
type supplement_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [supplement!]!
}

"""
input type for inserting object relation for remote table "supplement"
"""
input supplement_obj_rel_insert_input {
  data: supplement_insert_input!

  """upsert condition"""
  on_conflict: supplement_on_conflict
}

"""
on_conflict condition type for table "supplement"
"""
input supplement_on_conflict {
  constraint: supplement_constraint!
  update_columns: [supplement_update_column!]! = []
  where: supplement_bool_exp
}

"""Ordering options when selecting data from "supplement"."""
input supplement_order_by {
  description: translated_text_order_by
  description_id: order_by
  headline: translated_text_order_by
  headline_id: order_by
  id: order_by
  image: files_order_by
  image_id: order_by
  is_optional: order_by
  name: translated_text_order_by
  name_id: order_by
  organization: organization_order_by
  organization_id: order_by
  price: order_by
  prices_aggregate: supplement_prices_aggregate_order_by
  products_aggregate: product_supplement_aggregate_order_by
  type: order_by
}

"""primary key columns input for table: supplement"""
input supplement_pk_columns_input {
  id: uuid!
}

"""
columns and relationships of "supplement_prices"
"""
type supplement_prices {
  from: String
  id: uuid
  to: String
  value: numeric
}

"""
aggregated selection of "supplement_prices"
"""
type supplement_prices_aggregate {
  aggregate: supplement_prices_aggregate_fields
  nodes: [supplement_prices!]!
}

input supplement_prices_aggregate_bool_exp {
  count: supplement_prices_aggregate_bool_exp_count
}

input supplement_prices_aggregate_bool_exp_count {
  arguments: [supplement_prices_select_column!]
  distinct: Boolean
  filter: supplement_prices_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "supplement_prices"
"""
type supplement_prices_aggregate_fields {
  avg: supplement_prices_avg_fields
  count(columns: [supplement_prices_select_column!], distinct: Boolean): Int!
  max: supplement_prices_max_fields
  min: supplement_prices_min_fields
  stddev: supplement_prices_stddev_fields
  stddev_pop: supplement_prices_stddev_pop_fields
  stddev_samp: supplement_prices_stddev_samp_fields
  sum: supplement_prices_sum_fields
  var_pop: supplement_prices_var_pop_fields
  var_samp: supplement_prices_var_samp_fields
  variance: supplement_prices_variance_fields
}

"""
order by aggregate values of table "supplement_prices"
"""
input supplement_prices_aggregate_order_by {
  avg: supplement_prices_avg_order_by
  count: order_by
  max: supplement_prices_max_order_by
  min: supplement_prices_min_order_by
  stddev: supplement_prices_stddev_order_by
  stddev_pop: supplement_prices_stddev_pop_order_by
  stddev_samp: supplement_prices_stddev_samp_order_by
  sum: supplement_prices_sum_order_by
  var_pop: supplement_prices_var_pop_order_by
  var_samp: supplement_prices_var_samp_order_by
  variance: supplement_prices_variance_order_by
}

"""
input type for inserting array relation for remote table "supplement_prices"
"""
input supplement_prices_arr_rel_insert_input {
  data: [supplement_prices_insert_input!]!
}

"""aggregate avg on columns"""
type supplement_prices_avg_fields {
  value: Float
}

"""
order by avg() on columns of table "supplement_prices"
"""
input supplement_prices_avg_order_by {
  value: order_by
}

"""
Boolean expression to filter rows from the table "supplement_prices". All fields are combined with a logical 'AND'.
"""
input supplement_prices_bool_exp {
  _and: [supplement_prices_bool_exp!]
  _not: supplement_prices_bool_exp
  _or: [supplement_prices_bool_exp!]
  from: String_comparison_exp
  id: uuid_comparison_exp
  to: String_comparison_exp
  value: numeric_comparison_exp
}

"""
input type for incrementing numeric columns in table "supplement_prices"
"""
input supplement_prices_inc_input {
  value: numeric
}

"""
input type for inserting data into table "supplement_prices"
"""
input supplement_prices_insert_input {
  from: String
  id: uuid
  to: String
  value: numeric
}

"""aggregate max on columns"""
type supplement_prices_max_fields {
  from: String
  id: uuid
  to: String
  value: numeric
}

"""
order by max() on columns of table "supplement_prices"
"""
input supplement_prices_max_order_by {
  from: order_by
  id: order_by
  to: order_by
  value: order_by
}

"""aggregate min on columns"""
type supplement_prices_min_fields {
  from: String
  id: uuid
  to: String
  value: numeric
}

"""
order by min() on columns of table "supplement_prices"
"""
input supplement_prices_min_order_by {
  from: order_by
  id: order_by
  to: order_by
  value: order_by
}

"""
response of any mutation on the table "supplement_prices"
"""
type supplement_prices_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [supplement_prices!]!
}

"""Ordering options when selecting data from "supplement_prices"."""
input supplement_prices_order_by {
  from: order_by
  id: order_by
  to: order_by
  value: order_by
}

"""
select columns of table "supplement_prices"
"""
enum supplement_prices_select_column {
  """column name"""
  from

  """column name"""
  id

  """column name"""
  to

  """column name"""
  value
}

"""
input type for updating data in table "supplement_prices"
"""
input supplement_prices_set_input {
  from: String
  id: uuid
  to: String
  value: numeric
}

"""aggregate stddev on columns"""
type supplement_prices_stddev_fields {
  value: Float
}

"""
order by stddev() on columns of table "supplement_prices"
"""
input supplement_prices_stddev_order_by {
  value: order_by
}

"""aggregate stddev_pop on columns"""
type supplement_prices_stddev_pop_fields {
  value: Float
}

"""
order by stddev_pop() on columns of table "supplement_prices"
"""
input supplement_prices_stddev_pop_order_by {
  value: order_by
}

"""aggregate stddev_samp on columns"""
type supplement_prices_stddev_samp_fields {
  value: Float
}

"""
order by stddev_samp() on columns of table "supplement_prices"
"""
input supplement_prices_stddev_samp_order_by {
  value: order_by
}

"""
Streaming cursor of the table "supplement_prices"
"""
input supplement_prices_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: supplement_prices_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input supplement_prices_stream_cursor_value_input {
  from: String
  id: uuid
  to: String
  value: numeric
}

"""aggregate sum on columns"""
type supplement_prices_sum_fields {
  value: numeric
}

"""
order by sum() on columns of table "supplement_prices"
"""
input supplement_prices_sum_order_by {
  value: order_by
}

input supplement_prices_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: supplement_prices_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: supplement_prices_set_input

  """filter the rows which have to be updated"""
  where: supplement_prices_bool_exp!
}

"""aggregate var_pop on columns"""
type supplement_prices_var_pop_fields {
  value: Float
}

"""
order by var_pop() on columns of table "supplement_prices"
"""
input supplement_prices_var_pop_order_by {
  value: order_by
}

"""aggregate var_samp on columns"""
type supplement_prices_var_samp_fields {
  value: Float
}

"""
order by var_samp() on columns of table "supplement_prices"
"""
input supplement_prices_var_samp_order_by {
  value: order_by
}

"""aggregate variance on columns"""
type supplement_prices_variance_fields {
  value: Float
}

"""
order by variance() on columns of table "supplement_prices"
"""
input supplement_prices_variance_order_by {
  value: order_by
}

input supplement_save_input {
  description: multilanguage_field_input!
  headline: multilanguage_field_input!
  id: uuid!
  image_id: uuid!
  name: multilanguage_field_input!
  organization_id: uuid!
  price: numeric!
  products: [selected_item!]!
  type: String!
}

"""
select columns of table "supplement"
"""
enum supplement_select_column {
  """column name"""
  description_id

  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  image_id

  """column name"""
  is_optional

  """column name"""
  name_id

  """column name"""
  organization_id

  """column name"""
  price

  """column name"""
  type
}

"""
select "supplement_aggregate_bool_exp_bool_and_arguments_columns" columns of table "supplement"
"""
enum supplement_select_column_supplement_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_optional
}

"""
select "supplement_aggregate_bool_exp_bool_or_arguments_columns" columns of table "supplement"
"""
enum supplement_select_column_supplement_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_optional
}

"""
input type for updating data in table "supplement"
"""
input supplement_set_input {
  description_id: uuid
  headline_id: uuid
  id: uuid
  image_id: uuid
  is_optional: Boolean
  name_id: uuid
  organization_id: uuid
  price: numeric
  type: supplement_type_enum
}

"""aggregate stddev on columns"""
type supplement_stddev_fields {
  price: Float
}

"""
order by stddev() on columns of table "supplement"
"""
input supplement_stddev_order_by {
  price: order_by
}

"""aggregate stddev_pop on columns"""
type supplement_stddev_pop_fields {
  price: Float
}

"""
order by stddev_pop() on columns of table "supplement"
"""
input supplement_stddev_pop_order_by {
  price: order_by
}

"""aggregate stddev_samp on columns"""
type supplement_stddev_samp_fields {
  price: Float
}

"""
order by stddev_samp() on columns of table "supplement"
"""
input supplement_stddev_samp_order_by {
  price: order_by
}

"""
Streaming cursor of the table "supplement"
"""
input supplement_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: supplement_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input supplement_stream_cursor_value_input {
  description_id: uuid
  headline_id: uuid
  id: uuid
  image_id: uuid
  is_optional: Boolean
  name_id: uuid
  organization_id: uuid
  price: numeric
  type: supplement_type_enum
}

"""aggregate sum on columns"""
type supplement_sum_fields {
  price: numeric
}

"""
order by sum() on columns of table "supplement"
"""
input supplement_sum_order_by {
  price: order_by
}

"""
columns and relationships of "supplement_type"
"""
type supplement_type {
  description: String!
  id: String!
}

"""
aggregated selection of "supplement_type"
"""
type supplement_type_aggregate {
  aggregate: supplement_type_aggregate_fields
  nodes: [supplement_type!]!
}

"""
aggregate fields of "supplement_type"
"""
type supplement_type_aggregate_fields {
  count(columns: [supplement_type_select_column!], distinct: Boolean): Int!
  max: supplement_type_max_fields
  min: supplement_type_min_fields
}

"""
Boolean expression to filter rows from the table "supplement_type". All fields are combined with a logical 'AND'.
"""
input supplement_type_bool_exp {
  _and: [supplement_type_bool_exp!]
  _not: supplement_type_bool_exp
  _or: [supplement_type_bool_exp!]
  description: String_comparison_exp
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "supplement_type"
"""
enum supplement_type_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  supplement_type_pkey
}

enum supplement_type_enum {
  """Per pax"""
  PER_PAX

  """Per pax per day"""
  PER_PAX_PER_DAY

  """Per pax per hour"""
  PER_PAX_PER_HOUR

  """Once per unit"""
  PER_UNIT

  """Per unit per day"""
  PER_UNIT_DAY

  """Per unit per hour"""
  PER_UNIT_HOUR
}

"""
Boolean expression to compare columns of type "supplement_type_enum". All fields are combined with logical 'AND'.
"""
input supplement_type_enum_comparison_exp {
  _eq: supplement_type_enum
  _in: [supplement_type_enum!]
  _is_null: Boolean
  _neq: supplement_type_enum
  _nin: [supplement_type_enum!]
}

"""
input type for inserting data into table "supplement_type"
"""
input supplement_type_insert_input {
  description: String
  id: String
}

"""aggregate max on columns"""
type supplement_type_max_fields {
  description: String
  id: String
}

"""aggregate min on columns"""
type supplement_type_min_fields {
  description: String
  id: String
}

"""
response of any mutation on the table "supplement_type"
"""
type supplement_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [supplement_type!]!
}

"""
on_conflict condition type for table "supplement_type"
"""
input supplement_type_on_conflict {
  constraint: supplement_type_constraint!
  update_columns: [supplement_type_update_column!]! = []
  where: supplement_type_bool_exp
}

"""Ordering options when selecting data from "supplement_type"."""
input supplement_type_order_by {
  description: order_by
  id: order_by
}

"""primary key columns input for table: supplement_type"""
input supplement_type_pk_columns_input {
  id: String!
}

"""
select columns of table "supplement_type"
"""
enum supplement_type_select_column {
  """column name"""
  description

  """column name"""
  id
}

"""
input type for updating data in table "supplement_type"
"""
input supplement_type_set_input {
  description: String
  id: String
}

"""
Streaming cursor of the table "supplement_type"
"""
input supplement_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: supplement_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input supplement_type_stream_cursor_value_input {
  description: String
  id: String
}

"""
update columns of table "supplement_type"
"""
enum supplement_type_update_column {
  """column name"""
  description

  """column name"""
  id
}

input supplement_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: supplement_type_set_input

  """filter the rows which have to be updated"""
  where: supplement_type_bool_exp!
}

"""
update columns of table "supplement"
"""
enum supplement_update_column {
  """column name"""
  description_id

  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  image_id

  """column name"""
  is_optional

  """column name"""
  name_id

  """column name"""
  organization_id

  """column name"""
  price

  """column name"""
  type
}

input supplement_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: supplement_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: supplement_set_input

  """filter the rows which have to be updated"""
  where: supplement_bool_exp!
}

"""aggregate var_pop on columns"""
type supplement_var_pop_fields {
  price: Float
}

"""
order by var_pop() on columns of table "supplement"
"""
input supplement_var_pop_order_by {
  price: order_by
}

"""aggregate var_samp on columns"""
type supplement_var_samp_fields {
  price: Float
}

"""
order by var_samp() on columns of table "supplement"
"""
input supplement_var_samp_order_by {
  price: order_by
}

"""aggregate variance on columns"""
type supplement_variance_fields {
  price: Float
}

"""
order by variance() on columns of table "supplement"
"""
input supplement_variance_order_by {
  price: order_by
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "translated_text"
"""
type translated_text {
  de: String
  en: String
  es: String
  fr: String
  id: uuid!
}

"""
aggregated selection of "translated_text"
"""
type translated_text_aggregate {
  aggregate: translated_text_aggregate_fields
  nodes: [translated_text!]!
}

"""
aggregate fields of "translated_text"
"""
type translated_text_aggregate_fields {
  count(columns: [translated_text_select_column!], distinct: Boolean): Int!
  max: translated_text_max_fields
  min: translated_text_min_fields
}

"""
Boolean expression to filter rows from the table "translated_text". All fields are combined with a logical 'AND'.
"""
input translated_text_bool_exp {
  _and: [translated_text_bool_exp!]
  _not: translated_text_bool_exp
  _or: [translated_text_bool_exp!]
  de: String_comparison_exp
  en: String_comparison_exp
  es: String_comparison_exp
  fr: String_comparison_exp
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "translated_text"
"""
enum translated_text_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  translated_text_pkey
}

"""
input type for inserting data into table "translated_text"
"""
input translated_text_insert_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate max on columns"""
type translated_text_max_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate min on columns"""
type translated_text_min_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
response of any mutation on the table "translated_text"
"""
type translated_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [translated_text!]!
}

"""
input type for inserting object relation for remote table "translated_text"
"""
input translated_text_obj_rel_insert_input {
  data: translated_text_insert_input!

  """upsert condition"""
  on_conflict: translated_text_on_conflict
}

"""
on_conflict condition type for table "translated_text"
"""
input translated_text_on_conflict {
  constraint: translated_text_constraint!
  update_columns: [translated_text_update_column!]! = []
  where: translated_text_bool_exp
}

"""Ordering options when selecting data from "translated_text"."""
input translated_text_order_by {
  de: order_by
  en: order_by
  es: order_by
  fr: order_by
  id: order_by
}

"""primary key columns input for table: translated_text"""
input translated_text_pk_columns_input {
  id: uuid!
}

"""
select columns of table "translated_text"
"""
enum translated_text_select_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

"""
input type for updating data in table "translated_text"
"""
input translated_text_set_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
Streaming cursor of the table "translated_text"
"""
input translated_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: translated_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input translated_text_stream_cursor_value_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
update columns of table "translated_text"
"""
enum translated_text_update_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

input translated_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: translated_text_set_input

  """filter the rows which have to be updated"""
  where: translated_text_bool_exp!
}

"""
columns and relationships of "unit_management"
"""
type unit_management {
  description: String!
  id: String!
}

"""
aggregated selection of "unit_management"
"""
type unit_management_aggregate {
  aggregate: unit_management_aggregate_fields
  nodes: [unit_management!]!
}

"""
aggregate fields of "unit_management"
"""
type unit_management_aggregate_fields {
  count(columns: [unit_management_select_column!], distinct: Boolean): Int!
  max: unit_management_max_fields
  min: unit_management_min_fields
}

"""
Boolean expression to filter rows from the table "unit_management". All fields are combined with a logical 'AND'.
"""
input unit_management_bool_exp {
  _and: [unit_management_bool_exp!]
  _not: unit_management_bool_exp
  _or: [unit_management_bool_exp!]
  description: String_comparison_exp
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "unit_management"
"""
enum unit_management_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  unit_management_pkey
}

enum unit_management_enum {
  """
  Availability and price is managed per pax. Each unit have one or more pax.
  """
  PER_PAX

  """
  Availability and price is managed per resource. Each unit gets a resource.
  """
  PER_RESOURCE
}

"""
Boolean expression to compare columns of type "unit_management_enum". All fields are combined with logical 'AND'.
"""
input unit_management_enum_comparison_exp {
  _eq: unit_management_enum
  _in: [unit_management_enum!]
  _is_null: Boolean
  _neq: unit_management_enum
  _nin: [unit_management_enum!]
}

"""
input type for inserting data into table "unit_management"
"""
input unit_management_insert_input {
  description: String
  id: String
}

"""aggregate max on columns"""
type unit_management_max_fields {
  description: String
  id: String
}

"""aggregate min on columns"""
type unit_management_min_fields {
  description: String
  id: String
}

"""
response of any mutation on the table "unit_management"
"""
type unit_management_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [unit_management!]!
}

"""
on_conflict condition type for table "unit_management"
"""
input unit_management_on_conflict {
  constraint: unit_management_constraint!
  update_columns: [unit_management_update_column!]! = []
  where: unit_management_bool_exp
}

"""Ordering options when selecting data from "unit_management"."""
input unit_management_order_by {
  description: order_by
  id: order_by
}

"""primary key columns input for table: unit_management"""
input unit_management_pk_columns_input {
  id: String!
}

"""
select columns of table "unit_management"
"""
enum unit_management_select_column {
  """column name"""
  description

  """column name"""
  id
}

"""
input type for updating data in table "unit_management"
"""
input unit_management_set_input {
  description: String
  id: String
}

"""
Streaming cursor of the table "unit_management"
"""
input unit_management_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: unit_management_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input unit_management_stream_cursor_value_input {
  description: String
  id: String
}

"""
update columns of table "unit_management"
"""
enum unit_management_update_column {
  """column name"""
  description

  """column name"""
  id
}

input unit_management_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: unit_management_set_input

  """filter the rows which have to be updated"""
  where: unit_management_bool_exp!
}

input update_booking_version_with_optimistic_lock_input {
  booking_id: uuid!
  expected_version: numeric!
  new_version: numeric!
}

"""
User account information. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type users {
  activeMfaType: String
  avatarUrl: String!
  createdAt: timestamptz!
  currentChallenge: String
  defaultRole: String!

  """An object relationship"""
  defaultRoleByRole: authRoles!
  disabled: Boolean!
  displayName: String!
  email: citext
  emailVerified: Boolean!
  id: uuid!
  isAnonymous: Boolean!
  lastSeen: timestamptz
  locale: String!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz!
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean!

  """An array relationship"""
  refreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """An aggregate relationship"""
  refreshTokens_aggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """An aggregate relationship"""
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """An array relationship"""
  securityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """An aggregate relationship"""
  securityKeys_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): authUserSecurityKeys_aggregate!
  ticket: String
  ticketExpiresAt: timestamptz!
  totpSecret: String
  updatedAt: timestamptz!

  """An array relationship"""
  userProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """An aggregate relationship"""
  userProviders_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!

  """An array relationship"""
  users_organization_members(
    """distinct select on columns"""
    distinct_on: [organization_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_member_order_by!]

    """filter the rows returned"""
    where: organization_member_bool_exp
  ): [organization_member!]!

  """An aggregate relationship"""
  users_organization_members_aggregate(
    """distinct select on columns"""
    distinct_on: [organization_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organization_member_order_by!]

    """filter the rows returned"""
    where: organization_member_bool_exp
  ): organization_member_aggregate!
}

"""
aggregated selection of "auth.users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

input users_aggregate_bool_exp {
  bool_and: users_aggregate_bool_exp_bool_and
  bool_or: users_aggregate_bool_exp_bool_or
  count: users_aggregate_bool_exp_count
}

input users_aggregate_bool_exp_bool_and {
  arguments: users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_bool_or {
  arguments: users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_count {
  arguments: [users_select_column!]
  distinct: Boolean
  filter: users_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
order by aggregate values of table "auth.users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input users_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "auth.users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  activeMfaType: String_comparison_exp
  avatarUrl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  currentChallenge: String_comparison_exp
  defaultRole: String_comparison_exp
  defaultRoleByRole: authRoles_bool_exp
  disabled: Boolean_comparison_exp
  displayName: String_comparison_exp
  email: citext_comparison_exp
  emailVerified: Boolean_comparison_exp
  id: uuid_comparison_exp
  isAnonymous: Boolean_comparison_exp
  lastSeen: timestamptz_comparison_exp
  locale: String_comparison_exp
  metadata: jsonb_comparison_exp
  newEmail: citext_comparison_exp
  otpHash: String_comparison_exp
  otpHashExpiresAt: timestamptz_comparison_exp
  otpMethodLastUsed: String_comparison_exp
  passwordHash: String_comparison_exp
  phoneNumber: String_comparison_exp
  phoneNumberVerified: Boolean_comparison_exp
  refreshTokens: authRefreshTokens_bool_exp
  refreshTokens_aggregate: authRefreshTokens_aggregate_bool_exp
  roles: authUserRoles_bool_exp
  roles_aggregate: authUserRoles_aggregate_bool_exp
  securityKeys: authUserSecurityKeys_bool_exp
  securityKeys_aggregate: authUserSecurityKeys_aggregate_bool_exp
  ticket: String_comparison_exp
  ticketExpiresAt: timestamptz_comparison_exp
  totpSecret: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userProviders: authUserProviders_bool_exp
  userProviders_aggregate: authUserProviders_aggregate_bool_exp
  users_organization_members: organization_member_bool_exp
  users_organization_members_aggregate: organization_member_aggregate_bool_exp
}

"""
unique or primary key constraints on table "auth.users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  users_email_key

  """
  unique or primary key constraint on columns "phone_number"
  """
  users_phone_number_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input users_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input users_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input users_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "auth.users"
"""
input users_insert_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  defaultRoleByRole: authRoles_obj_rel_insert_input
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  refreshTokens: authRefreshTokens_arr_rel_insert_input
  roles: authUserRoles_arr_rel_insert_input
  securityKeys: authUserSecurityKeys_arr_rel_insert_input
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
  userProviders: authUserProviders_arr_rel_insert_input
  users_organization_members: organization_member_arr_rel_insert_input
}

"""aggregate max on columns"""
type users_max_fields {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  displayName: String
  email: citext
  id: uuid
  lastSeen: timestamptz
  locale: String
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "auth.users"
"""
input users_max_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  defaultRole: order_by
  displayName: order_by
  email: order_by
  id: order_by
  lastSeen: order_by
  locale: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  displayName: String
  email: citext
  id: uuid
  lastSeen: timestamptz
  locale: String
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "auth.users"
"""
input users_min_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  defaultRole: order_by
  displayName: order_by
  email: order_by
  id: order_by
  lastSeen: order_by
  locale: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "auth.users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "auth.users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "auth.users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "auth.users"."""
input users_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  defaultRole: order_by
  defaultRoleByRole: authRoles_order_by
  disabled: order_by
  displayName: order_by
  email: order_by
  emailVerified: order_by
  id: order_by
  isAnonymous: order_by
  lastSeen: order_by
  locale: order_by
  metadata: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  phoneNumberVerified: order_by
  refreshTokens_aggregate: authRefreshTokens_aggregate_order_by
  roles_aggregate: authUserRoles_aggregate_order_by
  securityKeys_aggregate: authUserSecurityKeys_aggregate_order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
  userProviders_aggregate: authUserProviders_aggregate_order_by
  users_organization_members_aggregate: organization_member_aggregate_order_by
}

"""primary key columns input for table: auth.users"""
input users_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input users_prepend_input {
  metadata: jsonb
}

"""
select columns of table "auth.users"
"""
enum users_select_column {
  """column name"""
  activeMfaType

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  currentChallenge

  """column name"""
  defaultRole

  """column name"""
  disabled

  """column name"""
  displayName

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  isAnonymous

  """column name"""
  lastSeen

  """column name"""
  locale

  """column name"""
  metadata

  """column name"""
  newEmail

  """column name"""
  otpHash

  """column name"""
  otpHashExpiresAt

  """column name"""
  otpMethodLastUsed

  """column name"""
  passwordHash

  """column name"""
  phoneNumber

  """column name"""
  phoneNumberVerified

  """column name"""
  ticket

  """column name"""
  ticketExpiresAt

  """column name"""
  totpSecret

  """column name"""
  updatedAt
}

"""
select "users_aggregate_bool_exp_bool_and_arguments_columns" columns of table "auth.users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  disabled

  """column name"""
  emailVerified

  """column name"""
  isAnonymous

  """column name"""
  phoneNumberVerified
}

"""
select "users_aggregate_bool_exp_bool_or_arguments_columns" columns of table "auth.users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  disabled

  """column name"""
  emailVerified

  """column name"""
  isAnonymous

  """column name"""
  phoneNumberVerified
}

"""
input type for updating data in table "auth.users"
"""
input users_set_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input users_stream_cursor_value_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
update columns of table "auth.users"
"""
enum users_update_column {
  """column name"""
  activeMfaType

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  currentChallenge

  """column name"""
  defaultRole

  """column name"""
  disabled

  """column name"""
  displayName

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  isAnonymous

  """column name"""
  lastSeen

  """column name"""
  locale

  """column name"""
  metadata

  """column name"""
  newEmail

  """column name"""
  otpHash

  """column name"""
  otpHashExpiresAt

  """column name"""
  otpMethodLastUsed

  """column name"""
  passwordHash

  """column name"""
  phoneNumber

  """column name"""
  phoneNumberVerified

  """column name"""
  ticket

  """column name"""
  ticketExpiresAt

  """column name"""
  totpSecret

  """column name"""
  updatedAt
}

input users_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: users_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: users_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: users_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: users_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: users_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: users_set_input

  """filter the rows which have to be updated"""
  where: users_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "venue"
"""
type venue {
  """An object relationship"""
  description: venue_description!
  description_id: uuid!

  """An array relationship"""
  facilities(
    """distinct select on columns"""
    distinct_on: [venue_facility_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_facility_order_by!]

    """filter the rows returned"""
    where: venue_facility_bool_exp
  ): [venue_facility!]!

  """An aggregate relationship"""
  facilities_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_facility_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_facility_order_by!]

    """filter the rows returned"""
    where: venue_facility_bool_exp
  ): venue_facility_aggregate!

  """An object relationship"""
  gallery: media_gallery
  gallery_id: uuid

  """An object relationship"""
  good_to_know: venue_good_to_know!
  good_to_know_id: uuid!
  id: uuid!

  """An object relationship"""
  organization: organization!
  organization_id: uuid!

  """An object relationship"""
  place: place!
  place_id: uuid!

  """An object relationship"""
  usps: venue_usps!
  usps_id: uuid!
}

"""
aggregated selection of "venue"
"""
type venue_aggregate {
  aggregate: venue_aggregate_fields
  nodes: [venue!]!
}

input venue_aggregate_bool_exp {
  count: venue_aggregate_bool_exp_count
}

input venue_aggregate_bool_exp_count {
  arguments: [venue_select_column!]
  distinct: Boolean
  filter: venue_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "venue"
"""
type venue_aggregate_fields {
  count(columns: [venue_select_column!], distinct: Boolean): Int!
  max: venue_max_fields
  min: venue_min_fields
}

"""
order by aggregate values of table "venue"
"""
input venue_aggregate_order_by {
  count: order_by
  max: venue_max_order_by
  min: venue_min_order_by
}

"""
input type for inserting array relation for remote table "venue"
"""
input venue_arr_rel_insert_input {
  data: [venue_insert_input!]!

  """upsert condition"""
  on_conflict: venue_on_conflict
}

"""
Boolean expression to filter rows from the table "venue". All fields are combined with a logical 'AND'.
"""
input venue_bool_exp {
  _and: [venue_bool_exp!]
  _not: venue_bool_exp
  _or: [venue_bool_exp!]
  description: venue_description_bool_exp
  description_id: uuid_comparison_exp
  facilities: venue_facility_bool_exp
  facilities_aggregate: venue_facility_aggregate_bool_exp
  gallery: media_gallery_bool_exp
  gallery_id: uuid_comparison_exp
  good_to_know: venue_good_to_know_bool_exp
  good_to_know_id: uuid_comparison_exp
  id: uuid_comparison_exp
  organization: organization_bool_exp
  organization_id: uuid_comparison_exp
  place: place_bool_exp
  place_id: uuid_comparison_exp
  usps: venue_usps_bool_exp
  usps_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "venue"
"""
enum venue_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  venue_pkey
}

"""
columns and relationships of "venue_description"
"""
type venue_description {
  de: String
  en: String
  es: String
  fr: String
  id: uuid!
}

"""
aggregated selection of "venue_description"
"""
type venue_description_aggregate {
  aggregate: venue_description_aggregate_fields
  nodes: [venue_description!]!
}

"""
aggregate fields of "venue_description"
"""
type venue_description_aggregate_fields {
  count(columns: [venue_description_select_column!], distinct: Boolean): Int!
  max: venue_description_max_fields
  min: venue_description_min_fields
}

"""
Boolean expression to filter rows from the table "venue_description". All fields are combined with a logical 'AND'.
"""
input venue_description_bool_exp {
  _and: [venue_description_bool_exp!]
  _not: venue_description_bool_exp
  _or: [venue_description_bool_exp!]
  de: String_comparison_exp
  en: String_comparison_exp
  es: String_comparison_exp
  fr: String_comparison_exp
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "venue_description"
"""
enum venue_description_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  venue_description_pkey
}

"""
input type for inserting data into table "venue_description"
"""
input venue_description_insert_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate max on columns"""
type venue_description_max_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate min on columns"""
type venue_description_min_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
response of any mutation on the table "venue_description"
"""
type venue_description_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [venue_description!]!
}

"""
input type for inserting object relation for remote table "venue_description"
"""
input venue_description_obj_rel_insert_input {
  data: venue_description_insert_input!

  """upsert condition"""
  on_conflict: venue_description_on_conflict
}

"""
on_conflict condition type for table "venue_description"
"""
input venue_description_on_conflict {
  constraint: venue_description_constraint!
  update_columns: [venue_description_update_column!]! = []
  where: venue_description_bool_exp
}

"""Ordering options when selecting data from "venue_description"."""
input venue_description_order_by {
  de: order_by
  en: order_by
  es: order_by
  fr: order_by
  id: order_by
}

"""primary key columns input for table: venue_description"""
input venue_description_pk_columns_input {
  id: uuid!
}

"""
select columns of table "venue_description"
"""
enum venue_description_select_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

"""
input type for updating data in table "venue_description"
"""
input venue_description_set_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
Streaming cursor of the table "venue_description"
"""
input venue_description_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: venue_description_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input venue_description_stream_cursor_value_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
update columns of table "venue_description"
"""
enum venue_description_update_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

input venue_description_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: venue_description_set_input

  """filter the rows which have to be updated"""
  where: venue_description_bool_exp!
}

input venue_facilities_save_input {
  id: String!
  items: [venue_facility_input!]!
}

"""
columns and relationships of "venue_facility"
"""
type venue_facility {
  """An object relationship"""
  headline: venue_facility_headline!
  headline_id: uuid!
  id: uuid!

  """An object relationship"""
  image: files!
  image_id: uuid!

  """An object relationship"""
  name: venue_facility_name!
  name_id: uuid!
  position: smallint!

  """An object relationship"""
  slug: slug!
  slug_id: uuid!

  """An object relationship"""
  venue: venue!
  venue_id: uuid!
}

"""
aggregated selection of "venue_facility"
"""
type venue_facility_aggregate {
  aggregate: venue_facility_aggregate_fields
  nodes: [venue_facility!]!
}

input venue_facility_aggregate_bool_exp {
  count: venue_facility_aggregate_bool_exp_count
}

input venue_facility_aggregate_bool_exp_count {
  arguments: [venue_facility_select_column!]
  distinct: Boolean
  filter: venue_facility_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "venue_facility"
"""
type venue_facility_aggregate_fields {
  avg: venue_facility_avg_fields
  count(columns: [venue_facility_select_column!], distinct: Boolean): Int!
  max: venue_facility_max_fields
  min: venue_facility_min_fields
  stddev: venue_facility_stddev_fields
  stddev_pop: venue_facility_stddev_pop_fields
  stddev_samp: venue_facility_stddev_samp_fields
  sum: venue_facility_sum_fields
  var_pop: venue_facility_var_pop_fields
  var_samp: venue_facility_var_samp_fields
  variance: venue_facility_variance_fields
}

"""
order by aggregate values of table "venue_facility"
"""
input venue_facility_aggregate_order_by {
  avg: venue_facility_avg_order_by
  count: order_by
  max: venue_facility_max_order_by
  min: venue_facility_min_order_by
  stddev: venue_facility_stddev_order_by
  stddev_pop: venue_facility_stddev_pop_order_by
  stddev_samp: venue_facility_stddev_samp_order_by
  sum: venue_facility_sum_order_by
  var_pop: venue_facility_var_pop_order_by
  var_samp: venue_facility_var_samp_order_by
  variance: venue_facility_variance_order_by
}

"""
input type for inserting array relation for remote table "venue_facility"
"""
input venue_facility_arr_rel_insert_input {
  data: [venue_facility_insert_input!]!

  """upsert condition"""
  on_conflict: venue_facility_on_conflict
}

"""aggregate avg on columns"""
type venue_facility_avg_fields {
  position: Float
}

"""
order by avg() on columns of table "venue_facility"
"""
input venue_facility_avg_order_by {
  position: order_by
}

"""
Boolean expression to filter rows from the table "venue_facility". All fields are combined with a logical 'AND'.
"""
input venue_facility_bool_exp {
  _and: [venue_facility_bool_exp!]
  _not: venue_facility_bool_exp
  _or: [venue_facility_bool_exp!]
  headline: venue_facility_headline_bool_exp
  headline_id: uuid_comparison_exp
  id: uuid_comparison_exp
  image: files_bool_exp
  image_id: uuid_comparison_exp
  name: venue_facility_name_bool_exp
  name_id: uuid_comparison_exp
  position: smallint_comparison_exp
  slug: slug_bool_exp
  slug_id: uuid_comparison_exp
  venue: venue_bool_exp
  venue_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "venue_facility"
"""
enum venue_facility_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  venue_facility_pkey
}

"""
columns and relationships of "venue_facility_headline"
"""
type venue_facility_headline {
  de: String
  en: String
  es: String
  fr: String
  id: uuid!
}

"""
aggregated selection of "venue_facility_headline"
"""
type venue_facility_headline_aggregate {
  aggregate: venue_facility_headline_aggregate_fields
  nodes: [venue_facility_headline!]!
}

"""
aggregate fields of "venue_facility_headline"
"""
type venue_facility_headline_aggregate_fields {
  count(columns: [venue_facility_headline_select_column!], distinct: Boolean): Int!
  max: venue_facility_headline_max_fields
  min: venue_facility_headline_min_fields
}

"""
Boolean expression to filter rows from the table "venue_facility_headline". All fields are combined with a logical 'AND'.
"""
input venue_facility_headline_bool_exp {
  _and: [venue_facility_headline_bool_exp!]
  _not: venue_facility_headline_bool_exp
  _or: [venue_facility_headline_bool_exp!]
  de: String_comparison_exp
  en: String_comparison_exp
  es: String_comparison_exp
  fr: String_comparison_exp
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "venue_facility_headline"
"""
enum venue_facility_headline_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  venue_facility_headline_pkey
}

"""
input type for inserting data into table "venue_facility_headline"
"""
input venue_facility_headline_insert_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate max on columns"""
type venue_facility_headline_max_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate min on columns"""
type venue_facility_headline_min_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
response of any mutation on the table "venue_facility_headline"
"""
type venue_facility_headline_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [venue_facility_headline!]!
}

"""
input type for inserting object relation for remote table "venue_facility_headline"
"""
input venue_facility_headline_obj_rel_insert_input {
  data: venue_facility_headline_insert_input!

  """upsert condition"""
  on_conflict: venue_facility_headline_on_conflict
}

"""
on_conflict condition type for table "venue_facility_headline"
"""
input venue_facility_headline_on_conflict {
  constraint: venue_facility_headline_constraint!
  update_columns: [venue_facility_headline_update_column!]! = []
  where: venue_facility_headline_bool_exp
}

"""Ordering options when selecting data from "venue_facility_headline"."""
input venue_facility_headline_order_by {
  de: order_by
  en: order_by
  es: order_by
  fr: order_by
  id: order_by
}

"""primary key columns input for table: venue_facility_headline"""
input venue_facility_headline_pk_columns_input {
  id: uuid!
}

"""
select columns of table "venue_facility_headline"
"""
enum venue_facility_headline_select_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

"""
input type for updating data in table "venue_facility_headline"
"""
input venue_facility_headline_set_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
Streaming cursor of the table "venue_facility_headline"
"""
input venue_facility_headline_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: venue_facility_headline_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input venue_facility_headline_stream_cursor_value_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
update columns of table "venue_facility_headline"
"""
enum venue_facility_headline_update_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

input venue_facility_headline_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: venue_facility_headline_set_input

  """filter the rows which have to be updated"""
  where: venue_facility_headline_bool_exp!
}

"""
input type for incrementing numeric columns in table "venue_facility"
"""
input venue_facility_inc_input {
  position: smallint
}

input venue_facility_input {
  headline: multilanguage_field_input!
  image_id: String!
  name: multilanguage_field_input!
}

"""
input type for inserting data into table "venue_facility"
"""
input venue_facility_insert_input {
  headline: venue_facility_headline_obj_rel_insert_input
  headline_id: uuid
  id: uuid
  image: files_obj_rel_insert_input
  image_id: uuid
  name: venue_facility_name_obj_rel_insert_input
  name_id: uuid
  position: smallint
  slug: slug_obj_rel_insert_input
  slug_id: uuid
  venue: venue_obj_rel_insert_input
  venue_id: uuid
}

"""aggregate max on columns"""
type venue_facility_max_fields {
  headline_id: uuid
  id: uuid
  image_id: uuid
  name_id: uuid
  position: smallint
  slug_id: uuid
  venue_id: uuid
}

"""
order by max() on columns of table "venue_facility"
"""
input venue_facility_max_order_by {
  headline_id: order_by
  id: order_by
  image_id: order_by
  name_id: order_by
  position: order_by
  slug_id: order_by
  venue_id: order_by
}

"""aggregate min on columns"""
type venue_facility_min_fields {
  headline_id: uuid
  id: uuid
  image_id: uuid
  name_id: uuid
  position: smallint
  slug_id: uuid
  venue_id: uuid
}

"""
order by min() on columns of table "venue_facility"
"""
input venue_facility_min_order_by {
  headline_id: order_by
  id: order_by
  image_id: order_by
  name_id: order_by
  position: order_by
  slug_id: order_by
  venue_id: order_by
}

"""
response of any mutation on the table "venue_facility"
"""
type venue_facility_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [venue_facility!]!
}

"""
columns and relationships of "venue_facility_name"
"""
type venue_facility_name {
  de: String
  en: String
  es: String
  fr: String
  id: uuid!
}

"""
aggregated selection of "venue_facility_name"
"""
type venue_facility_name_aggregate {
  aggregate: venue_facility_name_aggregate_fields
  nodes: [venue_facility_name!]!
}

"""
aggregate fields of "venue_facility_name"
"""
type venue_facility_name_aggregate_fields {
  count(columns: [venue_facility_name_select_column!], distinct: Boolean): Int!
  max: venue_facility_name_max_fields
  min: venue_facility_name_min_fields
}

"""
Boolean expression to filter rows from the table "venue_facility_name". All fields are combined with a logical 'AND'.
"""
input venue_facility_name_bool_exp {
  _and: [venue_facility_name_bool_exp!]
  _not: venue_facility_name_bool_exp
  _or: [venue_facility_name_bool_exp!]
  de: String_comparison_exp
  en: String_comparison_exp
  es: String_comparison_exp
  fr: String_comparison_exp
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "venue_facility_name"
"""
enum venue_facility_name_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  venue_facility_name_pkey
}

"""
input type for inserting data into table "venue_facility_name"
"""
input venue_facility_name_insert_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate max on columns"""
type venue_facility_name_max_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate min on columns"""
type venue_facility_name_min_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
response of any mutation on the table "venue_facility_name"
"""
type venue_facility_name_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [venue_facility_name!]!
}

"""
input type for inserting object relation for remote table "venue_facility_name"
"""
input venue_facility_name_obj_rel_insert_input {
  data: venue_facility_name_insert_input!

  """upsert condition"""
  on_conflict: venue_facility_name_on_conflict
}

"""
on_conflict condition type for table "venue_facility_name"
"""
input venue_facility_name_on_conflict {
  constraint: venue_facility_name_constraint!
  update_columns: [venue_facility_name_update_column!]! = []
  where: venue_facility_name_bool_exp
}

"""Ordering options when selecting data from "venue_facility_name"."""
input venue_facility_name_order_by {
  de: order_by
  en: order_by
  es: order_by
  fr: order_by
  id: order_by
}

"""primary key columns input for table: venue_facility_name"""
input venue_facility_name_pk_columns_input {
  id: uuid!
}

"""
select columns of table "venue_facility_name"
"""
enum venue_facility_name_select_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

"""
input type for updating data in table "venue_facility_name"
"""
input venue_facility_name_set_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
Streaming cursor of the table "venue_facility_name"
"""
input venue_facility_name_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: venue_facility_name_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input venue_facility_name_stream_cursor_value_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
update columns of table "venue_facility_name"
"""
enum venue_facility_name_update_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

input venue_facility_name_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: venue_facility_name_set_input

  """filter the rows which have to be updated"""
  where: venue_facility_name_bool_exp!
}

"""
on_conflict condition type for table "venue_facility"
"""
input venue_facility_on_conflict {
  constraint: venue_facility_constraint!
  update_columns: [venue_facility_update_column!]! = []
  where: venue_facility_bool_exp
}

"""Ordering options when selecting data from "venue_facility"."""
input venue_facility_order_by {
  headline: venue_facility_headline_order_by
  headline_id: order_by
  id: order_by
  image: files_order_by
  image_id: order_by
  name: venue_facility_name_order_by
  name_id: order_by
  position: order_by
  slug: slug_order_by
  slug_id: order_by
  venue: venue_order_by
  venue_id: order_by
}

"""primary key columns input for table: venue_facility"""
input venue_facility_pk_columns_input {
  id: uuid!
}

"""
select columns of table "venue_facility"
"""
enum venue_facility_select_column {
  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  image_id

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  slug_id

  """column name"""
  venue_id
}

"""
input type for updating data in table "venue_facility"
"""
input venue_facility_set_input {
  headline_id: uuid
  id: uuid
  image_id: uuid
  name_id: uuid
  position: smallint
  slug_id: uuid
  venue_id: uuid
}

"""aggregate stddev on columns"""
type venue_facility_stddev_fields {
  position: Float
}

"""
order by stddev() on columns of table "venue_facility"
"""
input venue_facility_stddev_order_by {
  position: order_by
}

"""aggregate stddev_pop on columns"""
type venue_facility_stddev_pop_fields {
  position: Float
}

"""
order by stddev_pop() on columns of table "venue_facility"
"""
input venue_facility_stddev_pop_order_by {
  position: order_by
}

"""aggregate stddev_samp on columns"""
type venue_facility_stddev_samp_fields {
  position: Float
}

"""
order by stddev_samp() on columns of table "venue_facility"
"""
input venue_facility_stddev_samp_order_by {
  position: order_by
}

"""
Streaming cursor of the table "venue_facility"
"""
input venue_facility_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: venue_facility_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input venue_facility_stream_cursor_value_input {
  headline_id: uuid
  id: uuid
  image_id: uuid
  name_id: uuid
  position: smallint
  slug_id: uuid
  venue_id: uuid
}

"""aggregate sum on columns"""
type venue_facility_sum_fields {
  position: smallint
}

"""
order by sum() on columns of table "venue_facility"
"""
input venue_facility_sum_order_by {
  position: order_by
}

"""
update columns of table "venue_facility"
"""
enum venue_facility_update_column {
  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  image_id

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  slug_id

  """column name"""
  venue_id
}

input venue_facility_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: venue_facility_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: venue_facility_set_input

  """filter the rows which have to be updated"""
  where: venue_facility_bool_exp!
}

"""aggregate var_pop on columns"""
type venue_facility_var_pop_fields {
  position: Float
}

"""
order by var_pop() on columns of table "venue_facility"
"""
input venue_facility_var_pop_order_by {
  position: order_by
}

"""aggregate var_samp on columns"""
type venue_facility_var_samp_fields {
  position: Float
}

"""
order by var_samp() on columns of table "venue_facility"
"""
input venue_facility_var_samp_order_by {
  position: order_by
}

"""aggregate variance on columns"""
type venue_facility_variance_fields {
  position: Float
}

"""
order by variance() on columns of table "venue_facility"
"""
input venue_facility_variance_order_by {
  position: order_by
}

input venue_gallery_save_input {
  gallery: media_gallery_input!
  id: String!
}

"""
columns and relationships of "venue_good_to_know"
"""
type venue_good_to_know {
  de: String
  en: String
  es: String
  fr: String
  id: uuid!
}

"""
aggregated selection of "venue_good_to_know"
"""
type venue_good_to_know_aggregate {
  aggregate: venue_good_to_know_aggregate_fields
  nodes: [venue_good_to_know!]!
}

"""
aggregate fields of "venue_good_to_know"
"""
type venue_good_to_know_aggregate_fields {
  count(columns: [venue_good_to_know_select_column!], distinct: Boolean): Int!
  max: venue_good_to_know_max_fields
  min: venue_good_to_know_min_fields
}

"""
Boolean expression to filter rows from the table "venue_good_to_know". All fields are combined with a logical 'AND'.
"""
input venue_good_to_know_bool_exp {
  _and: [venue_good_to_know_bool_exp!]
  _not: venue_good_to_know_bool_exp
  _or: [venue_good_to_know_bool_exp!]
  de: String_comparison_exp
  en: String_comparison_exp
  es: String_comparison_exp
  fr: String_comparison_exp
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "venue_good_to_know"
"""
enum venue_good_to_know_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  venue_good_to_know_pkey
}

"""
input type for inserting data into table "venue_good_to_know"
"""
input venue_good_to_know_insert_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate max on columns"""
type venue_good_to_know_max_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""aggregate min on columns"""
type venue_good_to_know_min_fields {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
response of any mutation on the table "venue_good_to_know"
"""
type venue_good_to_know_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [venue_good_to_know!]!
}

"""
input type for inserting object relation for remote table "venue_good_to_know"
"""
input venue_good_to_know_obj_rel_insert_input {
  data: venue_good_to_know_insert_input!

  """upsert condition"""
  on_conflict: venue_good_to_know_on_conflict
}

"""
on_conflict condition type for table "venue_good_to_know"
"""
input venue_good_to_know_on_conflict {
  constraint: venue_good_to_know_constraint!
  update_columns: [venue_good_to_know_update_column!]! = []
  where: venue_good_to_know_bool_exp
}

"""Ordering options when selecting data from "venue_good_to_know"."""
input venue_good_to_know_order_by {
  de: order_by
  en: order_by
  es: order_by
  fr: order_by
  id: order_by
}

"""primary key columns input for table: venue_good_to_know"""
input venue_good_to_know_pk_columns_input {
  id: uuid!
}

"""
select columns of table "venue_good_to_know"
"""
enum venue_good_to_know_select_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

"""
input type for updating data in table "venue_good_to_know"
"""
input venue_good_to_know_set_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
Streaming cursor of the table "venue_good_to_know"
"""
input venue_good_to_know_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: venue_good_to_know_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input venue_good_to_know_stream_cursor_value_input {
  de: String
  en: String
  es: String
  fr: String
  id: uuid
}

"""
update columns of table "venue_good_to_know"
"""
enum venue_good_to_know_update_column {
  """column name"""
  de

  """column name"""
  en

  """column name"""
  es

  """column name"""
  fr

  """column name"""
  id
}

input venue_good_to_know_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: venue_good_to_know_set_input

  """filter the rows which have to be updated"""
  where: venue_good_to_know_bool_exp!
}

"""
input type for inserting data into table "venue"
"""
input venue_insert_input {
  description: venue_description_obj_rel_insert_input
  description_id: uuid
  facilities: venue_facility_arr_rel_insert_input
  gallery: media_gallery_obj_rel_insert_input
  gallery_id: uuid
  good_to_know: venue_good_to_know_obj_rel_insert_input
  good_to_know_id: uuid
  id: uuid
  organization: organization_obj_rel_insert_input
  organization_id: uuid
  place: place_obj_rel_insert_input
  place_id: uuid
  usps: venue_usps_obj_rel_insert_input
  usps_id: uuid
}

input venue_main_save_input {
  description: multilanguage_field_input!
  good_to_know: multilanguage_field_input!
  id: String!
  place: place_input
}

"""aggregate max on columns"""
type venue_max_fields {
  description_id: uuid
  gallery_id: uuid
  good_to_know_id: uuid
  id: uuid
  organization_id: uuid
  place_id: uuid
  usps_id: uuid
}

"""
order by max() on columns of table "venue"
"""
input venue_max_order_by {
  description_id: order_by
  gallery_id: order_by
  good_to_know_id: order_by
  id: order_by
  organization_id: order_by
  place_id: order_by
  usps_id: order_by
}

"""aggregate min on columns"""
type venue_min_fields {
  description_id: uuid
  gallery_id: uuid
  good_to_know_id: uuid
  id: uuid
  organization_id: uuid
  place_id: uuid
  usps_id: uuid
}

"""
order by min() on columns of table "venue"
"""
input venue_min_order_by {
  description_id: order_by
  gallery_id: order_by
  good_to_know_id: order_by
  id: order_by
  organization_id: order_by
  place_id: order_by
  usps_id: order_by
}

"""
response of any mutation on the table "venue"
"""
type venue_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [venue!]!
}

"""
input type for inserting object relation for remote table "venue"
"""
input venue_obj_rel_insert_input {
  data: venue_insert_input!

  """upsert condition"""
  on_conflict: venue_on_conflict
}

"""
on_conflict condition type for table "venue"
"""
input venue_on_conflict {
  constraint: venue_constraint!
  update_columns: [venue_update_column!]! = []
  where: venue_bool_exp
}

"""Ordering options when selecting data from "venue"."""
input venue_order_by {
  description: venue_description_order_by
  description_id: order_by
  facilities_aggregate: venue_facility_aggregate_order_by
  gallery: media_gallery_order_by
  gallery_id: order_by
  good_to_know: venue_good_to_know_order_by
  good_to_know_id: order_by
  id: order_by
  organization: organization_order_by
  organization_id: order_by
  place: place_order_by
  place_id: order_by
  usps: venue_usps_order_by
  usps_id: order_by
}

"""primary key columns input for table: venue"""
input venue_pk_columns_input {
  id: uuid!
}

"""
select columns of table "venue"
"""
enum venue_select_column {
  """column name"""
  description_id

  """column name"""
  gallery_id

  """column name"""
  good_to_know_id

  """column name"""
  id

  """column name"""
  organization_id

  """column name"""
  place_id

  """column name"""
  usps_id
}

"""
input type for updating data in table "venue"
"""
input venue_set_input {
  description_id: uuid
  gallery_id: uuid
  good_to_know_id: uuid
  id: uuid
  organization_id: uuid
  place_id: uuid
  usps_id: uuid
}

"""
Streaming cursor of the table "venue"
"""
input venue_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: venue_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input venue_stream_cursor_value_input {
  description_id: uuid
  gallery_id: uuid
  good_to_know_id: uuid
  id: uuid
  organization_id: uuid
  place_id: uuid
  usps_id: uuid
}

"""
update columns of table "venue"
"""
enum venue_update_column {
  """column name"""
  description_id

  """column name"""
  gallery_id

  """column name"""
  good_to_know_id

  """column name"""
  id

  """column name"""
  organization_id

  """column name"""
  place_id

  """column name"""
  usps_id
}

input venue_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: venue_set_input

  """filter the rows which have to be updated"""
  where: venue_bool_exp!
}

"""
columns and relationships of "venue_usps"
"""
type venue_usps {
  id: uuid!

  """An object relationship"""
  image: files
  image_id: uuid

  """An array relationship"""
  lines(
    """distinct select on columns"""
    distinct_on: [venue_usps_line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_usps_line_order_by!]

    """filter the rows returned"""
    where: venue_usps_line_bool_exp
  ): [venue_usps_line!]!

  """An aggregate relationship"""
  lines_aggregate(
    """distinct select on columns"""
    distinct_on: [venue_usps_line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [venue_usps_line_order_by!]

    """filter the rows returned"""
    where: venue_usps_line_bool_exp
  ): venue_usps_line_aggregate!
}

"""
aggregated selection of "venue_usps"
"""
type venue_usps_aggregate {
  aggregate: venue_usps_aggregate_fields
  nodes: [venue_usps!]!
}

"""
aggregate fields of "venue_usps"
"""
type venue_usps_aggregate_fields {
  count(columns: [venue_usps_select_column!], distinct: Boolean): Int!
  max: venue_usps_max_fields
  min: venue_usps_min_fields
}

"""
Boolean expression to filter rows from the table "venue_usps". All fields are combined with a logical 'AND'.
"""
input venue_usps_bool_exp {
  _and: [venue_usps_bool_exp!]
  _not: venue_usps_bool_exp
  _or: [venue_usps_bool_exp!]
  id: uuid_comparison_exp
  image: files_bool_exp
  image_id: uuid_comparison_exp
  lines: venue_usps_line_bool_exp
  lines_aggregate: venue_usps_line_aggregate_bool_exp
}

"""
unique or primary key constraints on table "venue_usps"
"""
enum venue_usps_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  venue_usps_pkey
}

"""
input type for inserting data into table "venue_usps"
"""
input venue_usps_insert_input {
  id: uuid
  image: files_obj_rel_insert_input
  image_id: uuid
  lines: venue_usps_line_arr_rel_insert_input
}

"""
columns and relationships of "venue_usps_line"
"""
type venue_usps_line {
  """An object relationship"""
  headline: translated_text
  headline_id: uuid!
  id: uuid!

  """An object relationship"""
  name: translated_text!
  name_id: uuid!
  position: smallint!

  """An object relationship"""
  venue_usps: venue_usps!
  venue_usps_id: uuid!
}

"""
aggregated selection of "venue_usps_line"
"""
type venue_usps_line_aggregate {
  aggregate: venue_usps_line_aggregate_fields
  nodes: [venue_usps_line!]!
}

input venue_usps_line_aggregate_bool_exp {
  count: venue_usps_line_aggregate_bool_exp_count
}

input venue_usps_line_aggregate_bool_exp_count {
  arguments: [venue_usps_line_select_column!]
  distinct: Boolean
  filter: venue_usps_line_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "venue_usps_line"
"""
type venue_usps_line_aggregate_fields {
  avg: venue_usps_line_avg_fields
  count(columns: [venue_usps_line_select_column!], distinct: Boolean): Int!
  max: venue_usps_line_max_fields
  min: venue_usps_line_min_fields
  stddev: venue_usps_line_stddev_fields
  stddev_pop: venue_usps_line_stddev_pop_fields
  stddev_samp: venue_usps_line_stddev_samp_fields
  sum: venue_usps_line_sum_fields
  var_pop: venue_usps_line_var_pop_fields
  var_samp: venue_usps_line_var_samp_fields
  variance: venue_usps_line_variance_fields
}

"""
order by aggregate values of table "venue_usps_line"
"""
input venue_usps_line_aggregate_order_by {
  avg: venue_usps_line_avg_order_by
  count: order_by
  max: venue_usps_line_max_order_by
  min: venue_usps_line_min_order_by
  stddev: venue_usps_line_stddev_order_by
  stddev_pop: venue_usps_line_stddev_pop_order_by
  stddev_samp: venue_usps_line_stddev_samp_order_by
  sum: venue_usps_line_sum_order_by
  var_pop: venue_usps_line_var_pop_order_by
  var_samp: venue_usps_line_var_samp_order_by
  variance: venue_usps_line_variance_order_by
}

"""
input type for inserting array relation for remote table "venue_usps_line"
"""
input venue_usps_line_arr_rel_insert_input {
  data: [venue_usps_line_insert_input!]!

  """upsert condition"""
  on_conflict: venue_usps_line_on_conflict
}

"""aggregate avg on columns"""
type venue_usps_line_avg_fields {
  position: Float
}

"""
order by avg() on columns of table "venue_usps_line"
"""
input venue_usps_line_avg_order_by {
  position: order_by
}

"""
Boolean expression to filter rows from the table "venue_usps_line". All fields are combined with a logical 'AND'.
"""
input venue_usps_line_bool_exp {
  _and: [venue_usps_line_bool_exp!]
  _not: venue_usps_line_bool_exp
  _or: [venue_usps_line_bool_exp!]
  headline: translated_text_bool_exp
  headline_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: translated_text_bool_exp
  name_id: uuid_comparison_exp
  position: smallint_comparison_exp
  venue_usps: venue_usps_bool_exp
  venue_usps_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "venue_usps_line"
"""
enum venue_usps_line_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  venue_usps_line_pkey
}

"""
input type for incrementing numeric columns in table "venue_usps_line"
"""
input venue_usps_line_inc_input {
  position: smallint
}

input venue_usps_line_input {
  headline: multilanguage_field_input!
  name: multilanguage_field_input!
}

"""
input type for inserting data into table "venue_usps_line"
"""
input venue_usps_line_insert_input {
  headline: translated_text_obj_rel_insert_input
  headline_id: uuid
  id: uuid
  name: translated_text_obj_rel_insert_input
  name_id: uuid
  position: smallint
  venue_usps: venue_usps_obj_rel_insert_input
  venue_usps_id: uuid
}

"""aggregate max on columns"""
type venue_usps_line_max_fields {
  headline_id: uuid
  id: uuid
  name_id: uuid
  position: smallint
  venue_usps_id: uuid
}

"""
order by max() on columns of table "venue_usps_line"
"""
input venue_usps_line_max_order_by {
  headline_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  venue_usps_id: order_by
}

"""aggregate min on columns"""
type venue_usps_line_min_fields {
  headline_id: uuid
  id: uuid
  name_id: uuid
  position: smallint
  venue_usps_id: uuid
}

"""
order by min() on columns of table "venue_usps_line"
"""
input venue_usps_line_min_order_by {
  headline_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  venue_usps_id: order_by
}

"""
response of any mutation on the table "venue_usps_line"
"""
type venue_usps_line_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [venue_usps_line!]!
}

"""
on_conflict condition type for table "venue_usps_line"
"""
input venue_usps_line_on_conflict {
  constraint: venue_usps_line_constraint!
  update_columns: [venue_usps_line_update_column!]! = []
  where: venue_usps_line_bool_exp
}

"""Ordering options when selecting data from "venue_usps_line"."""
input venue_usps_line_order_by {
  headline: translated_text_order_by
  headline_id: order_by
  id: order_by
  name: translated_text_order_by
  name_id: order_by
  position: order_by
  venue_usps: venue_usps_order_by
  venue_usps_id: order_by
}

"""primary key columns input for table: venue_usps_line"""
input venue_usps_line_pk_columns_input {
  id: uuid!
}

"""
select columns of table "venue_usps_line"
"""
enum venue_usps_line_select_column {
  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  venue_usps_id
}

"""
input type for updating data in table "venue_usps_line"
"""
input venue_usps_line_set_input {
  headline_id: uuid
  id: uuid
  name_id: uuid
  position: smallint
  venue_usps_id: uuid
}

"""aggregate stddev on columns"""
type venue_usps_line_stddev_fields {
  position: Float
}

"""
order by stddev() on columns of table "venue_usps_line"
"""
input venue_usps_line_stddev_order_by {
  position: order_by
}

"""aggregate stddev_pop on columns"""
type venue_usps_line_stddev_pop_fields {
  position: Float
}

"""
order by stddev_pop() on columns of table "venue_usps_line"
"""
input venue_usps_line_stddev_pop_order_by {
  position: order_by
}

"""aggregate stddev_samp on columns"""
type venue_usps_line_stddev_samp_fields {
  position: Float
}

"""
order by stddev_samp() on columns of table "venue_usps_line"
"""
input venue_usps_line_stddev_samp_order_by {
  position: order_by
}

"""
Streaming cursor of the table "venue_usps_line"
"""
input venue_usps_line_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: venue_usps_line_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input venue_usps_line_stream_cursor_value_input {
  headline_id: uuid
  id: uuid
  name_id: uuid
  position: smallint
  venue_usps_id: uuid
}

"""aggregate sum on columns"""
type venue_usps_line_sum_fields {
  position: smallint
}

"""
order by sum() on columns of table "venue_usps_line"
"""
input venue_usps_line_sum_order_by {
  position: order_by
}

"""
update columns of table "venue_usps_line"
"""
enum venue_usps_line_update_column {
  """column name"""
  headline_id

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  venue_usps_id
}

input venue_usps_line_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: venue_usps_line_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: venue_usps_line_set_input

  """filter the rows which have to be updated"""
  where: venue_usps_line_bool_exp!
}

"""aggregate var_pop on columns"""
type venue_usps_line_var_pop_fields {
  position: Float
}

"""
order by var_pop() on columns of table "venue_usps_line"
"""
input venue_usps_line_var_pop_order_by {
  position: order_by
}

"""aggregate var_samp on columns"""
type venue_usps_line_var_samp_fields {
  position: Float
}

"""
order by var_samp() on columns of table "venue_usps_line"
"""
input venue_usps_line_var_samp_order_by {
  position: order_by
}

"""aggregate variance on columns"""
type venue_usps_line_variance_fields {
  position: Float
}

"""
order by variance() on columns of table "venue_usps_line"
"""
input venue_usps_line_variance_order_by {
  position: order_by
}

"""aggregate max on columns"""
type venue_usps_max_fields {
  id: uuid
  image_id: uuid
}

"""aggregate min on columns"""
type venue_usps_min_fields {
  id: uuid
  image_id: uuid
}

"""
response of any mutation on the table "venue_usps"
"""
type venue_usps_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [venue_usps!]!
}

"""
input type for inserting object relation for remote table "venue_usps"
"""
input venue_usps_obj_rel_insert_input {
  data: venue_usps_insert_input!

  """upsert condition"""
  on_conflict: venue_usps_on_conflict
}

"""
on_conflict condition type for table "venue_usps"
"""
input venue_usps_on_conflict {
  constraint: venue_usps_constraint!
  update_columns: [venue_usps_update_column!]! = []
  where: venue_usps_bool_exp
}

"""Ordering options when selecting data from "venue_usps"."""
input venue_usps_order_by {
  id: order_by
  image: files_order_by
  image_id: order_by
  lines_aggregate: venue_usps_line_aggregate_order_by
}

"""primary key columns input for table: venue_usps"""
input venue_usps_pk_columns_input {
  id: uuid!
}

input venue_usps_save_input {
  id: uuid!
  image_id: uuid!
  lines: [venue_usps_line_input!]!
}

"""
select columns of table "venue_usps"
"""
enum venue_usps_select_column {
  """column name"""
  id

  """column name"""
  image_id
}

"""
input type for updating data in table "venue_usps"
"""
input venue_usps_set_input {
  id: uuid
  image_id: uuid
}

"""
Streaming cursor of the table "venue_usps"
"""
input venue_usps_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: venue_usps_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input venue_usps_stream_cursor_value_input {
  id: uuid
  image_id: uuid
}

"""
update columns of table "venue_usps"
"""
enum venue_usps_update_column {
  """column name"""
  id

  """column name"""
  image_id
}

input venue_usps_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: venue_usps_set_input

  """filter the rows which have to be updated"""
  where: venue_usps_bool_exp!
}

"""
columns and relationships of "storage.virus"
"""
type virus {
  createdAt: timestamptz!

  """An object relationship"""
  file: files!
  fileId: uuid!
  filename: String!
  id: uuid!
  updatedAt: timestamptz!
  userSession(
    """JSON select path"""
    path: String
  ): jsonb!
  virus: String!
}

"""
aggregated selection of "storage.virus"
"""
type virus_aggregate {
  aggregate: virus_aggregate_fields
  nodes: [virus!]!
}

"""
aggregate fields of "storage.virus"
"""
type virus_aggregate_fields {
  count(columns: [virus_select_column!], distinct: Boolean): Int!
  max: virus_max_fields
  min: virus_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input virus_append_input {
  userSession: jsonb
}

"""
Boolean expression to filter rows from the table "storage.virus". All fields are combined with a logical 'AND'.
"""
input virus_bool_exp {
  _and: [virus_bool_exp!]
  _not: virus_bool_exp
  _or: [virus_bool_exp!]
  createdAt: timestamptz_comparison_exp
  file: files_bool_exp
  fileId: uuid_comparison_exp
  filename: String_comparison_exp
  id: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userSession: jsonb_comparison_exp
  virus: String_comparison_exp
}

"""
unique or primary key constraints on table "storage.virus"
"""
enum virus_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  virus_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input virus_delete_at_path_input {
  userSession: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input virus_delete_elem_input {
  userSession: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input virus_delete_key_input {
  userSession: String
}

"""
input type for inserting data into table "storage.virus"
"""
input virus_insert_input {
  createdAt: timestamptz
  file: files_obj_rel_insert_input
  fileId: uuid
  filename: String
  id: uuid
  updatedAt: timestamptz
  userSession: jsonb
  virus: String
}

"""aggregate max on columns"""
type virus_max_fields {
  createdAt: timestamptz
  fileId: uuid
  filename: String
  id: uuid
  updatedAt: timestamptz
  virus: String
}

"""aggregate min on columns"""
type virus_min_fields {
  createdAt: timestamptz
  fileId: uuid
  filename: String
  id: uuid
  updatedAt: timestamptz
  virus: String
}

"""
response of any mutation on the table "storage.virus"
"""
type virus_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [virus!]!
}

"""
on_conflict condition type for table "storage.virus"
"""
input virus_on_conflict {
  constraint: virus_constraint!
  update_columns: [virus_update_column!]! = []
  where: virus_bool_exp
}

"""Ordering options when selecting data from "storage.virus"."""
input virus_order_by {
  createdAt: order_by
  file: files_order_by
  fileId: order_by
  filename: order_by
  id: order_by
  updatedAt: order_by
  userSession: order_by
  virus: order_by
}

"""primary key columns input for table: storage.virus"""
input virus_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input virus_prepend_input {
  userSession: jsonb
}

"""
select columns of table "storage.virus"
"""
enum virus_select_column {
  """column name"""
  createdAt

  """column name"""
  fileId

  """column name"""
  filename

  """column name"""
  id

  """column name"""
  updatedAt

  """column name"""
  userSession

  """column name"""
  virus
}

"""
input type for updating data in table "storage.virus"
"""
input virus_set_input {
  createdAt: timestamptz
  fileId: uuid
  filename: String
  id: uuid
  updatedAt: timestamptz
  userSession: jsonb
  virus: String
}

"""
Streaming cursor of the table "virus"
"""
input virus_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: virus_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input virus_stream_cursor_value_input {
  createdAt: timestamptz
  fileId: uuid
  filename: String
  id: uuid
  updatedAt: timestamptz
  userSession: jsonb
  virus: String
}

"""
update columns of table "storage.virus"
"""
enum virus_update_column {
  """column name"""
  createdAt

  """column name"""
  fileId

  """column name"""
  filename

  """column name"""
  id

  """column name"""
  updatedAt

  """column name"""
  userSession

  """column name"""
  virus
}

input virus_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: virus_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: virus_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: virus_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: virus_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: virus_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: virus_set_input

  """filter the rows which have to be updated"""
  where: virus_bool_exp!
}

